#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: grepstrassen,v 1.13 2006/02/14 20:09:15 eserte Exp $
# Author: Slaven Rezic
#

# Strassen-Dateien filtern
# Similar to Strassen::CoreHeavy::grepstreets

use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../data",
	 "$FindBin::RealBin/../lib",
	);
use Strassen::Core;
use Strassen::Stat;
use strict;

use Getopt::Long;
my($v, $cat, $catrx, $name, $namerx, $section, $sectionrx);
my($minarea, $minlength);
my $preserveglobaldirectives;
my %special;
my %special_end;
my %type_s;
GetOptions("v" => \$v,
	   "cat=s" => \$cat,
	   "catrx=s" => \$catrx,
	   "name=s" => \$name,
	   "namerx=s" => \$namerx,
	   "section=s" => \$section,
	   "sectionrx=s" => \$sectionrx,
	   "special=s" => sub {
	       my $type = $_[1];
	       no strict 'refs';
	       &{"init_" . $type}($type);
	   },
	   "adddirectives=s" => sub {
	       my $type = $_[1];
	       init_directive_handler($type);
	   },
	   "preserveglobaldirectives!" => \$preserveglobaldirectives,
	   "minarea=f" => \$minarea,
	   "minlength=f" => \$minlength,
	  ) or die <<EOF;
usage: $0 [-v] [-cat category] [-catrx regexp]
       [-name name] [-namerx regexp]
       [-section section] [-sectionrx regexp]
       [-special name] [-minarea ...km²] [-minlength ...km]
       [-preserveglobaldirectives]

section is a region marked with the "section" directive in a bbd file.

EOF

$catrx = qr{$catrx} if $catrx;
$namerx = qr{$namerx} if $namerx;
$sectionrx = qr{$sectionrx} if $sectionrx;
$minarea = $minarea*(1000*1000) if defined $minarea;
$minlength = $minlength*1000 if defined $minlength;

my $datafile = shift || "-";

my $s = Strassen->new($datafile, UseLocalDirectives => 1, PreserveLineInfo => 1);
my $new_s = Strassen->new;
$s->init;
while(1) {
    my $r = $s->next;
    if (!$r->[1]) {
	die "Empty coords array found in line " . $s->line . ", file " . $datafile;
    }
    last if !@{ $r->[1] };
    if (defined $name) { if ($r->[0] eq $name) { next if $v } else { next unless $v } }
    if (defined $namerx) { if ($r->[0] =~ $namerx) { next if $v } else { next unless $v } }
    if (defined $cat) { if ($r->[2] eq $cat) { next if $v } else { next unless $v } }
    if (defined $catrx) { if ($r->[2] =~ $catrx) { next if $v } else { next unless $v } }
    my $dir = $s->get_directive;
    if (defined $section) { if (defined $dir->{section} && grep { $_ eq $section } @{ $dir->{section} }) { next if $v } else { next unless $v } }
    if (defined $sectionrx) { if (defined $dir->{section} && grep { /$sectionrx/ } @{ $dir->{section} }) { next if $v } else { next unless $v } }
    if (defined $minarea && $r->[2] =~ /^F:/) { if (Strassen::area($r) >= $minarea) { next if $v } else { next unless $v } }
    if (defined $minlength && $r->[2] !~ /^F:/ && @{$r->[1]} > 1) { if (Strassen::total_len($r) >= $minlength) { next if $v } else { next unless $v } }	
    while(my($k,$v) = each %special) {
	next if !$v->($r, $dir);
    }
    $new_s->push_ext($r, $dir);
}

while(my($k,$v) = each %special_end) {
    $v->();
}

if ($preserveglobaldirectives) {
    my $global_directives = $s->get_global_directives;
    if ($global_directives && keys %$global_directives) {
	for my $directive (keys %$global_directives) {
	    print join("", map { "#: $directive $_\n" } @{ $global_directives->{$directive} });
	    if ($directive eq 'encoding') {
		binmode STDOUT, ":encoding(" . $global_directives->{$directive}->[0] . ")";
	    }
	}
	print "#:\n"; # end
    }
} else {
    # Only preserve some importing global directives:
    my $comment_directives = $s->get_global_directives->{'#'};
    if ($comment_directives) {
	print join("", map { "#:# $_\n" } @$comment_directives);
    }
    my $encoding_directive = $s->get_global_directives->{'encoding'}->[0];
    if ($encoding_directive) {
	print "#: encoding: $encoding_directive\n";
	binmode STDOUT, ":encoding($encoding_directive)";
    }
}

# XXX The "# filtered" is a hack to prevent the first line being interpreted
# as a global directive.
print "# filtered\n" . $new_s->as_string;

sub init_directive_handler {
    my $type = shift;
    $special{$type} = sub { special_directive_handler($type, @_) };
    require Storable;
    $type_s{$type} = Strassen->new;
    $special_end{$type} = sub { end_directive_handler($type, @_) };
}

sub special_directive_handler {
    my($type, $r, $dir) = @_;
    my $new_r = Storable::dclone($r);
    if (exists $dir->{$type}) {
	my $name = $r->[Strassen::NAME] . " (";
	my @add_names = grep { !/^\s*$/ } @{ $dir->{$type} };
	if (!@add_names) {
	    @add_names = $type eq 'fragezeichen' ? "unsicher" : $type;
	}
	$name .= join("; ", @add_names);
	$name .= ")";
	$new_r->[Strassen::NAME] = $name;
	$new_r->[Strassen::CAT] = "?";
	$type_s{$type}->push($new_r);
    }
    1;
}

sub end_directive_handler {
    my($type) = @_;
    require File::Basename;
    $type_s{$type}->write("/tmp/" . $type . "_" . File::Basename::basename($datafile) . ".bbd");
}

######################################################################
# XXX obsolete: could be replaced by -adddirectives add_fragezeichen
# BUT! this would create files /tmp/add_fragezeichen... instead of
# /tmp/fragezeichen...
# XXX Cannot handle encoding directive
sub init_fragezeichen {
    my $val = shift;
    no strict 'refs';
    $special{$val} = \&{"special_" . $val};
    require Storable;
    use vars qw($fragezeichen_s);
    $fragezeichen_s = Strassen->new;
    $special_end{$val} = \&{"end_" . $val};
}

sub special_fragezeichen {
    my($r, $dir) = @_;
    my $fragezeichen_r = Storable::dclone($r);
    if (exists $dir->{add_fragezeichen}) {
	my $name = $r->[Strassen::NAME] . " (";
	my @add_names = grep { !/^\s*$/ } @{ $dir->{add_fragezeichen} };
	if (!@add_names) {
	    @add_names = "unsicher";
	}
	$name .= join("; ", @add_names);
	$name .= ")";
	$fragezeichen_r->[Strassen::NAME] = $name;
	$fragezeichen_r->[Strassen::CAT] = "?";
	$fragezeichen_s->push($fragezeichen_r);
    }
    1;
}

sub end_fragezeichen {
    require File::Basename;
    $fragezeichen_s->write("/tmp/fragezeichen_" . File::Basename::basename($datafile) . ".bbd");
}

__END__
