#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: check_str_plz,v 1.27 2007/08/26 21:23:03 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 1998,2004,2005 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: eserte@users.sourceforge.net
# WWW:  http://bbbike.sourceforge.net
#

# überprüft Straßennamen gegen die PLZ-Datei

use Getopt::Long;
use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
use File::Basename qw(basename);
use Strassen;
use PLZ;
use Symbol;

use strict;

unshift(@Strassen::datadirs, "$FindBin::RealBin/../data");

my $do_multi_bez = 1;
my $datafile = "strassen";
my $ignore_in_parens = 1;
my $ignore_bracket_part = 1;
my $plzfield = PLZ::FILE_ZIP();
my $plzdata;
my $addstr;
my $do_check_coords;
my $ignore_plz_warnings;

GetOptions("plzdata=s"  => \$plzdata,
	   "plzfield=i" => \$plzfield,
	   "addstr=s"   => \$addstr,
	   "multibez!"  => \$do_multi_bez,
	   "data=s"     => \$datafile,
	   "ignoreparens!" => \$ignore_in_parens,
	   "ignorebracketpart!" => \$ignore_bracket_part, # ignore [...]
	   "ignoreplzwarnings!" => \$ignore_plz_warnings,
	   "checkcoords!" => \$do_check_coords,
	  ) or die <<EOF;
usage: $0 [-plzdata plzdatafile] [-plzfield fieldindex]
	  [-addstr bbdfile] [-[no]multibez] [-[no]checkcoords]
	  [-[no]ignoreparens] [-[no]ignorebracketpart] [-ignoreplzwarnings]
	  -data bbdfile
EOF

my $plz;
if (!defined $plzdata) {
    $plz = PLZ->new();
    $plzdata = $plz->{File};
}

my %str_in_plz;
my %str_in_plz2;
my %str_coord;
my %str_coord_without_bezirk;
my $fh = gensym;
open($fh, $plzdata) or die "$plzdata: $!";
while(<$fh>) {
    chomp;
    my(@l) = split(/\|/, $_);
    $str_in_plz{$l[0]}->{$l[1]}++;
    $l[$plzfield]="" if $ignore_plz_warnings && !defined $l[$plzfield]; # may happen for example in Potsdam.coords.data
    $str_in_plz2{$l[0]}->{$l[$plzfield]}++;
    $str_coord{$l[PLZ::FILE_NAME()]}->{$l[PLZ::FILE_CITYPART()]}
	= $l[PLZ::FILE_COORD()];
    $str_coord_without_bezirk{$l[PLZ::FILE_NAME()]}
	= $l[PLZ::FILE_COORD()];
}
close $fh;

if (!defined $addstr) {
    foreach (@Strassen::datadirs) {
	$addstr = "$_/add_str";
	if (-f $addstr && -r $addstr) {
	    last;
	} else {
	    undef $addstr;
	}
    }
}

open(D, $addstr) or die "$addstr: $!";
while(<D>) {
    chomp;
    my($str, $bez) = split(/\t/, $_);
    $bez = "XXX[FROM $addstr]XXX" if !$bez;
    $str_in_plz{$str}->{$bez}++;
    $str_coord{$str}->{$bez} = "XXX";
    $str_coord_without_bezirk{$str} = "XXX";
}
close D;

my %str_in_multi_bez;
if ($do_multi_bez) {
    my $multi_bez_str = MultiBezStr->new("multi_bez_str-orig");
    if ($multi_bez_str) {
	my $k;
	my %h = $multi_bez_str->hash;
	while(my($k, $v) = each %h) {
	    $str_in_multi_bez{$k} = join(",", sort @$v);
	}
    } else {
	warn "Can't set multi_bez_str";
    }
}

my @lastbezirk;
my $lastname;
my @coords;
my $check_coords = sub {
    return unless $do_check_coords;
    my $check_against;
    if (exists $str_coord{$lastname}) {
	if (keys %{ $str_coord{$lastname} } == 1) {
	    while(my($k,$v) = each %{ $str_coord{$lastname} }) {
		$check_against = $v;
		last;
	    }
	} else {
	    for my $bezirk (@lastbezirk) {
		if (exists $str_coord{$lastname}->{$bezirk}) {
		    $check_against = $str_coord{$lastname}->{$bezirk};
		    last;
		}
	    }
	    # else use first
	    while(my($k,$v) = each %{ $str_coord{$lastname} }) {
		$check_against = $v;
		last;
	    }
	}
    }
    if (!$check_against) {
	warn "Can't find any coordinate for $lastname @lastbezirk\n";
    } elsif (!grep { $_ eq $check_against } @coords) {
	warn "Can't find coordinate $check_against for $lastname @lastbezirk\n";
    }
};

my @ambiguous;
my @unknown;
my @unknown2;
my @no_coord;

my $s = new Strassen $datafile;
$s->init;
while(1) {
    my $ret = $s->next;
    last if !@{$ret->[1]};
    my $name = $ret->[0];

    if ($ignore_in_parens && $name =~ /^\(.*\)$/) {
	next;
    }

    if ($ignore_bracket_part) {
	$name =~ s{\s+\[.*?\]\s*}{ }g;
	$name =~ s{ +$}{};
    }

    my @bezirk;
    if ($name =~ s/\s+\(([^\(]+)\)$//) {
	foreach (split(/,\s*/, $1)) {
	    push(@bezirk, $_) unless /\?/ || /^(?:F|R)\s*\d+$/;
	}
    }

    if (defined $lastname && $name eq $lastname) {
	push @coords, @{$ret->[Strassen::COORDS()]};
	next;
    } else {
	if (defined $lastname && @coords) {
	    $check_coords->();
	}
	@coords = @{$ret->[Strassen::COORDS()]};
    }

    if (!@bezirk) {
	if (exists $str_in_plz{$name} &&
	    exists $str_in_plz2{$name}) {
	    my $k1 = keys %{$str_in_plz{$name}};
	    my $k2 = keys %{$str_in_plz2{$name}};
	    if ($k1 > 1 && $k2 > 1) {
		my(@b) = keys %{$str_in_plz{$name}};
		if (!exists $str_in_multi_bez{$name} ||
		    $str_in_multi_bez{$name} ne join(",", sort @b)) {
		    push @ambiguous, $name;
		}
	    }
	}
    }
    if (!exists $str_in_plz{$name}) {
	push(@unknown, $name);
    } elsif (@bezirk && $name !~ /^\(/) {
	foreach my $bezirk (@bezirk) {
	    if (!exists $str_in_plz{$name}->{$bezirk}) {
		push(@unknown2, $name);
	    }
	}
    }
    if (exists $str_in_plz{$name}) {
	if (@bezirk) {
	    for my $bezirk (@bezirk) {
		if (!$str_coord{$name}->{$bezirk}) {
		    push(@no_coord, $name);
		}
	    }
	} else {
	    if (!$str_coord_without_bezirk{$name}) {
		push(@no_coord, $name);
	    }
	}
    }

    $lastname = $name;
    @lastbezirk = @bezirk;
}
$check_coords->();

if (@unknown || @unknown2 || @ambiguous || @no_coord) {
    print "="x70,"\n", join("\n", sort @unknown), "\n";
    print "="x70,"\n", join("\n", sort @unknown2), "\n";
    print "="x70,"\n";
    if (@no_coord) {
	print "= No coordinate in " . basename($plzdata) . " for:\n";
	print join("\n", sort @no_coord), "\n";
    }
    print "="x70,"\n";
    if (@ambiguous) {
	print "= Add to file multi_bez_str-orig or add citypart name to street:\n";
	foreach (sort @ambiguous) {
	    print "$_<TAB>", join(",", keys %{$str_in_plz{$_}}), "\n";
	}
    }
    exit 1;
} else {
    exit 0;
}

