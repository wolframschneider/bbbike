#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: any2bbd,v 1.20 2007/08/12 19:00:10 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2005,2006 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);
use Hash::Util qw(lock_keys);

use Archive::Zip qw(:ERROR_CODES);
use File::Temp qw(tempfile);
use File::Basename qw(basename dirname);
use Getopt::Long;

use Strassen::Gpsman;
use Strassen::Core;
use Strassen::MultiStrassen;

# XXX problematisch: die .g7t-Waypoints-Dateien, die Zeilen ohne Koordinaten erzeugen!

my %opt;

GetOptions(\%opt,
	   "dir=s",
	   'exclude=s@',
	   'excluderx=s@',
	   "o=s",
	   "append|a!",
	   "inputformat|i=s",
	   "routenamefmt=s",
	   "infotobbd!",
	  )
    or die <<EOF;
usage: $0 [-i inputformat] -o outfile [-a|-append]
    [-routenamefmt ...] [-dir download-dir | files ...]
    [-exclude basename [-exclude ...]]
    [-excluderx rx [-excluderx ...]]
    [-infotobbd]
EOF

my $download_dir = $opt{dir} if defined $opt{dir};
my $outfile = $opt{o} || die "Missing option -o for output file, use -o - for stdout";
my $routenamefmt = $opt{routenamefmt} || "%b";
my %exclude = map {($_,1)} @{ $opt{exclude} || [] };
my $excludebyrx = sub {
    return if !$opt{excluderx};
    for (@{ $opt{excluderx} }) {
	return 1 if ($_[0] =~ m{$_}i);
    }
    0;
};
my $do_infotobbd = $opt{infotobbd} || 0;

my @files = @ARGV;
if (!@files) {
    if (defined $download_dir) {
	@files = glob("$download_dir/*");
    }
}

my @s;
for my $file (@files) {
    next if $exclude{ basename($file) };
    next if $excludebyrx->($file);
    print STDERR "$file... ";
    my %info = (handled_by => "?", file => $file, subfile => undef);
    lock_keys %info;

    my $check_s = sub {
	my $s = shift;
	if ($s && $s->data && @{ $s->data }) {
	    print STDERR "OK ($info{handled_by})\n";
	    1;
	} else {
	    print STDERR "no GPS data\n";
	    0;
	}
    };

    eval {
	if ($file =~ /\.zip$/i) {
	    my $zip = Archive::Zip->new;
	    $zip->read($file) == AZ_OK or die;
	    print STDERR "\n";
	    for my $member ($zip->members) {
		next if $exclude{ basename($member->fileName) };
		next if $excludebyrx->($member->fileName);
		print STDERR "  " . $member->fileName . "... ";
		$info{subfile} = $member->fileName;
		my($suffix) = $member->fileName =~ /(\.[^\.]+)$/;
		my($tmpfh,$tmpfile) = tempfile(UNLINK => 1,
					       SUFFIX => $suffix,
					      );
		print $tmpfh ($member->contents)[0];
		close $tmpfh;
		my $s = run_gpsbabel($tmpfile,
				     title => routenamefmt($file . "/" . basename($member->fileName)),
				     info => \%info,
				    );
		if ($check_s->($s)) {
		    prepend_info($s, \%info);
		    push @s, $s;
		}
	    }
	} else {
	    my $s = run_gpsbabel($file, title => routenamefmt($file),
				 info => \%info);
	    if ($check_s->($s)) {
		prepend_info($s, \%info);
		push @s, $s;
	    }
	}
    };
    warn $@ if $@;
}

if (!@s) {
    warn "No usable input files (tried @files), do not write anything...\n";
    exit 0;
}

my $ms = MultiStrassen->new(@s);
if ($opt{append}) {
    $ms->append($outfile);
} else {
    $ms->write($outfile);
}

# XXX use GPS::Gpsbabel::run_gpsbabel instead!
sub run_gpsbabel {
    my($file, %args) = @_;
    my $title = $args{title} || $file;
    my $info = $args{info} || {};
    my $cat = "#000080";
    if ($opt{inputformat}) {
	my $s = eval {
	    require Strassen::FromRoute;
	    Strassen::FromRoute->new($file, name => $title);
	};
	if ($s) {
	    $info->{handled_by} = "Strassen::FromRoute";
	    return $s;
	}
    }
    if ($file =~ m{( \.(dbf|sbn|sbx|shp|shx)$
		   | \.(mif|mid)$
		   | \.e00$
		   | \.mps$
		   | \.g7t$
		   | \.gpx$
		   | \.kml$
		   | \.kmz$
		   | \.ovl$
		   | \.gpx$
		   )
	          }xi) {
	my $s = eval { Strassen->new($file, name => $title, cat => $cat) };
	if ($s) {
	    $info->{handled_by} = ref $s;
	    return $s;
	} else {
	    warn $@;
	}
    }

    if (open(my $fh, $file)) {
	my $first_line = <$fh>;
	if ($first_line =~ /^%.*(gpsmanager|gps::gpsmanconn)/i) {
	    close $fh;
	    my $s = Strassen::Gpsman->new($file,
					  cat => $cat,
					  fallbackname => $title);
	    if ($s) {
		$info->{handled_by} = "Strassen::Gpsman";
		return $s;
	    }
	}
    }

    # XXX should really check magic before trying, i.e. 2nd line should match
    # /^I\s+PCX5/
    my $in_fmt = "pcx";
    my $out_fmt;
    if (eval { require Strassen::GPX; 1 }) {
	# Prefer gpx output, because gpsbabel's pcx->gpx conversion is
	# better than pcx->gpsman.
	#
	# Downside: handling GPX is *MUCH* slower
	$out_fmt = "gpx";
    } else {
	$out_fmt = "gpsman";
    }
    if ($file =~ /\.gpx$/) {
	$in_fmt = "gpx";
	$out_fmt = "gpsman";
    }
    my($ofh,$ofilename) = tempfile(UNLINK => 1,
				   SUFFIX => "_any2bbd.$out_fmt");
    system("gpsbabel", "-t",
	   "-i", $in_fmt, "-f", $file,
	   "-o", $out_fmt, -F, $ofilename);
    $info->{handled_by} = "gpsbabel";

    if ($out_fmt eq 'gpsman') {
	# Hack: set track name
	my($o2fh,$o2filename) = tempfile(UNLINK => 1);
	open(F, $ofilename) or die $!;
	while(<F>) {
	    s/(^!T:)/$1\t$title/;
	    print $o2fh $_;
	}
	close F;
	close $o2fh;
	$ofilename = $o2filename;
    }

    my $s;
    if ($out_fmt eq 'gpsman') {
	$s = Strassen::Gpsman->new($ofilename,
				   cat => $cat,
				   fallbackname => $title);
	$info->{handled_by} .= " and Strassen::Gpsman";
    } elsif ($out_fmt eq 'gpx') {
	$s = eval { Strassen->new($ofilename,
				  cat => $cat,
				  name => $title)
		};
	$info->{handled_by} .= " and " . ref($s);
    } else {
	die "Shouldn't happen: out_fmt=<$out_fmt>";
    }
    $s;
}

sub routenamefmt {
    my($file) = @_;
    my $rv = $routenamefmt;
    $rv =~ s{%b}{ basename($file) }ge;
    $rv =~ s{%f}{ $file }g;
    $rv =~ s{%d}{ basename(dirname($file)) }ge;
    $rv =~ s{%D}{ dirname($file) }ge;
    $rv;
}

# XXX Should go to Strassen::?
sub prepend_info {
    return if !$do_infotobbd;
    my($s, $info) = @_;
    unshift @{ $s->data },
	"# source file: $info->{file}" . ($info->{subfile} ? "#$info->{subfile}" : "") . "\n",
	    "# handled_by: $info->{handled_by}\n";
}

__END__
