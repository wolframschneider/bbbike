#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2009,2011 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use warnings;

sub usage (;$) {
    my $msg = shift;
    warn $msg, "\n" if $msg;
    die <<EOF;
usage: $0 task
EOF
}

my $task = shift
    or usage("Task is missing");

if ($task eq 'yml_to_permanent_bbd') {
    warn "WARNING: Please rename 'yml_to_permanent_bbd' to 'yml_to_recurring_bbd'.\n";
    $task = 'yml_to_recurring_bbd';
} elsif ($task eq 'yml_to_nonpermanent_bbd') {
    warn "WARNING: Please rename 'yml_to_nonpermanent_bbd' to 'yml_to_nonrecurring_bbd'.\n";
    $task = 'yml_to_nonrecurring_bbd';
}

if ($task eq 'pl_to_yml') {
    my $in_file = shift
	or usage("in file is missing");
    my $out_file = shift
	or usage("out file is missing");
    @ARGV and usage("extra args");

    _add_bbbike_inc();
    require BBBikeYAML;

    no warnings 'once';
    #local $YAML::UseBlock = 1;
    use vars qw(@temp_blocking);
    local @temp_blocking;
    do $in_file;
    die "Can't find \@temp_blocking array in $in_file" if not @temp_blocking;
    BBBikeYAML::DumpFile($out_file, \@temp_blocking);

} elsif ($task eq 'cmp_pl_and_yml') {
    my $file_pl = shift
	or usage("pl file is missing");
    my $file_yml = shift
	or usage("yml file is missing");
    @ARGV and usage("extra args");

    require Data::Compare;
    require Data::Dumper;
    require File::Temp;

    _add_bbbike_inc();
    require BBBikeYAML;

    use vars qw(@temp_blocking);
    local @temp_blocking;
    do $file_pl;
    die "Can't find \@temp_blocking array in $file_pl" if not @temp_blocking;
    my $y = BBBikeYAML::LoadFile($file_yml);

    no warnings 'once';
    local $Data::Dumper::Sortkeys = 1;
    if (not Data::Compare::Compare(\@temp_blocking, $y)) {
	my($tmp1fh,$tmp1file) = File::Temp::tempfile(SUFFIX => "_temp_blockings.pl") or die;
	my($tmp2fh,$tmp2file) = File::Temp::tempfile(SUFFIX => "_temp_blockings.yml") or die;
	print $tmp1fh Data::Dumper->new([\@temp_blocking],[])->Dump;
	print $tmp2fh Data::Dumper->new([$$y],[])->Dump;
	close $tmp1fh or die;
	close $tmp2fh or die;
	system("diff", "-u", $tmp1file, $tmp2file);
	exit 1;
    }

} elsif ($task eq 'yml_to_bbd') {
    my $infile = shift
	or usage "yml file is missing";
    @ARGV and usage "Extra args";

    yml_to_bbd($infile);

} elsif ($task eq 'yml_to_recurring_bbd') {
    my $infile = shift
	or usage "yml file is missing";
    @ARGV and usage "Extra args";

    yml_to_bbd($infile, filter => 'recurring');

} elsif ($task eq 'yml_to_nonrecurring_bbd') {
    my $infile = shift
	or usage "yml file is missing";
    @ARGV and usage "Extra args";

    yml_to_bbd($infile, filter => 'nonrecurring');

} elsif ($task eq 'bbd_to_existsid') {
    my @infiles = @ARGV
	or usage "bbd file is missing (one or more)";

    bbd_to_existsid(@infiles);

} else {
    usage("Task $task is unknown");
}

sub yml_to_bbd {
    my($infile, %args) = @_;
    my $filter_recurring    = $args{'filter'} && $args{'filter'} eq 'recurring';
    my $filter_nonrecurring = $args{'filter'} && $args{'filter'} eq 'nonrecurring';

    _add_bbbike_inc();
    require BBBikeYAML;

    my $x = BBBikeYAML::LoadFile($infile);
    for my $rec (@$x) {
	my $d = $rec->{data};
	next if not $d;
	next if $filter_recurring    && !($rec->{permanent} || $rec->{recurring});
	next if $filter_nonrecurring &&  ($rec->{permanent} || $rec->{recurring});
	if ($rec->{source_id}) {
	    my @source_ids = ref $rec->{source_id} eq 'ARRAY' ? @{ $rec->{source_id} } : $rec->{source_id};
	    for my $source_id (@source_ids) {
		print "#: by: $source_id\n";
	    }
	    my @real_source_ids = _filter_real_source_ids(@source_ids);
	    for my $source_id (@real_source_ids) {
		print "#: source_id: $source_id\n";
	    }
	}
	my $t = $rec->{text};
	$t =~ s/[\n\t]/ /g;
	$d =~ s/^(?!\#)/$t /gm;
	print $d;
    }
}

sub bbd_to_existsid {
    my(@infiles) = @_;

    _add_bbbike_inc();
    require Strassen::Core;
    require BBBikeYAML;

    my %existsid;
    for my $infile (@infiles) {
	Strassen->new_stream($infile)->read_stream
	    (sub {
		 my(undef, $dir) = @_;
		 for my $source_id (@{ $dir->{source_id} || [] }) {
		     $existsid{$source_id} = 1;
		 }
	     });
    }
    print BBBikeYAML::Dump(\%existsid);
}

sub _filter_real_source_ids {
    my(@source_ids) = @_;
    my @ret_source_ids;
    for my $source_id (@source_ids) {
	next if $source_id =~ m{^https?://};
	(my $ret_source_id = $source_id) =~ s{\s+.*}{};
	push @ret_source_ids, $ret_source_id;
    }
    @ret_source_ids;
}

sub _add_bbbike_inc {
    require lib;
    require FindBin;
    lib->import("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
}

__END__
