#!/usr/local/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2008,2009,2010,2011 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib "$FindBin::RealBin/..";

use vars qw($VERSION);
$VERSION = 0.12;

use Cwd qw(cwd realpath);
use Data::Dumper;
use File::Basename qw(basename);
use File::Spec qw();
use Getopt::Long;
use IO::File;
use List::Util qw(max);

sub epoch2isodatez (;$);
sub touch ($);

use constant DO_ASSERTS => 1;
use constant SORTED_TAGS => 1;
if (SORTED_TAGS) {
    require Tie::IxHash;
}

# Same as in Strassen::Core, which is coincidence.
use constant STRASSEN_NAME   => 0;
use constant STRASSEN_COORDS => 1;
use constant STRASSEN_CAT    => 2;

my $o;
my $f;
my $v;
my $encoding = "utf-8";
my $debug = 1; # 0: quiet, 1: normal, 2: verbose
my $ignore_unhandled;
my $ignore_underline;

my $nodate;
my $map;
my $center;
my $center_delta;

my $parsefor;
my $country = '';
my $lang = '';
use constant MAXLINELENGTH => 12288; # the limit of BBBikeXS
my $splitlonglines = 1; # XXX this may change once BBBikeXS has no length restriction anymore
my $xmlparser;
my %height_db;
my $height_db_file;
my $no_create;
my $git_id = "";

my %experiments;
my %known_experiments = map {($_,1)} qw(add_postal_code coastline_hack polar_coord_hack handle_relations);

sub usage () {
    <<EOF;
usage: $0 [-v] [-f] [-encoding enc] [-center lon,lat] [-map bbbike [-centerdelta lon,lat]] [-country country] -o directory osmfile ...

-v                Show parser progress
-f                Force overwriting existing output directory
-enc ...          Specify different encoding, standard is utf-8
-map bbbike       Use BBBike coordinates instead of WGS 84 coordinates in the
                  output. Recommended until BBBike is able to fully handle
                  WGS 84 coordinates.
-center lon,lat   Set the center of the map. If not set, then the plotting
		  software decides on a center itself, usually the center
		  of the bounding box.
-centerdelta lon,lat If -map bbbike is used, then specify the 0,0 point.
		     Defaults to standard Berlin setting.
-o directory      A non-existing directory to output the bbd files.
-parsefor ...     Parse only for the given key=value pair,
                  key as string and val as regexp
-country ...      Optimize output for given country (see documentation for
                  supported countries)
-lang ...         Optimize output for given language (see documentation for
                  supported languages)
-ignore-unhandled do not create the _unhandled layer
-ignore-underline do not create any of the "_*" layers
-experiment ...   Turn on experimental features (may be given multiple times).
-height-db=file   read height values from database. Same format as ./hoehe
osmfile ...       Files downloaded by downloadosm,
                  or directory containing .osm files
-no-create	  do not store create date and cwd
--git-id=gitid	  store gid id in bbd output files
EOF
}

my $prog = realpath $0;
my @commandline = ($^X, $0, @ARGV);
my $cwd = cwd;

GetOptions("o=s" => \$o,
	   "f" => \$f,
	   "v" => \$v,
	   "no-create" => \$no_create,
	   "git-id=s" => \$git_id,
	   "debug=i" => \$debug,
	   "map=s" => \$map,
	   "height-db=s" => \$height_db_file,
	   "center=s" => \$center,
	   "centerdelta=s" => \$center_delta,
	   "encoding=s" => \$encoding,
	   "parsefor=s" => \$parsefor,
	   "country=s" => \$country,
	   "lang=s" => \$lang,
	   "nodate" => \$nodate,
	   "splitlonglines!" => \$splitlonglines,
	   "xmlparser=s" => \$xmlparser,
	   "ignore-unhandled!" => \$ignore_unhandled,
	   "ignore-underline!" => \$ignore_underline,
	   'experiment=s@' => sub {
	       my $exp = $_[1];
	       if (!$known_experiments{$exp}) {
		   die <<EOF;
Unknown experiment '$exp'. Known experiments are:
@{[ sort keys %known_experiments ]}
EOF
	       }
	       $experiments{$exp}++;
	   },
	  )
    or die usage;

&init_height_db($height_db_file) if $height_db_file;

my @osm_files = @ARGV;
if (!@osm_files) {
    die <<EOF . "\n" . usage;
Please specify one or more osm files. To download an osm file, you can use
the script downloadosm (usually to be found in the same directory as this
script) or raw wget, for example

  wget -O filename.osm http://www.openstreetmap.org/api/0.5/map?bbox=x0,y0,x1,y1

Note that the bbox must not be too large, otherwise you get a 400 bad request
error.
EOF
}

if ($center && $center !~ m{^[-+]?[\d\.]+,[-+]?[\d\.]+$}) {
    die "The value for the -center option has to be in the form lon,lat\n";
}

my($parsefor_key, $parsefor_val);
if ($parsefor) {
    if (!(($parsefor_key, $parsefor_val) = $parsefor =~ m{^(.*)=(.*)$})) {
	die "-parsefor value <$parsefor> must be in the form key=val";
    }
    $parsefor_val = qr{$parsefor_val};
}

if (!$parsefor) {
    if (!$o) {
	die "Please specify (non-existent) output directory with -o option.\n" . usage;
    }
    if (!$f && -e $o) {
	die "Output directory <$o> must not exist (or specify -f to force overwrite).\n";
    }
}

# fallback
sub M ($) { $_[0] }
sub Mfmt  { sprintf(shift, @_) }

if ($lang) {
    $lang = '' if $lang eq 'de';
}
if ($lang) {
    die "Language '$lang' is not supported, please specify either 'de' or 'en'" unless $lang eq 'en';
}

my %unhandled;
my %out;
my %resolve_node_later;
my %resolved;
my @bbox_wgs84;
my %global_directives;
my %place_to_population;
my $handle_relations = $experiments{'handle_relations'};

%global_directives =
    (
     "_building"     => ["layer_stack: above:i"],
     "_motortraffic" => ["category_image.Parking: ../misc/verkehrszeichen/Zeichen_314.svg:24x24=1:3000,xxx"],
     "borders" => ["line_color: #000000", # per bbd.pod
		   "str_color: #000000", # in reality
		   # Z4: Landesgrenzen
		   # Z5: gibt's in NRW
		   (map { "line_dash.Z$_: 8,5,2,5" } (1 .. 10)),
		  ],
     'zebrastreifen' => ['category_image.Zs: ../misc/verkehrszeichen/Zeichen_350.svg:24x24=1:12000,xxx'],
     'grenzuebergaenge' => ['category_image.GU: grenzuebergang_16'],
     'ortsschilder' => ['category_image.OS: ../misc/verkehrszeichen/Zeichen_310_leer.svg:24x24=1:12000,xxx',
			'title: Ortsschilder'],
    );

# see http://www.mail-archive.com/talk@openstreetmap.org/msg06041.html
# XXX does not match very well with the tracks around Baska Voda --- maybe grade1 should match Q1 at most?
my %grade_to_Q = (1 => "Q0",
		  2 => "Q1",
		  3 => "Q2",
		  4 => "Q3",
		  5 => "Q3-",
		 );
# XXX to be reviewed
my %smoothness_to_Q = ('excellent'     => 'Q0',
		       'good'          => 'Q1',
		       'intermediate'  => 'Q2',
		       'bad'           => 'Q3',
		       'very_bad'      => 'Q3-',
		       'horrible'      => 'Q3--',
		       'very_horrible' => 'Q3---',
		       'impassable'    => undef, # will be turned into a 'gesperrt, 2'
		      );		       

my %smoothness_to_de = ('excellent'     => 'ausgezeichnet',
			'good'          => 'gut',
			'intermediate'  => 'mäßig',
			'bad'           => 'schlecht',
			'very_bad'      => 'sehr schlecht',
			'horrible'      => 'grauenhaft',
			'very_horrible' => 'sehr grauenhaft',
			'impassable'    => 'unpassierbar',
		       );		       

use constant HIGHWAY_BAB_RX => qr{^(?:motorway|motorway_link|trunk|trunk_link)$};
use constant HIGHWAY_HH_RX  => qr{^(?:primary|primary_link)$};
use constant HIGHWAY_H_RX   => qr{^(?:secondary)$};
use constant HIGHWAY_NH_RX  => qr{^(?:tertiary)$};
use constant HIGHWAY_N_RX   => qr{^(?:residential|unclassified|service|minor)$};

use constant CONSTRUCTION_RX => qr{^(?:construction|planned|proposed)$};

my $cyclists_dismount_label = ($lang eq 'en' ? 'Cyclists dismount' : 'Radfahrer absteigen');

sub init_height_db {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";

    my $use_rounding = 2;

    while(<$fd>) {
	chomp;
	my ($height, $x, $coord) = split;

	if ($use_rounding == 1) {
	    $height = int($height + 0.5);
	} elsif ($use_rounding == 2) {
	    $height = int(10*$height + 0.5)/10;
	}
     
	$height_db{ $coord } = $height;
    }
    close $fd;
}

sub add_underline {
    return if $ignore_underline;
    my($or_ref, $name, $cat) = @_;
    push @$or_ref, [$name, $cat];
}

my $do_amenity = sub {
    my($is_area, $amenity, $tagref) = @_;
    my @or;
    my $F = $is_area ? "F:" : "";
    if ($amenity eq 'place_of_worship') {
	my $religion = $tagref->{'religion'};
	if (!$religion || $religion eq 'christian') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:church"];
	} elsif ($religion eq 'jewish') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:synagogue"];
	} elsif ($religion eq 'muslim') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:mosque"];
	} else {
	    $unhandled{"amenity-religion-$religion"}++;
	}
    } elsif ($amenity eq 'museum') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:museum"];
    } elsif ($amenity eq 'hospital') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:hospital"];
    } elsif ($amenity =~ m{^theat(?:er|re)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:theater"];
    } elsif ($amenity =~ m{^(?:shopping|shopping_centre)$}) {
	push @or, ["sehenswuerdigkeit", $F."Shop"];
    } elsif ($amenity =~ m{^(?:arts_center|courthouse|library|police|post_office|public_building|townhall|university|embassy|prison)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW"];
    } elsif ($amenity =~ m{^(?:biergarten|cafe|cafeteria|pub|bar)$}) {
	push @or, ["kneipen", $F."X"];
    } elsif ($amenity =~ m{^(?:fast_food|restaurant)$}) {
	push @or, ["restaurants", $F."X"];
    } elsif ($amenity eq 'cinema') {
	push @or, ["kinos", $F."X"];
    } elsif ($amenity =~ m{^(?:kindergarten|school)$}) {
	add_underline(\@or, "_education", $F."X");
    } elsif ($amenity =~ m{^(?:parking|car_rental)$}) {
	add_underline(\@or, "_motortraffic", $F."#f0f0f0|IMG:Parking");
    } elsif ($amenity eq 'border_control') {
	push @or, ['grenzuebergaenge', 'GU'];
    } elsif ($amenity eq 'grave_yard') {
	if ($is_area) {
	    push @or, ['sehenswuerdigkeit', 'F:Cemetery'];
	} else {
	    push @or, ['sehenswuerdigkeit', 'SW'];
	}
    } else {
	$unhandled{"amenity-$amenity"}++;
    }
    @or;
};

my $do_historic = sub {
    my($is_area, $historic) = @_;
    my @or;
    my $F = $is_area ? "F:" : "";
    if ($historic eq 'monument') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:monument"];
    } elsif ($historic =~ m{^(?:castle|memorial|archaeological_site|ruins)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW"];
    } else {
	$unhandled{"historic-$historic"}++;
    }
    @or;
};

my $do_tourism = sub {
    my($is_area, $tourism) = @_;
    my @or;
    my $F = $is_area ? "F:" : "";
    if ($tourism eq 'attraction') {
	push @or, ["sehenswuerdigkeit", $F."SW"];
    } elsif ($tourism eq 'museum') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:museum"];
    } else {
	$unhandled{"tourism-$tourism"}++;
    }
    @or;
};

my $do_fixme = sub {
    my($tagref) = @_;
    my @or;
    if (exists $tagref->{fixme}) {
	push @or, ['fragezeichen', '?', name => $tagref->{fixme}];
    } elsif (exists $tagref->{note} && $tagref->{note} =~ m{^fixme\s*(.*)}i) {
	push @or, ['fragezeichen', '?', name => $1];
    }
    @or;
};

my $do_unhandled = sub {
    my($name_ref, $tagref) = @_;

    for my $key (keys %$tagref) {
	next if $key =~ m{^(?:
			    name
			  | created_by
			  | source
			  | url
			 )$}x;
	my $val = $tagref->{$key};
	if ($$name_ref) { $$name_ref .= "; " }
	$$name_ref .= "$key:$val";
    }
};

{
    # expand directories
    # XXX Should be really a recursive function, probably
    my @new_osm_files;
    for my $osm_file (@osm_files) {
	if (-d $osm_file) {
	    push @new_osm_files, grep { -f $_ && -s $_ } glob(File::Spec->catfile($osm_file,"*.{osm,osm.gz,osm.bz2}")); # XXX argh, grep duplicates functionality, see "recursive" suggestion above
	} elsif (-z $osm_file) {
	    # May happen while loading data, so ignore this
	    warn "Ignore empty file <$osm_file>...\n";
	} else {
	    push @new_osm_files, $osm_file;
	}
    }
    @osm_files = @new_osm_files;
}

# Conversion function
my $conv = sub {
    my($lon,$lat) = @_;
    "$lon,$lat";
};
if (!$experiments{'polar_coord_hack'}) {
    die "Should never happen: -o is missing?" if !$o;
    if (-e "$o/Karte/Polar.pm") {
	unlink "$o/Karte/Polar.pm"
	    or die "Cannot remove $o/Karte/Polar.pm: $!";
    }
}
if ($experiments{'polar_coord_hack'}) {
    require Math::Trig;
    my $lat;
    if ($center) {
	(undef, $lat) = split /,/, $center;
    } else {
	my($min_lat, $max_lat);
	# XXX taken from BBBikeOsmUtil.pm
	my $osm_download_file_qr = qr{/download_(-?\d+\.\d+),(-?\d+\.\d+),(-?\d+\.\d+),(-?\d+\.\d+)\.osm(?:\.gz|\.bz2)?$};
	# XXX it would be better to read the bboxes of all XML files
	for my $osm_file (@osm_files) {
	    if ($osm_file =~ $osm_download_file_qr) {
		if (!defined $min_lat || $2 < $min_lat) {
		    $min_lat = $2;
		}
		if (!defined $max_lat || $4 > $max_lat) {
		    $max_lat = $4;
		}
	    }
	}
	if (defined $min_lat && defined $max_lat) {
	    $lat = ($max_lat - $min_lat)/2 + $min_lat;
	}
    }
    if (!defined $lat) {
	die <<EOF;
Cannot apply polar_coord_hack experiment, because the center could not
apply polar_coorbe determined. Most commonly this happens because the
osm file does not have a <bound> tag (e.g. because it was created
using osmosis). To fix this, set manually the -center option.
EOF
	# XXX should read the bboxes of all files
    }
    my $newx1 = cos(Math::Trig::deg2rad($lat))*111_000; # XXX 111km is rough for one degree

    mkdir $o if !-d $o; # does not exist yet, see below the OUTPUT section
    mkdir "$o/Karte" if !-d "$o/Karte";
    open my $ifh, "<", "$FindBin::RealBin/../Karte/Polar.pm"
	or die "Cannot open $FindBin::RealBin/../Karte/Polar.pm: $!";
    open my $ofh, ">", "$o/Karte/Polar.pm~"
	or die "Cannot write to $o/Karte/Polar.pm~: $!";
    print $ofh q{warn "Using corrected Karte::Polar for latitude } . $lat . q{...\n";} . "\n";
    while(<$ifh>) {
	s{^(\s*X1\s*=>\s*)[0-9.-]+}{$1$newx1};
	print $ofh $_;
    }
    close $ofh
	or die "Error while writing to Polar.pm~: $!";
    rename "$o/Karte/Polar.pm~", "$o/Karte/Polar.pm"
	or die "Error while renaming Polar.pm~: $!";

    lib->import($o); # so the hacked Karte::Polar is in front of @INC
}

if ($map) {
    if ($map ne 'bbbike') {
	die "Only -map bbbike is supported.\n";
    }
    require Karte::Polar;
    require Karte::Standard;

    my($dx,$dy) = (0,0);
    if ($center_delta) {
	my($c_lon,$c_lat) = split /,/, $center_delta;
	($dx,$dy) = $Karte::Standard::obj->trim_accuracy($Karte::Polar::obj->map2standard($c_lon,$c_lat));
    }

    $conv = sub {
	my($lon,$lat) = @_;
	my($x,$y) = $Karte::Standard::obj->trim_accuracy($Karte::Polar::obj->map2standard($lon,$lat));
	($x-$dx).",".($y-$dy);
    };
}

if ($center) {
    $center = $conv->(split /,/, $center);
}

my $tp;
eval {
    die "No terminal" if !is_interactive();
    require Time::Progress;
    $tp = Time::Progress->new;
    $tp->attr(min => 0, max => 2 * $#osm_files + 1);
    $tp->restart;
    if ($handle_relations) {
	print STDERR "Three passes are following: nodes, ways, and relations\n";
    } else {
	print STDERR "Two passes are following: nodes and ways\n";
    }
};

sub padding {
    my $lat = shift;

    my ($int, $dec) = split(/\./, $lat);
    
    while(length($dec) < 7) {
	$dec .= '0';
	$lat .= '0';
    }
    return $lat;
}

# use Data::Dumper; print Dumper( \%height_db );
######################################################################
# NODES
my %node2ll;
my $osm_file_i = 0;
for my $osm_file (@osm_files) {
    if ($v) {
	if ($tp) {
	    print STDERR $tp->report("\r  nodes done %p elapsed: %L, ETA %E (" . substr(basename($osm_file),0,28) . ")", $osm_file_i++);
	} else {
	    warn "Parse $osm_file for nodes...\n";
	}
    }
    my($dom, $reader) = open_osm($osm_file);
    set_info_handler($osm_file, $dom, $reader);

 PARSE: {

	if ($reader) {
	    $reader->nextElement;
	    die "The file '$osm_file' is not starting with a <osm> tag, probably not an osm file?"
		if $reader->name ne 'osm';
	    $reader->nextElement == 1 or last PARSE;
	    # $reader stays now on <bounds> or <bound> or the first <node>
	    if (DO_ASSERTS) {
		$reader->name =~ m{^(?:bounds|bound|node)}
		    or parse_warning($reader, "after parsing <osm>");
	    }
	}

	if ($reader && $reader->name eq 'bound') { # is this the new api? <bound> vs. <bounds>?
	    # XXX missing implementation for XML::LibXML-non-reader and <bound> tag
	    my($minlat,$minlon,$maxlat,$maxlon) = split /,/, $reader->getAttribute('box');
	    if (!defined $bbox_wgs84[0] || $minlon < $bbox_wgs84[0]) { $bbox_wgs84[0] = $minlon }
	    if (!defined $bbox_wgs84[1] || $minlat < $bbox_wgs84[1]) { $bbox_wgs84[1] = $minlat }
	    if (!defined $bbox_wgs84[2] || $maxlon > $bbox_wgs84[2]) { $bbox_wgs84[2] = $maxlon }
	    if (!defined $bbox_wgs84[3] || $maxlat > $bbox_wgs84[3]) { $bbox_wgs84[3] = $maxlat }

	    $reader->nextElement == 1 or last PARSE;
	} else {
	    # XXX It seems that the osm specification allows multiple
	    # bounds elements, but the real-existing osm files only
	    # have one, so check only for one:
	    my $bounds_node;
	    if ($reader) {
		if ($reader->name eq 'bounds') {
		    $bounds_node = $reader;
		}
	    } else {
		($bounds_node) = $dom->findnodes("/osm/bounds");
	    }

	    if ($bounds_node) {
		my $minlat = $bounds_node->getAttribute("minlat");
		my $maxlat = $bounds_node->getAttribute("maxlat");
		my $minlon = $bounds_node->getAttribute("minlon");
		my $maxlon = $bounds_node->getAttribute("maxlon");
		if (!defined $bbox_wgs84[0] || $minlon < $bbox_wgs84[0]) { $bbox_wgs84[0] = $minlon }
		if (!defined $bbox_wgs84[1] || $minlat < $bbox_wgs84[1]) { $bbox_wgs84[1] = $minlat }
		if (!defined $bbox_wgs84[2] || $maxlon > $bbox_wgs84[2]) { $bbox_wgs84[2] = $maxlon }
		if (!defined $bbox_wgs84[3] || $maxlat > $bbox_wgs84[3]) { $bbox_wgs84[3] = $maxlat }

		if ($reader) {
		    $reader->nextElement == 1 or last PARSE;
		}
	    }
	}

	if ($reader) {
	    # $reader stays now on the first <node> (or on
	    # another <bounds>, if there is really one)
	    if (DO_ASSERTS) {
		$reader->name eq 'node' or
		    parse_warning($reader, "after parsing <bounds> or <bound>");
	    }
	}

	my @nodes;
	if ($dom) {
	    @nodes = $dom->findnodes('/osm/node');
	}

	# Use $next1 until <tag>s are resolved
	my $next1 = sub {
	    if ($reader) {
		$reader->skipSiblings if $reader->depth == 2;
		my $res = $reader->nextSiblingElement;
		if (DO_ASSERTS) {
		    ($reader->name =~ m{^(?:node|way)} || $res == 0) or
			parse_warning($reader, "after skipping a node");
		}
	    }
	    no warnings 'exiting';
	    next;
	};

	# Use $next2 after <tag>s are resolved
	my $next2 = sub {
	    no warnings 'exiting';
	    next;
	};

	while(do {
	    no warnings 'uninitialized';
	    (($reader && $reader->name eq 'node') ||
	     ($dom && @nodes))
	}) {
	    my $node = $reader ? $reader : shift @nodes;

	    my $id = $node->getAttribute('id');
	    $next1->() if exists $node2ll{$id};
	    my $lat = $node->getAttribute('lat');
	    my $lon = $node->getAttribute('lon');
	    my $ll = $node2ll{$id} = $conv->($lon,$lat);

	    my %tag;
	    tie %tag, 'Tie::IxHash' if SORTED_TAGS;
	    if ($reader) {
		$reader->nextElement == 1 or last;
		while($reader->name eq 'tag') {
		    $tag{$reader->getAttribute('k')} = $reader->getAttribute('v');
		    if ($reader->nextElement != 1) {
			# no assertion needed here, we're at the end of the file
			last;
		    }
		}
	    } else {
		for my $tag ($node->findnodes('./tag')) {
		    $tag{$tag->getAttribute('k')} = $tag->getAttribute('v');
		}
	    }

	    my @or;

	    my $name   = $tag{'name'} || '';
	    my $height = exists $tag{'height'} ? $tag{'height'} : $tag{'ele'};

	    if (!defined $height) {
	        my $lon2 = &padding($lon);
	        my $lat2 = &padding($lat);

	        if (exists $height_db{"$lon2,$lat2"} ) {
		   $height = $height_db{"$lon2,$lat2"};
	        }
            } else {
		# ignore metric description: "2 m" => "2"
	        $height =~ s/\s*m$//;

		# still some non-integers, extract number
		if ($height !~ /^[\d\.]+$/) {
		    $height = ($height =~ /([\d\.]+)/ ? $1 : 0);
	        }
		$height = int($height + 0.5);
	    }
	    warn "height: $height, $name\n" if defined $height && $height ne '' && $debug >= 2;

	    if (defined $parsefor_key) {
		my $found_val = $tag{$parsefor_key};
		if (defined $found_val && $found_val =~ $parsefor_val) {
		    push @or, ["-", $found_val];
		}
	    } elsif (exists $tag{'railway'}) {
		my $railway_cat = $tag{'railway'};
		if ($railway_cat =~ m{^(?:station|halt)$}) {
		    if ($name) {
			# fix name, remove "Bahnhof" if at beginning (XXX do it language independent?):
			$name =~ s{^(?:Bahnhof|Bhf\.?)\s+(.+)}{$1};
		    }

		    if (exists $tag{'station'} && $tag{'station'} eq 'light_rail') {
			push @or, ['sbahnhof', 'SA', name => normalize_name_sbahnhof($name)];
		    } elsif (exists $tag{'station'} && $tag{'station'} eq 'subway') {
			push @or, ['ubahnhof', 'UA', name => normalize_name_ubahnhof($name)];
		    } else {
			# We don't know which layer this station belongs to,
			# so resolve it later.
			# XXX Maybe this should cause a warning? But currently "normal" railway stations
			# do not have a "station" tag, just light_rail and subway
			resolve_node_later("railway", $name, $ll);
			$next2->();
		    }
		} elsif ($railway_cat =~ m{^(?:crossing|level_crossing)$}) {
		    push @or, ["ampeln", "B"];
		} elsif ($railway_cat eq 'tram_stop') { # takes precedence over highway=bus_stop
		    add_underline(\@or, '_oepnv', 'Tramstop');
		} else {
		    $unhandled{"node-railway=$railway_cat"}++;
		}
	    } elsif (exists $tag{'highway'}) {
		my $highway_cat = $tag{'highway'};
		if ($highway_cat eq 'traffic_signals') {
		    push @or, ["ampeln", "X"];
		} elsif ($highway_cat eq 'bus_stop') {
		    add_underline(\@or, "_oepnv", "Busstop");
		} elsif ($highway_cat eq 'crossing' &&
			 ((exists $tag{crossing} && ($tag{crossing} eq 'uncontrolled' || $tag{crossing} eq 'zebra')) ||
			  (exists $tag{crossing_ref} && $tag{crossing_ref} eq 'zebra'))
			) {
		    push @or, ['zebrastreifen', 'Zs'];
		} elsif ($highway_cat eq 'crossing' &&
			 exists $tag{'crossing'} && $tag{'crossing'} eq 'traffic_signals') {
		    push @or, ['ampeln', 'F'];
		} else {
		    $unhandled{"node-highway=$highway_cat"}++;
		}
	    } elsif (exists $tag{'barrier'} && $tag{'barrier'} eq 'cycle_barrier') {
		$name = $lang eq 'en' ? 'Cycle barrier' : 'Drängelgitter' if !$name;
		push @or, ['gesperrt', 'BNP:5', name => $name];
	    } elsif (exists $tag{'barrier'} && $tag{'barrier'} eq 'gate') {
		$name = $lang eq 'en' ? 'Gate' : 'Tor' if !$name;
		push @or, ['gesperrt', 'BNP:10', name => $name];
	    } elsif (exists $tag{'place'}) {
		my $place = $tag{'place'};
		my $population = exists $tag{'population'} ? $tag{'population'} : $tag{'openGeoDB:population'};
		if ($population && $place !~ m{^(suburb|state)$}) { # "Mahlsdorf" is a suburb, but with a population tag; "Sachsen" has place=state
		    my $cat;
		    if ($population >= 200000) {
			$cat = 6;
		    } elsif ($population >= 50000) {
			$cat = 5;
		    } elsif ($population >= 20000) {
			$cat = 4;
		    } elsif ($population >= 5000) {
			$cat = 3;
		    } elsif ($population >= 2000) {
			$cat = 2;
		    } elsif ($place eq 'hamlet') {
			$cat = 0;
		    } else {
			$cat = 1;
		    }
		    push @or, ["orte", $cat];
		    $place_to_population{$ll} = $population;
		} else {
		    if ($place eq 'hamlet' || $place eq 'suburb' || $place eq 'locality') {
			push @or, ["orte", 0];
		    } elsif ($place eq 'village') {
			push @or, ["orte", 1];
		    } elsif ($place eq 'town') {
			push @or, ["orte", 3];
		    } elsif ($place eq 'city') {
			push @or, ["orte", 5];
		    } elsif ($place eq 'island') {
			# XXX an interim solution --- a better solution
			# would check for the coastline of this island and
			# create a proper F:I item
			push @or, ["wasserstrassen", "I"],
		    } else {
			$unhandled{"node-place=$place"}++;
		    }
		}
	    } elsif (exists $tag{'amenity'}) {
		push @or, $do_amenity->(0, $tag{'amenity'}, \%tag);
	    } elsif (exists $tag{'historic'}) {
		push @or, $do_historic->(0, $tag{'historic'}, \%tag);
	    } elsif (exists $tag{'tourism'}) {
		push @or, $do_tourism->(0, $tag{'tourism'}, \%tag);
	    } elsif (exists $tag{'aeroway'} && $tag{'aeroway'} eq 'aerodrome') {
		push @or, ['sehenswuerdigkeit', 'SW|IMG:airport'];
	    } elsif (exists $tag{'power'}) {
		add_underline(\@or, "_power", "X");
	    }

	    if (defined $height && $height =~ m{^[+-]?\d+}) {
		push @or, ["hoehe", "X", name => $height];
	    }

	    if (exists $tag{'icao'}) {
		push @or, ["icao", "X", name => $tag{icao} . (defined $name ? " ($name)" : '')];
	    }

	    if (exists $tag{'traffic_sign'} && $tag{'traffic_sign'} eq 'city_limit') {
		push @or, ['ortsschilder', 'OS'];
	    }

	    if (!@or && !$ignore_unhandled && !$ignore_underline) {
		$do_unhandled->(\$name, \%tag);
		if ($name ne "" && !exists $tag{'obsolete_boundary'}) {
		    push @or, ["_unhandled", "X"];
		}
	    }

	    push @or, $do_fixme->(\%tag);

	    for my $or (@or) {
		my($out_file, $cat, %args) = @$or;

		my $name = $name;
		if ($args{name}) {
		    $name = $args{name};
		}

		if (exists $tag{'url'}) {
		    push @{$out{$out_file}}, ["#: url: $tag{url}"];
		}
		push @{$out{$out_file}}, [$name, [$ll], $cat];
	    }
	}
    }
}

######################################################################
# WAYS
my %seenway;
my %way2nodes;
for my $osm_file (@osm_files) {
    if ($v) {
	if ($tp) {
	    print STDERR $tp->report("\r  ways done %p elapsed: %L, ETA %E (" . substr(basename($osm_file),0,28) . ")", $osm_file_i++);
	} else {
	    warn "Parse $osm_file for ways...\n";
	}
    }
    my($dom, $reader) = open_osm($osm_file);
    set_info_handler($osm_file, $dom, $reader);

 PARSE: {
	my @ways;
	if ($dom) {
	    @ways = $dom->findnodes('/osm/way');
	} else {
	    $reader->nextElement('way') == 1 or last PARSE;
	    if (DO_ASSERTS) {
		$reader->name eq 'way'
		    or parse_warning($reader, "searching for <way>");
	    }
	}

	my $next1 = sub {
	    if ($reader) {
		$reader->skipSiblings if $reader->depth == 2;
		my $res = $reader->nextSiblingElement;
		if (DO_ASSERTS) {
		    ($res == 0 || $reader->name =~ m{^(?:way|relation)}) or
			parse_warning($reader, "after skipping a way");
		}
	    }
	    no warnings 'exiting';
	    next;
	};

	while (do {
	    no warnings 'uninitialized';
	    (($reader && $reader->name eq 'way') ||
	     ($dom && @ways))
	}) {
	    my $way = $reader ? $reader : shift @ways;

	    my $id = $way->getAttribute('id');
	    $next1->() if exists $seenway{$id};
	    $seenway{$id} = 1;
	    my $visible = $way->getAttribute('visible');
	    $next1->() if $visible && $visible eq 'false';

	    my @or;

	    my @nodes;
	    my %tag;
	    tie %tag, 'Tie::IxHash' if SORTED_TAGS;
	    if ($dom) {
		@nodes = map { $_->textContent } $way->findnodes('./nd/@ref');
		for my $tag ($way->findnodes('./tag')) {
		    $tag{$tag->getAttribute('k')} = $tag->getAttribute('v');
		}
	    } else {
		$reader->nextElement == 1 or last;
		while(1) {
		    my $node_name = $reader->name;
		    if ($node_name eq 'nd') {
			push @nodes, $reader->getAttribute('ref');
		    } elsif ($node_name eq 'tag') {
			$tag{$reader->getAttribute('k')} = $reader->getAttribute('v');
		    } else {
			last;
		    }
		    $reader->nextElement == 1 or last;
		}
	    }

	    my $is_area = sub {
		$nodes[0] == $nodes[-1];
	    };

	    if ($handle_relations) {
		$way2nodes{$id} = \@nodes;
	    }

	    my $name   = $tag{'name'} || '';
	    my $height = exists $tag{'height'} ? $tag{'height'} : $tag{'ele'};

	    if (exists $tag{'ref'}) {
		my $ref = $tag{'ref'};
		if (!$name) {
		    $name = $ref;
		} elsif ($ref ne $name) {
		    $name .= " ($ref)";
		}
	    }

	    if ($debug >= 2) {
		$name .= "; id=$id";
	    }

	    my $cycleway = $tag{'cycleway'};
	    my $place    = $tag{'place'};

	    my $do_cycleway = sub {
		my @or;
		if      ($cycleway eq 'lane') {
		    push @or, ["radwege_exact", "RW4"];
		} elsif ($cycleway eq 'track') {
		    push @or, ["radwege_exact", "RW1"];
		} elsif ($cycleway eq 'opposite_track' ||
			 $cycleway eq 'opposite_lane' # sollte in Berlin nicht vorkommen
			) {
		    push @or, ["radwege_exact", "RW9"];
		} elsif ($cycleway eq 'opposite') {
		    # wird in Zusammenhang mit oneway verwendet
		} else {
		    $unhandled{"cycleway-$cycleway"}++;
		}
		@or;
	    };

	    my $do_railway = sub {
		my $railway_cat = $tag{'railway'};

		my $addcat = "";
		if (exists $tag{'tunnel'} && $tag{'tunnel'} eq 'yes') {
		    $addcat .= "::Tu";
		} elsif (exists $tag{'bridge'} && $tag{'bridge'} eq 'yes') {
		    $addcat .= "::Br";
		}

		if      ($railway_cat eq 'subway') {
		    my $addservice = is_rail_service("U", $name, \@nodes) ? 'Betrieb' : '';
		    push @or, ["ubahn", "U".$addservice.$addcat]; # no zones
		    resolve_node_now('railway', 'ubahnhof', "U", \@nodes);
		} elsif ($railway_cat eq 'light_rail') {
		    my $addservice = is_rail_service("S", $name, \@nodes) ? 'Betrieb' : '';
		    push @or, ["sbahn", "S".$addservice.$addcat]; # no zones
		    resolve_node_now('railway', 'sbahnhof', "S", \@nodes);
		} elsif ($railway_cat eq 'rail') {
		    if ($name =~ m{^S\d+(,\s+S\d+)*$}) {
			# in Munich, S-Bahn is not marked as "light_rail"
			push @or, ["sbahn", "S".$addcat];
			resolve_node_now('railway', 'sbahnhof', "S", \@nodes);
		    } else {
			push @or, ["rbahn", "R".$addcat];
			resolve_node_now('railway', 'rbahnhof', "R", \@nodes);
		    }
		} elsif ($railway_cat eq 'preserved') {
		    # ignore
		} elsif ($railway_cat eq 'service') {
		    push @or, ["rbahn", "RG".$addcat];
		    resolve_node_now('railway', 'rbahnhof', "RG", \@nodes);
		} elsif ($railway_cat =~ m{^(?:abandoned|disused)$}) {
		    push @or, ["rbahn", "R0".$addcat];
		    resolve_node_now('railway', 'rbahnhof', "R0", \@nodes);
		} elsif ($railway_cat =~ CONSTRUCTION_RX) {
		    push @or, ["rbahn", "RBau".$addcat];
		    resolve_node_now('railway', 'rbahnhof', "RBau", \@nodes);
		} elsif ($railway_cat =~ m{^(?:narrow_gauge)$}) { # z.B. Parkeisenbahnen
		    push @or, ["rbahn", "RP".$addcat];
		    resolve_node_now('railway', 'rbahnhof', "RP", \@nodes);
		} elsif ($railway_cat =~ m{\btram\b}) {
		    push @or, ["comments_tram", "CS".$addcat];
		} else {
		    return 0; # unhandled
		}
		return 1; # handled
	    };

	    if (defined $height ) {
		#warn "hoehe\n";
		#push @or, ["hoehe", "N"];
		#push @or, ["kneipen", $F."X"];
	    }

	    my $quality_cat;
	    my $quality_name;
	    if (exists $tag{'surface'} || exists $tag{'smoothness'}) {
		my $surface    = $tag{'surface'}    || '';
		my $smoothness = $tag{'smoothness'} || '';

		my @quality_name;

		if ($surface ne '') {
		    if      ($surface eq 'paved') {
			$quality_cat = 'Q0';
			@quality_name = 'befestigt (betoniert, asphaltiert oder wassergebunden)';
		    } elsif ($surface eq 'asphalt') {
			$quality_cat = 'Q0';
			@quality_name = 'Asphalt';
		    } elsif ($surface eq 'concrete') {
			$quality_cat = 'Q0';
			@quality_name = 'Beton';
		    } elsif ($surface eq 'concrete_plates') {
			$quality_cat = 'Q2+';
			@quality_name = 'Plattenweg';
		    } elsif ($surface eq 'cobblestone') {
			$quality_cat = 'Q2';
			@quality_name = 'Kopfsteinpflaster';
		    } elsif ($surface eq 'gravel') {
			$quality_cat = 'Q1-';
			@quality_name = 'Schotter'; # fein oder grob?
		    } elsif ($surface eq 'unpaved') {
			$quality_cat = 'Q2';
			@quality_name = 'unbefestigt';
		    } elsif ($surface eq 'sand') {
			$quality_cat = 'Q3';
			@quality_name = 'sandig';
		    } elsif ($surface eq 'paving_stones') {
			$quality_cat = 'Q1';
			@quality_name = 'Verbundsteinpflaster';
		    } elsif ($surface eq 'compacted') {
			$quality_cat = 'Q1';
			@quality_name = 'wassergebundene Decke';
		    } elsif ($surface eq 'grass') {
			$quality_cat = 'Q3';
			@quality_name = 'Gras';
		    } elsif ($surface eq 'wood') {
			$quality_cat = 'Q1';
			@quality_name = 'Holz';
		    }
		    if ($lang eq 'en') {
			@quality_name = $surface;
		    }
		}

		if ($smoothness ne '') {
		    if (defined $smoothness_to_Q{$smoothness}) {
			$quality_cat = $smoothness_to_Q{$smoothness}; # overrides before
			push @quality_name, $lang eq '' ? $smoothness_to_de{$smoothness}||$smoothness : $smoothness;
		    } else {
			push @or, ['gesperrt', '2', name => $smoothness];
		    }
		}

		$quality_name = join ", ", @quality_name if @quality_name;
	    }

	    my $handicap_cat;
	    my $handicap_name;

	    my $set_handicap = sub {
		# XXX missing '-' and '+' handling
		if (!defined $handicap_cat || substr($handicap_cat,1,1) < substr($_[0],1,1)) {
		    $handicap_cat = $_[0];
		    $handicap_name = $_[1];
		}
	    };

	    if (exists $tag{'highway'}) {
		my $highway_cat = $tag{'highway'};
		my $is_motorway = 0;
		my $is_motorroad = exists $tag{'motorroad'} and $tag{'motorroad'} eq 'yes' ? 1 : 0; # Kraftfahrzeugstraße
		my $bicycle_tag = $tag{'bicycle'};
		my $foot_tag = $tag{'foot'};
		if (defined $bicycle_tag && $bicycle_tag eq 'no') {
		    if (defined $foot_tag && $foot_tag eq 'no') {
			$is_motorroad = 1;
		    } else {
			$set_handicap->('q4', $cyclists_dismount_label);
		    }
		}
		if (defined $bicycle_tag && $bicycle_tag eq 'dismount') {
		    $set_handicap->('q4', $cyclists_dismount_label);
		}

		if ($experiments{add_postal_code} && exists $tag{'postal_code'}) {
		    $name .= " ($tag{'postal_code'})";
		}

		my $addcat = "";
		if (exists $tag{'tunnel'} && $tag{'tunnel'} eq 'yes') {
		    $addcat .= "::Tu";
		} elsif (exists $tag{'bridge'} && $tag{'bridge'} eq 'yes') {
		    $addcat .= "::Br";
		}

		if      ($highway_cat =~ HIGHWAY_BAB_RX || $is_motorroad) {
		    if ($country eq 'de') {
			$name =~ s{\bA\s*(\d+)}{BAB$1};
		    }
		    push @or, ["strassen_bab", "BAB".$addcat];
		    $is_motorway = 1;
		} elsif ($highway_cat =~ HIGHWAY_HH_RX) {
		    push @or, ["strassen", "HH".$addcat];
		} elsif ($highway_cat =~ HIGHWAY_H_RX) {
		    push @or, ["strassen", "H".$addcat];
		} elsif ($highway_cat =~ HIGHWAY_NH_RX) {
		    push @or, ["strassen", "NH".$addcat];
		} elsif ($highway_cat =~ HIGHWAY_N_RX) {
		    push @or, ["strassen", "N".$addcat];
		} elsif ($highway_cat eq 'road') {
		    push @or, ['strassen', "N".$addcat];
		    push @or, ['fragezeichen', '?', name => 'road category missing'];
		} elsif ($highway_cat eq 'cycleway') {
		    push @or, ["strassen", "NN".$addcat];
		CYCLEWAY_KEY: {
			if ($cycleway) {
			    my @sub_or = $do_cycleway->();
			    if (@sub_or) {
				push @or, @sub_or;
				last CYCLEWAY_KEY;
			    }
			}
			# fallback
			push @or, ["radwege_exact", "RW1"];
		    }
		} elsif ($highway_cat eq 'unsurfaced') { # XXX not mentioned in Map_Features, maybe fix data and remove?
		    push @or, ["strassen", "N".$addcat];
		    if (!defined $quality_cat) {
			$quality_cat = "Q2";
			$quality_name = $lang eq 'en' ? $highway_cat : "unbefestigte Straße";
		    }
		} elsif ($highway_cat eq 'track') {
		    push @or, ["strassen", "N".$addcat];
		    my $add_quality_name;
		    if ($tag{tracktype}) { # may override $quality_cat
			my @all_grades = grep { m{^grade\d+$} } split /\s*;\s*/, $tag{tracktype};
			my @num_grades = map { m{grade(\d+)}; $1 } @all_grades;
			if (@num_grades) {
			    my $grade = max @num_grades;
			    if (defined(my $q = $grade_to_Q{$grade})) {
				$quality_cat = $q;
			    }
			    if (defined $quality_name) {
				$quality_name .= " (" . join(", ", @all_grades) . ")";
			    } else {
				$add_quality_name = " (" . join(", ", @all_grades) . ")";
			    }
			}
		    }
		    if (!defined $quality_cat) {
			$quality_cat = "Q2";
		    }
		    if (!defined $quality_name) {
			$quality_name = $lang eq 'en' ? $highway_cat : "Fahrweg";
		    }
		    if ($add_quality_name) {
			$quality_name .= $add_quality_name;
		    }
		} elsif ($highway_cat eq 'path') {
		    push @or, ["strassen", "NN".$addcat];
		    if (!$tag{bicycle} || $tag{bicycle} eq 'no') {
			if (!defined $quality_cat) {
			    $quality_cat = "Q3";
			    $quality_name = $lang eq 'en' ? $highway_cat : "Pfad";
			}
		    } else {
			push @or, ["radwege_exact", "RW1"];
		    }
		} elsif ($highway_cat =~ m{^(footway|pedestrian)$}) {
		    my $label = ($highway_cat eq 'footway'
				 ? ($lang eq 'en' ? 'footway' : 'Fußweg')
				 : ($lang eq 'en' ? 'pedestrian area' : 'Fußgängerzone')
				);
		    push @or, ["strassen", "NN".$addcat];
		    if (defined $bicycle_tag) {
			if ($bicycle_tag =~ m{^(yes|designated|official)$}) {
			    $set_handicap->('q1', $label . ($lang eq 'en' ? ', cycling allowed' : ', Radfahren erlaubt'));
			} elsif ($bicycle_tag eq 'permissive') {
			    $set_handicap->('q2', $label . ($lang eq 'en' ? ', cycling permissive' : ', Radfahren geduldet'));
			} elsif ($bicycle_tag eq 'no') {
			    $set_handicap->('q4', $label . ($lang eq 'en' ? ', cycling not allowed' : ', Radfahren nicht erlaubt, ggfs. schieben'));
			} else {
			    warn "Found unhandled bicycle=$bicycle_tag together with $highway_cat...\n";
			}
		    } else {
			my $cat = $highway_cat eq 'footway' ? 'q3' : 'q4'; # unklare Situation für Radfahrer
			$set_handicap->($cat, $label);
		    }
		} elsif ($highway_cat eq 'living_street') {
		    push @or, ["strassen", "N".$addcat];
		    push @or, ["radwege_exact", "RW6;RW6", name => ($name ? "$name: " : "") . ($lang eq 'en' ? 'living street' : 'verkehrsberuhigter Bereich')];
		} elsif ($highway_cat =~ CONSTRUCTION_RX) {
		    my $construction = $tag{'construction'} || ""; # what will the type of street be?
		    if      ($construction =~ HIGHWAY_BAB_RX) {
			push @or, ["strassen_bab", "BAB::inwork"];
		    } elsif ($construction =~ HIGHWAY_HH_RX) {
			push @or, ['strassen', 'HH'];
			push @or, ['gesperrt', '2:inwork'];
		    } elsif ($construction =~ HIGHWAY_H_RX) {
			push @or, ['strassen', 'H'];
			push @or, ['gesperrt', '2:inwork'];
		    } elsif ($construction =~ HIGHWAY_NH_RX) {
			push @or, ['strassen', 'NH'];
			push @or, ['gesperrt', '2:inwork'];
		    } elsif ($construction =~ HIGHWAY_N_RX) {
			push @or, ['strassen', 'N'];
			push @or, ['gesperrt', '2:inwork'];
		    } else {
			push @or, ['strassen', 'N'];
			push @or, ['gesperrt', '2:inwork'];
		    }
		} elsif ($highway_cat eq 'steps') {
		    push @or, ["strassen", "NN".$addcat];
		    my $name       = $lang eq 'en' ? 'steps' : 'Treppe';
		    my $lost_time  = 30; # an average if a step_count is missing
		    my $step_count = $tag{'step_count'};
		    if (defined $step_count) {
			if ($lang eq 'en') {
			    $name = $step_count . ' step' . ($step_count == 1 ? '' : 's');
			} else {
			    $name .= " ($step_count Stufe" . ($step_count == 1 ? '' : 'n');
			}
			$lost_time = int($step_count * 0.7); # XXX need more scientific background for the coefficient
		    }
		    push @or, ["gesperrt", "0:$lost_time", name => $name]; # XXX really should be only one point, or maybe better, change bbbike to handle line features for "Treppe"; Also missing: precalculated angle. In case of a line feature I need to think something else...
		} elsif ($highway_cat eq 'cycleroad') { # It seems that this tag is not anymore in use
		    push @or, ["strassen", "N".$addcat];
		    push @or, ["radwege_exact", "RW7;RW7"];
		} else {
		    $unhandled{"highway=$highway_cat"}++;
		}

		my $oneway = $tag{'oneway'};
		if ($oneway) {
		    my $reversed = 1;
		    # Special case -1, see
		    # http://wiki.openstreetmap.org/index.php/Key:oneway
		    if ($oneway eq '-1') {
			$oneway = "true";
			$reversed = 0;
		    }
		    if ($oneway =~ m{^(?:yes|true)$}) {
			if ($is_motorway ||
			    (exists $tag{'bicycle'} && $tag{'bicycle'} eq 'opposite') || # seen in Würzburg, Äußere Pleich, but no documentation/discussion for it
			    (exists $tag{'cycleway'} && $tag{'cycleway'} =~ m{^opposite(?:$|_lane|_track)$}) # described in http://wiki.openstreetmap.org/wiki/DE:Germany_roads_tagging
			   ) {
			    push @or, ['gesperrt_car', '1', reversed => $reversed];
			} else {
			    if ($highway_cat eq 'cycleway') {
				# usually this generates to much clutter in
				# the map ("straßenbegleitende Radwege"), so
				# ignore map display
				push @or, ["gesperrt", "1::igndisp", reversed => $reversed];
			    } else {
				push @or, ["gesperrt", "1", reversed => $reversed];
			    }
			}
		    } else {
			$unhandled{"oneway=$oneway"}++;
		    }
		}

		if (defined $quality_cat) {
		    push @or,
			["qualitaet_s",
			 $quality_cat,
			 name => ($name ? $name : '') . ($name && $quality_name ? ': ' : '') . ($quality_name ? $quality_name : ''),
			];
		}

		if (defined $handicap_cat) {
		    push @or,
			["handicap_s",
			 $handicap_cat,
			 name => ($name ? $name : '') . ($name && $handicap_name ? ': ' : '') . ($handicap_name ? $handicap_name : ''),
			];
		}

		if (exists $tag{lit} && $tag{lit} eq 'no') {
		    push @or,
			['nolighting', 'NL', name => ''];
		}

		my $rcn_ref = $tag{'rcn_ref'};
		my $lcn_ref = $tag{'lcn_ref'};
		if ($rcn_ref) {
		    push @or, ["comments_route", "radroute", name => $rcn_ref];
		}
		if ($lcn_ref) {
		    push @or, ["comments_route", "radroute", name => $lcn_ref];
		}

		if (exists $tag{'railway'}) {
		    $do_railway->(); # typically tram on street
		}

	    } elsif (exists $tag{'waterway'}) {
		my $waterway_cat = $tag{'waterway'};
		if      ($waterway_cat eq 'riverbank') {
		    # Plot as an area only if it's closed
		    if ($nodes[0] eq $nodes[-1]) {
			push @or, ["wasserstrassen", "F:W"];
		    } else {
			push @or, ["wasserstrassen", "W"]; # XXX This should be fixed!
			warn_once("Found unclosed riverbank, sorry cannot use it, fallback to line plotting ...\n");
		    }
		} elsif ($waterway_cat eq 'canal') {
		    push @or, ["wasserstrassen", "W"];
		} elsif ($waterway_cat eq 'river') {
		    push @or, ["wasserstrassen", "W1"];
		} elsif ($waterway_cat eq 'stream') {
		    push @or, ["wasserstrassen", "W0"];
		} else {
		    $unhandled{"waterway=$waterway_cat"}++;
		}
	    } elsif (exists $tag{'railway'}) {
		if (!$do_railway->()) {
		    my $railway_cat = $tag{'railway'};
		    $unhandled{"railway=$railway_cat"}++;
		}
	    } elsif (exists $tag{'natural'}) {
		my $natural = $tag{'natural'};
		if      ($natural eq 'water') {
		    push @or, ["wasserstrassen", "F:W"];
		} elsif ($natural eq 'wood') {
		    push @or, ["flaechen", "F:Forest"];
		} elsif ($natural eq 'land') {
		    my $island = $tag{'island'}; # seen in Zuerich
		    my $layer  = $tag{'layer'}; # seen in Berlin
		    if (($place && $place eq 'island') ||
			($island && $island =~ m{^(?:yes|true)$}) ||
			(defined $layer && $layer ne "" && $layer == 1)
		       ) {
			push @or, ["wasserstrassen", "F:I"];
		    }
		} elsif ($natural eq 'coastline') {
		    if ($experiments{coastline_hack}) {
			push @or, ["_coastline", "W"];
			warn_once("Moving natural=coastline into _coastline file, for proceeding with the coastline hack...\n");
		    } else {
			push @or, ["wasserstrassen", "W"]; # XXX This should be fixed!
			warn_once("Found natural=coastline, sorry cannot use it, fallback to line plotting...\n");
		    }
		} else {
		    $unhandled{"natural=$natural"}++;
		}
	    } elsif (exists $tag{'boundary'}) { # Sometimes there's boundary=administrative and natural=coastline at the same time. Currently I prefer coastline over boundary (see the Usedom data). But maybe I should render both? Think of it! XXX
		my $boundary = $tag{'boundary'};
		my $admin_level = $tag{'admin_level'};
		if      ($boundary eq 'administrative') {
		    # The new-style berlin/germany-independent borders
		    push @or, ["borders", "Z" . (defined $admin_level ? $admin_level : '?')];
		    # For bbbike compat only:
		    if (defined $admin_level) {
			if (   $admin_level == 9  # (neue) Bezirke
			       || $admin_level == 10 # Ortsteile
			   ) {
			    push @or, ["berlin_ortsteile", "Z"];
			} elsif ($admin_level == 2) {
			    push @or, ["deutschland", "Z"];
			} else {
			    $unhandled{"boundary=administrative,admin_level=$admin_level"}++;
			}
		    }
		} else {
		    $unhandled{"boundary=$boundary"}++;
		}
	    } elsif ($place) {
		if      ($place eq 'airport') {
		    push @or, ["flaechen", "F:Ae"];
		} else {
		    $unhandled{"place=$place"}++;
		}
	    } elsif (exists $tag{'sport'}) {
		my $sport = $tag{'sport'};
		if      ($sport =~ m{^(?:soccer|athletics)$}) {
		    push @or, ["flaechen", "F:Sport"];
		} else {
		    $unhandled{"sport=$sport"}++;
		}
	    } elsif (exists $tag{'leisure'}) {
		my $leisure = $tag{'leisure'};
		if      ($leisure =~ m{^(?:park|garden|recreation_ground)$}) {
		    push @or, ["flaechen", "F:P"];
		} elsif ($leisure eq 'stadium') {
		    push @or, ["flaechen", "F:Sport"];
		} elsif ($leisure eq 'cemetery') { # see below: landuse=cemetery
		    push @or, ["flaechen", "F:Cemetery"];
		} else {
		    $unhandled{"leisure=$leisure"}++;
		}
	    } elsif ($cycleway) {
		push @or, $do_cycleway->();
	    } elsif (exists $tag{'landuse'}) {
		my $landuse = $tag{'landuse'};
		if      ($landuse eq 'cemetery') {
		    push @or, ["flaechen", "F:Cemetery"];
		} elsif ($landuse eq 'industrial') {
		    push @or, ["flaechen", "F:Industrial"];
		} elsif ($landuse eq 'railway') {
		    push @or, ["flaechen", "F:Industrial"]; # XXX but maybe use Railway some day?
		} elsif ($landuse eq 'commercial') {
		    push @or, ["flaechen", "F:Industrial"]; # XXX but maybe use Commercial some day?
		} elsif ($landuse eq 'retail') {
		    push @or, ["flaechen", "F:Industrial"]; # XXX but maybe use Retail some day?
		} elsif ($landuse eq 'allotments') {
		    push @or, ["flaechen", "F:Orchard"];
		} elsif ($landuse eq 'forest') { # see above: natural=wood
		    push @or, ["flaechen", "F:Forest"];
		} elsif ($landuse =~ m{^(?:grass|village_green)$}) {
		    push @or, ["flaechen", "F:Green"]; # XXX not definitely clear
		    #XXX ja? nein? } elsif ($landuse eq 'water') { push @or, ["wasserstrassen", "F:W"];
		} elsif ($landuse eq 'residential') {
		    add_underline(\@or, "_building", "F:#d0d0d0");
		} else {
		    # e.g. greenfield (= Bauerwartungsland)
		    $unhandled{"landuse=$landuse"}++;
		}
	    } elsif (exists $tag{'route'}) {
		my $route = $tag{'route'};
		if      ($route eq 'ferry') {
		TRY_FERRY: {
			my @comments;
			my $day_on  = $tag{'day on'};
			my $day_off = $tag{'day off'};
			my $bicycle = $tag{'bicycle'};
			if ($day_on && $day_off) {
			    push @comments, "$day_on - $day_off";
			}
			if ($bicycle && $bicycle !~ m{^(?:yes|true)$}) {
			    if ($bicycle =~ m{^(?:no|false)$}) {
				last TRY_FERRY;
			    }
			    push @comments, "bicycle=$bicycle";
			}
			my $comments = join("; ", @comments);
			push @or, ["faehren", "Q"];
			if ($comments) {
			    push @or, ["comments_ferry", "CS", name => $comments];
			}
		    }
		} else {
		    $unhandled{"route=$route"}++;
		}
	    } elsif (exists $tag{'amenity'}) {
		push @or, $do_amenity->($is_area->(), $tag{'amenity'}, \%tag);
	    } elsif (exists $tag{'historic'}) {
		push @or, $do_historic->($is_area->(), $tag{'historic'}, \%tag);
	    } elsif (exists $tag{'tourism'}) {
		push @or, $do_tourism->($is_area->(), $tag{'tourism'}, \%tag);
	    } elsif (exists $tag{'building'}) {
		my $building = $tag{'building'};
		if ($building =~ m{^(?:yes|true)$}) {
		    add_underline(\@or, "_building", "F:#cccccc");
		}
	    } elsif (exists $tag{'power'}) {
		if (exists $tag{'operator'}) {
		    $name = ($name ? $name.": " : "") . $tag{'operator'};
		}
		add_underline(\@or, "_power", "X");
	    }

	    if (!@or && !$ignore_unhandled && !$ignore_underline) {
		$do_unhandled->(\$name, \%tag);
		if ($name ne "") {
		    my $cat;
		    if (exists $tag{'landuse'} &&
			$tag{'landuse'} =~ m{^(farm|farmland)$}
		       ) {
			$cat = 'F:#ffdead';
		    } else {
			$cat = 'X';
		    }
		    push @or, ["_unhandled", $cat];
		}
	    }

	    push @or, $do_fixme->(\%tag);

	    for my $or (@or) {
		my($out_file, $cat, %args) = @$or;

		my $name = $name;
		my @nodes = @nodes;
		if ($args{reversed}) {
		    @nodes = reverse @nodes;
		}
		if (defined $args{name}) {
		    $name = $args{name};
		}

		# XXX evtl. die folgenden Direktiven nur im
		# "Hauptfile" ausgeben, siehe "width" unten?
		## Also, it's not lear how to handle all the possible languages. Now
		## the compromise is to use the english entry and the language specified
		## while doing the conversion. Not ideal.
		for my $key (qw(wikipedia website url)) {
		    my $url;
		    for my $_uselang ($lang, '', 'en', 'de') {
			my $suffix = $_uselang ne '' ? ":$_uselang" : '';
			my $uselang = $_uselang ne '' ? $_uselang : 'en';
			if (exists $tag{"$key$suffix"}) {
			    if ($key eq 'wikipedia' && $tag{"$key$suffix"} !~ m{^http:}) {
				$url = "http://$uselang.wikipedia.org/wiki/" . $tag{"$key$suffix"};
			    } else {
				$url = $tag{"$key$suffix"};
			    }
			}
			if ($url) {
			    push @{$out{$out_file}}, ["#: url: $url"];
			    last;
			}
		    }
 		}

		# local, official, historical, regional names etc:  
		# http://wiki.openstreetmap.org/wiki/Key:name
	      	foreach my $key (qw/int_name nat_name reg_name loc_name old_name alt_name official_name/) {
		    if (exists $tag{$key}) {
		    	push @{$out{$out_file}}, ["#: $key: $tag{$key}"];
		    }
		}

		if ((exists $tag{'width'} || exists $tag{'est_width'}) && $out_file eq 'strassen') {
		    my $w = $tag{'width'} || $tag{'est_width'};
		    if ($w =~ m{^([\d\.]+)(?:$|\s*m)}) {
			push @{$out{$out_file}}, ["#: carriageway_width: ${w}m"];
		    } else {
			if ($debug) {
			    if ($w =~ m{^(?:narrow)}) {
				# silently ignore
			    } else {
				warn "Found width/est_width tag, but cannot parse the value '$w' in way '$id'\n";
			    }
			}
		    }
		}
		push @{$out{$out_file}}, [$name, [map { $node2ll{$_} } @nodes], $cat];
	    }
	}
    }
}

######################################################################
# RELATIONS
if ($handle_relations) {
    my %seenrelation;
    for my $osm_file (@osm_files) {
	if ($v) {
	    if ($tp) {
		print STDERR $tp->report("\r  relations done %p elapsed: %L, ETA %E (" . substr(basename($osm_file),0,28) . ")", $osm_file_i++);
	    } else {
		warn "Parse $osm_file for relations...\n";
	    }
	}
	my($dom, $reader) = open_osm($osm_file);
	if ($dom) { die "NYI: no relation support with XML::LibXML, use XML::LibXML::Reader" }
	set_info_handler($osm_file, $dom, $reader);

    PARSE: {
	    $reader->nextElement('relation') == 1 or last PARSE;
	    if (DO_ASSERTS) {
		$reader->name eq 'relation'
		    or parse_warning($reader, "searching for <relation>");
	    }

	    my $next1 = sub {
		if ($reader) {
		    $reader->skipSiblings if $reader->depth == 2;
		    my $res = $reader->nextSiblingElement;
		    if (DO_ASSERTS) {
			($res == 0 || $reader->name =~ m{^(?:relation)}) or
			    parse_warning($reader, "after skipping a relation");
		    }
		}
		no warnings 'exiting';
		next;
	    };

	    while(do {
		no warnings 'uninitialized';
		($reader && $reader->name eq 'relation');
	    }) {
		my $relation = $reader;
		my $id = $relation->getAttribute('id');
		$next1->() if exists $seenrelation{$id};
		$seenrelation{$id} = 1;

		my @members;
		my %tag;
		tie %tag, 'Tie::IxHash' if SORTED_TAGS;
		$reader->nextElement == 1 or last;
		while(1) {
		    my $node_name = $reader->name;
		    if ($node_name eq 'member') {
			push @members, { type => $reader->getAttribute('type'),
					 ref  => $reader->getAttribute('ref'),
					 role => $reader->getAttribute('role'),
				       };
		    } elsif ($node_name eq 'tag') {
			$tag{$reader->getAttribute('k')} = $reader->getAttribute('v');
		    } else {
			last;
		    }
		    $reader->nextElement == 1 or last;
		}

		## In the Berlin data there's only one relation tagged
		## with visible=no (why not false?), so probably wrong
		## and does not need to be handled
		#$next1->() if $tag{'visible'} && $tag{'visible'} eq 'false';

		my @or;
		my $name   = $tag{'name'} || '';

		if (my $route = $tag{'route'}) {
		    if ($route eq 'bicycle') {
			for my $member (@members) {
			    my $role = $member->{role} || '';
			    my $cat = ($role eq 'forward' ? 'radroute;' :
				       $role eq 'backward' ? ';radroute' : 'radroute');
			    push @or, ['comments_route', $cat, $member];
			}
		    } elsif ($route eq 'bus') {
			for my $member (@members) {
			    my $role = $member->{role} || '';
			    my $cat = ($role eq 'forward' ? 'Bus;' :
				       $role eq 'backward' ? ';Bus' : 'Bus');
			    push @or, ['_oepnv', $cat, $member];
			}
		    }
		} elsif ($tag{boundary} && $tag{boundary} eq 'administrative') {
		    my $admin_level = $tag{admin_level} || '?';
		    for my $member (@members) {
			push @or, ['_boundary', 'Z'.$admin_level, $member];
		    }
		}

	    OUTPUT_RECORD: for my $or (@or) {
		    my($out_file, $cat, $member, %args) = @$or;

		    my $name = $name;
		    if ($args{name}) {
			$name = $args{name};
		    }

		    my $member_id = $member->{'ref'};
		    if (!exists $way2nodes{$member_id}) {
			## Don't warn; it's usual that not all
			## relation members are part of the osm
			## download:
			#warn "Member '$member_id' in relation '$id' is missing";
		    } else {
			$out{$out_file} ||= [];
			my $out_array = $out{$out_file};
			my @coords = map { $node2ll{$_} } @{ $way2nodes{$member_id} };
			if ($out_array) {
			    # Check for continuations:
			    my $last_record = $out_array->[-1];
			    if ($last_record->[0] eq $name &&
				$last_record->[1][-1] eq $coords[0] &&
				$last_record->[2] eq $cat
			       ) {
				shift @coords;
				push @{$last_record->[1]}, @coords;
				next OUTPUT_RECORD;
			    }
			}
			push @$out_array, [$name, \@coords, $cat];
		    }
		}
	    }
	}
    }
}

######################################################################
# POST PROCESSING

resolve_node_fallback();
sort_by_population_and_category();

######################################################################
# OUTPUT
if ($parsefor) {
    output_data(\*STDOUT, $out{"-"});
} else {
    if (!-d $o) {
	if (!mkdir $o) {
	    die "Cannot create output directory <$o>: $!" if !$f;
	}
    }
    chdir $o
	or die "Cannot chdir to $o: $!";
    while(my($filename,$data) = each %out) {
	print STDERR "$filename... " if $debug;
	open my $ofh, ">:encoding($encoding)", "$filename~"
	    or die "Can't write to file <$filename~> in directory <$o>: $!";
	output_data($ofh, $data, $filename);
	close $ofh
	    or die "Error while closing: $!";
	rename "$filename~", $filename
	    or die "Can't rename $filename~ to $filename: $!";
	print STDERR "\n" if $debug;
    }

    # required files (dummy files, bbbike or bbbike.cgi like to have these):
    for my $file (qw(gesperrt gesperrt_car
		     wasserumland wasserumland2 hoehe
		     orte orte2 qualitaet_l handicap_l
		     berlin deutschland orte_city
		     landstrassen landstrassen2
		     ubahn ubahnhof sbahn sbahnhof rbahn rbahnhof
		     gesperrt_u gesperrt_s gesperrt_r
		     radwege_exact fragezeichen
		     Berlin.coords.data Potsdam.coords.data
		     plaetze ampeln green nolighting
		    )) {
	touch $file;
    }
    for (qw(cyclepath misc path route tram kfzverkehr scenic ferry danger mount)) {
	touch "comments_$_";
    }
    # radwege will be used for plotting, radwege_exact for routing.
    # New bbbike can use the same file for both, but for hysterical
    # reasons still uses different files.
    if (!-e "radwege" && -e "radwege_exact") {
	symlink "radwege_exact", "radwege"
	    or warn "Cannot create symlink radwege -> radwege_exact: $!";
    }
    if (!-d "temp_blockings") {
	mkdir "temp_blockings";
    }
    touch "temp_blockings/bbbike-temp-blockings.pl";
    output_meta();
}

if (%unhandled && $debug >= 1) {
    print "Unhandled categories:\n";
    local $Data::Dumper::Sortkeys = 1;
    print Dumper (\%unhandled);
}

#exit;

######################################################################

# Decide whether U/S-Bahn is a real "public" railway or just a service
# one. Heuristics could work for Germany, but is currently restricted
# to Berlin.
sub is_rail_service {
    my($type, $name, $nodes_ref) = @_;
    return 0 if ($type eq 'U' && $name =~ /^U\s*\d/);
    return 0 if ($type eq 'S' && $name =~ /^S\s*\d/);
    my($lon,$lat) = split /,/, $node2ll{$nodes_ref->[0]};
    my($east,$north) = split /,/, $conv->(14.525134, 52.826885);
    my($west,$south) = split /,/, $conv->(12.545141, 52.112717);
    return 0 if ($lat > $north || $lat < $south ||
		 $lon > $east  || $lon < $west); # outside Berlin and region
    return 1;
}

sub resolve_node_later {
    my($osm_layer, $name, $coord) = @_;
    $resolve_node_later{$osm_layer}->{$coord} = $name;
}

sub resolve_node_now {
    my($osm_layer, $bbbike_layer, $bbbike_cat, $nodes_ref) = @_;
    my $r = $resolve_node_later{$osm_layer};
    my $resolved = $resolved{$osm_layer};
    my $normalize_name = {ubahnhof => \&normalize_name_ubahnhof,
			  sbahnhof => \&normalize_name_sbahnhof,
			 }->{$bbbike_layer};
    do{warn "no $osm_layer layer"; return} if !$r;
    for my $coord (map { $node2ll{$_} } @$nodes_ref) {
	if (defined $coord && exists $r->{$coord}) {
	    my $name = $r->{$coord};
	    $name = $normalize_name->($name) if $normalize_name;
	    push @{$out{$bbbike_layer}}, [$name, [$coord], $bbbike_cat];
	    delete $r->{$coord};
	    $resolved->{$coord}++;
	}
    }
}

sub resolve_node_fallback {
    my $have_unresolved = 0;
    for (keys %resolve_node_later) {
	if (keys %{$resolve_node_later{$_}}) {
	    $have_unresolved++; # XXX maybe, may be some already in %resolved
	    last;
	}
    }
    return if !$have_unresolved;

    print STDERR "unresolved:\n" if $debug;
    for my $osm_layer (keys %resolve_node_later) {
	print STDERR "  $osm_layer:\n" if $debug;
	my $resolved = $resolved{$osm_layer};
	while(my($coord, $name) = each %{ $resolve_node_later{$osm_layer} }) {
	    next if $resolved->{$coord};
	    if ($osm_layer eq 'railway') {
		my($file, $cat);
 		if ($name =~ s{^U(|-Bhf)\s+}{}) {
		    ($file, $cat) = ("ubahnhof", "UA"); # zone is faked
 		} elsif ($name =~ s{^S(|-Bhf)\s+}{}) {
		    ($file, $cat) = ("sbahnhof", "SA");
 		} else {
		    ($file, $cat) = ("rbahnhof", "RA");
 		}
		push @{$out{$file}}, [$name, [$coord], $cat];
		print STDERR "    fallback for $name -> $cat $file\n" if $debug;
	    } else {
		print STDERR "    NO FALLBACK for $name ($coord)\n" if $debug;
	    }
	}
    }
}

sub normalize_name_ubahnhof {
    my $name = shift;
    $name =~ s{^U(\s+|-Bhf)\.?\s*}{};
    $name;
}

sub normalize_name_sbahnhof {
    my $name = shift;
    $name =~ s{^S(\s+|-Bhf)\.?\s*}{};
    $name;
}

sub sort_by_population_and_category {
    @{$out{"orte"}} = map {
	$_->[1]
    } sort {
	(defined $b->[0] && defined $a->[0] && $b->[0] <=> $a->[0]) ||
	    $b->[1][STRASSEN_CAT] <=> $a->[1][STRASSEN_CAT]
    } map {
	[$place_to_population{$_->[1][STRASSEN_NAME]} || undef, $_]
    } @{$out{"orte"}};
}

sub output_data {
    my($ofh, $data, $filename) = @_;
    print $ofh <<EOF;
#: #: -*- coding: $encoding -*-
EOF
    if ($encoding ne 'iso-8859-1') {
	print $ofh <<EOF;
#:encoding: $encoding
EOF
    }
    if (!$map) {
	print $ofh <<EOF;
#:map: polar
EOF
    } elsif ($map ne 'bbbike') {
	print $ofh <<EOF;
#:map: $map
EOF
    }
my $isodate = epoch2isodatez;
$isodate = 'fixed' if $nodate;

print $ofh <<EOF;
#:date: $isodate
EOF
    if ($global_directives{$filename}) {
	for my $directive (@{ $global_directives{$filename} }) {
	    print $ofh <<EOF;
#:$directive
EOF
	}
    }

    my $p = basename($prog);
    print $ofh <<EOF;
#:
#
# OpenStreetMap data can be used freely under the terms of the 
# Creative Commons Attribution-ShareAlike 2.0 license.
# http://wiki.openstreetmap.org/wiki/OpenStreetMap_License
#
# Converted from openstreetmap data using $p v$VERSION $git_id
#
# DO NOT EDIT THIS FILE! Edit the original openstreetmap data!
#
EOF
    for my $rec (@$data) {
	my($name, $coords, $cat) = @$rec;
	if (!defined $coords) {
	    # a directive
	    print $ofh $name, "\n";
	    next;
	}
	my $namecat = "$name\t$cat";
	my $coord_string = join(" ", grep { defined } @$coords);
	if ($splitlonglines && length($namecat) + length($coord_string) + 2 >= MAXLINELENGTH) {
	    warn_once("Long line detected in $filename, splitting...\n");
	    my $currlen = length($namecat);
	    print $ofh $namecat;
	    my $lastc;
	    for my $c (grep { defined } @$coords) {
		if ($currlen + 1 + length($c) + 1 > MAXLINELENGTH) {
		    print $ofh "\n$namecat $lastc";
		    $currlen = length($namecat);
		}
		print $ofh " ", $c;
		$lastc = $c;
		$currlen += 1 + length($c);
	    }
	    print $ofh "\n";
	} else {
	    print $ofh $namecat, " ", $coord_string, "\n";
	}
    }
}

sub output_meta {
    my $meta_file_dd  = "meta.dd";
    my $meta_file_yml = "meta.yml";

    my %meta;

    $meta{created} = epoch2isodatez;
    $meta{created_by} = $ENV{EMAIL} || $ENV{REPLYTO} || $ENV{REPLY_TO} || (getpwuid($<))[0];
    $meta{commandline} = \@commandline;
    $meta{creation_cwd} = $cwd;
    if (@bbox_wgs84) {
	my @bbox;
	@bbox[0,1] = split /,/, $conv->(@bbox_wgs84[0,1]);
	@bbox[2,3] = split /,/, $conv->(@bbox_wgs84[2,3]);
	$meta{bbox} = \@bbox;
	$meta{bbox_wgs84} = \@bbox_wgs84;
    }
    $meta{center} = [split /,/, $center] if defined $center;
    $meta{source} = 'osm';
    #$meta{source_files} = \@osm_files; # XXX hmmm, too many?
    $meta{coordsys} = $map ? $map : 'wgs84';
    $meta{skip_features} = {green        => 1, # no support in osm data
			    obst         => 1, # -"-
			    landstrassen => 1, # no scoping with osm data
			    wasserumland => 1, # -"-
			    wideregion   => 1, # -"-
			    vbb          => 1, # even in Berlin, because we don't have the VBB zone info
			    # following are skipped if no data was found
			    (!$out{nolighting} || !@{ $out{nolighting} } ? (nolighting => 1) : ()),
			    (!$out{faehren} || !@{ $out{faehren} } ? (faehren => 1) : ()),
			   };
    for my $def (['u-bahn', ['ubahn', 'ubahnhof']],
		 ['s-bahn', ['sbahn', 'sbahnhof']],
		 ['r-bahn', ['rbahn', 'rbahnhof']],
		) {
	my($feature_name, $layers) = @$def;
    CHECK_EMPTY_LAYER: {
	    for my $layer (@$layers) {
		last CHECK_EMPTY_LAYER if -s $layer;
	    }
	    $meta{skip_features}->{$feature_name} = 1;
	}
    }

    if ($no_create) {
	undef $meta{created};
	undef $meta{created_by};
	undef $meta{creation_cwd};
    }

    open my $ofh, ">", $meta_file_dd."~"
	or die "Cannot write to $meta_file_dd~: $!";
    print $ofh Data::Dumper->new([\%meta],['meta'])->Sortkeys(1)->Useqq(1)->Dump;
    close $ofh
	or die "While closing $meta_file_dd~: $!";
    rename $meta_file_dd."~", $meta_file_dd
	or die "While renaming $meta_file_dd~ to $meta_file_dd: $!";

    if (eval { require YAML::Syck; 1 }) {
	YAML::Syck::DumpFile($meta_file_yml, \%meta);
    } elsif (eval { require YAML; 1 }) {
	YAML::DumpFile($meta_file_yml, \%meta);
    } else {
	warn "No YAML::Syck or YAML.pm available, cannot dump $meta_file_yml.\n";
	unlink $meta_file_yml; # may be an older file there
    }
}

sub touch ($) {
    my $file = shift;
    sysopen my $fh, $file, O_WRONLY|O_CREAT|O_NONBLOCK|O_NOCTTY
	or die "Can't create $file: $!";
    close $fh
	or die "Can't close $file: $!";
}

sub open_osm {
    my $osm_file = shift;
    my($dom, $reader);
    my $fh;
    if ($osm_file =~ m{\.gz$}) {
	if (!eval { require PerlIO::gzip; 1 }) {
	    open $fh, '-|', 'gzip', '-dc', $osm_file
		or die "Can't run zcat on $osm_file: $!";
	} else {
	    open $fh, "<:gzip", $osm_file
		or die "Can't open file $osm_file: $!";
	}
    } elsif ($osm_file =~ m{\.bz2$}) {
## See https://rt.cpan.org/Ticket/Display.html?id=42241
# 	if (!eval { require PerlIO::via::Bzip2; 1 }) {
# 	    die "No support for bzip2-compressed osm files, PerlIO::via::Bzip2 is missing.\n";
# 	}
# 	open $fh, "<:via(Bzip2)", $osm_file
# 	    or die "Can't open file $osm_file: $!";
	open $fh, "-|", "bunzip2", "--stdout", $osm_file
	    or die "Can't run bunzip2 on $osm_file: $!";
    }

    my @xmlparser;
    if ($xmlparser) {
	@xmlparser = $xmlparser;
    } else {
	@xmlparser = ('XML::LibXML::Reader', 'XML::LibXML');
    }

    for my $_try (@xmlparser) {
	if ($_try eq 'XML::LibXML::Reader') {
	    if (eval { require XML::LibXML::Reader; 1 }) {
		if ($fh) {
		    $reader = XML::LibXML::Reader->new(IO => $fh);
		} else {
		    $reader = XML::LibXML::Reader->new(location => $osm_file);
		}
		last;
	    }
	} elsif ($_try eq 'XML::LibXML') {
	    if (eval { require XML::LibXML; 1 }) {
		my $p = XML::LibXML->new;
		if ($fh) {
		    $dom = $p->parse_fh($fh)->documentElement;
		} else {
		    $dom = $p->parse_file($osm_file)->documentElement;
		}
		last;
	    }
	} else {
	    die "Unknown XML parser $_try";
	}
    }

    if (!$dom && !$reader) {
	if (!-e $osm_file) {
	    die "The file '$osm_file' does not exist.\n";
	} elsif (!-r $osm_file) {
	    die "The file '$osm_file' is not readable.\n";
	} else {
	    die "XML::LibXML has to be installed. Please fetch it from CPAN.\n";
	}
    }
    ($dom, $reader);
}

sub set_info_handler {
    my($osm_file, $dom, $reader) = @_;
    no warnings 'signal'; # INFO is usually only available on BSD systems
    $SIG{INFO} = sub {
	my $msg = "File $osm_file";
	if ($reader) {
	    no warnings 'uninitialized';
	    $msg .= sprintf ", bytes consumed %d, line %d, current node name '%s', id=%s", $reader->byteConsumed, $reader->lineNumber, $reader->name, $reader->getAttribute('id');
	}
	print STDERR $msg, "\n";
	print STDERR "Memory: ", join(", ", currmem()), "\n";
	require Carp; Carp::carp('Currently');
    };
}

sub parse_warning {
    my($reader, $where) = @_;
    require Carp;
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    Carp::carp("*** PARSE WARNING: unexpected node <" . $reader->name . "> at line " . $reader->lineNumber . " $where");
}

{
    my %warn_once;
    sub warn_once {
	my $warning = join(" ", @_);
	return if $warn_once{$warning};
	warn $warning;
	$warn_once{$warning}++;
    }
}

sub epoch2isodatez (;$) {
    my $time = shift || time;
    my @l = gmtime $time;
    sprintf("%04d%02d%02d%02d%02d%02dZ",
	    $l[5]+1900, $l[4]+1, $l[3],
	    $l[2],      $l[1],   $l[0]);
}

# REPO BEGIN
# REPO NAME is_interactive /home/e/eserte/work/srezic-repository 
# REPO MD5 87e9e2500fbe4a3ffe5f977de8513d47
sub is_interactive {
    if ($^O eq 'MSWin32' || !eval { require POSIX; 1 }) {
	# fallback
	return -t STDIN && -t STDOUT;
    }

    # from perlfaq8
    open(TTY, "/dev/tty") or die $!;
    my $tpgrp = POSIX::tcgetpgrp(fileno(*TTY));
    my $pgrp = getpgrp();
    if ($tpgrp == $pgrp) {
	1;
    } else {
	0;
    }
}
# REPO END

# REPO BEGIN
# REPO NAME currmem /home/e/eserte/work/srezic-repository 
# REPO MD5 00fa532c42d6ade32b01e3fad34331a4

=item currmem([$pid])

=for category System

Return ($mem, $realmem) of the current process or process $pid, if $pid
is given.

On Linux, an even shorter alternative for getting the virtual memory is:

    cat /proc/$$/stat | cut -d" " -f 23

=cut

sub currmem {
    my $pid = shift || $$;
    no warnings 'portable'; # because of possible large hex values on 64bit systems
    if ($^O eq 'freebsd' && open(MAP, "dd if=/proc/$pid/map bs=64k 2>/dev/null |")) { # FreeBSD
	my $mem = 0;
	my $realmem = 0;
	while(<MAP>) {
	    my(@l) = split /\s+/;
	    my $delta = (hex($l[1])-hex($l[0]));
	    $mem += $delta;
	    if ($l[11] ne 'vnode') {
		$realmem += $delta;
	    }
	}
	close MAP;
	($mem, $realmem);
    } elsif ($^O eq 'linux' && open(MAP, "/proc/$pid/maps")) { # Linux
	my $mem = 0;
	my $realmem = 0;
	while(<MAP>) {
	    my(@l) = split /\s+/;
	    my($start,$end) = split /-/, $l[0];
	    my $delta = (hex($end)-hex($start));
	    $mem += $delta;
	    if (!defined $l[5] || $l[5] eq '') {
		$realmem += $delta;
	    }
	}
	close MAP;
	($mem, $realmem);
    } else {
	undef;
    }
}
# REPO END

__END__

=head1 NAME

osm2bbd - convert OpenStreetMap data for BBBike

=head1 SYNOPSIS

    ./osm2bbd [options] -o /path/to/output /path/to/osm/files

=head1 HOWTO

Create a directory where to download OSM data. It's best to use an
empty directory. Convention: I use
C<misc/download/osm/I<region_name>> as a path name. For Berlin, this
would be:

    cd /path/to/bbbike
    mkdir -p misc/download/osm/berlin

Use L<downloadosm> to download the OSM data. Decide first on the
bounding box to download (see also hints below). To load all of
Berlin, use

    ./miscsrc/downloadosm -o misc/download/osm/berlin 13.010982 52.337651 13.761388 52.675354

With a standard DSL connection, this last about 1:30 hours, totalling
220 MB of data (as of July 2008, in Januar 2009, it was nearly 400
MB). Note that it's fine to use also larger osm files (i.e. in the
size of a German state), e.g. the prepared files from
L<http://download.geofabrik.de>. Gzipped and bzipped osm files are fine,
but need C<zcat> resp. C<bunzip2> installed.

Now convert the OSM data into a BBBike-readable format. This should
take 5 minutes or so (Athlon64, i386-freebsd) for the above dataset.
Decide on the destination directory. Convention: I use
C<data_I<region_name>_osm_bbbike>. Note: this directory should not
exist. For Berlin, this would be:

    ./miscsrc/osm2bbd -v -map bbbike -o data_berlin_osm_bbbike/ misc/download/osm/berlin

Finally call bbbike with the C<-datadir> option:

    ./bbbike -datadir data_berlin_osm_bbbike

=head2 HINTS

To get the bbox of a bbd file, use:

    perl -l -MKarte::Standard -MKarte::Polar -MStrassen -e '$s=Strassen->new("data/strassen"); ($x1,$y1,$x2,$y2) = $s->bbox; print join(",", $Karte::Polar::obj->standard2map($x1,$y1),$Karte::Polar::obj->standard2map($x2,$y2))'

Get the visible area in the BBBike application. Start ptksh within
BBBike (in the Settings menu if bbbike was started with -advanced, orr
hit just Shift-P) and the type in:

    @corners = $c->get_corners;
    join(",", $Karte::Polar::obj->standard2map(anti_transpose(@corners[0,1])), 
              $Karte::Polar::obj->standard2map(anti_transpose(@corners[2,3])));

=head1 EXAMPLES

To convert data for the San Francisco area:

=over

=item 1. download geo data for San Francisco/SFO from opensteetmaps.org

    ./miscsrc/downloadosm -o ../sfbike/sfo -- -122.527 37.594 -122.351 37.811

=item 2. convert *.osm files to bbbike data

    ./miscsrc/osm2bbd -f -map bbbike -center -122.598,37.6829 -country us -o data-sfo ../sfbike/sfo

=item 3. (optional) do some additional postprocessing

    ./miscsrc/osm2bbd-postprocess data-sfo

=item 4. start sfbike, english version

    env LANG=en_US.UTF-8 perl ./bbbike -datadir data-sfo

=back

=head1 SUPPORTED LANGUAGES

If no language is specified, then output is optimized for German. The
only other language currently supported is English (C<en>).

=head1 SUPPORTED COUNTRIES

Currently there's only special handling for C<de>: motorways get
translated from "AI<number>" to "BABI<number>" to for handling with
BBBike.

=head1 EXPERIMENTS

The C<-experimental> switch turns experimental features on. Currently
are defined:

=over

=item C<add_postal_code>

Add the postal code (if available) to every street name. This helps in
cases when street names are ambigous (because the area is large enough
to cover multiple cities, or if the same street name exists multiple
times in the same city).

=item C<coastline_hack>

Prepare for better coastline handling. This needs additional support
from L<osm2bbd-postprocess>. See the C<-only-coastline-hack> and
C<-coastline-hack-anchor> options there.

=item C<polar_coord_hack>

Turn the polar coordinates hack on. This would create a rewritten
version of the module L<Karte::Polar>, which is adapted to the central
latitude of the processed region. This means distance calculation is
still not perfect, but far better for regions far away from the
reference latitude of BBBike (which is 52.5°, the latitude of Berlin).
Currently only the Perl/Tk version has out-of-the-box support for this
hack. To use the hack in the CGI implementation it is necessary to add
something like

    unshift @INC, "/path/to/datadir;

best in the configuration file F<bbbike.cgi.config> (or whatever
config file is used).

=back

=head1 IMPLEMENTATION NOTES

There are two parsing modes, which can be switched by using the
C<-xmlparser> switch: C<XML::LibXML::Reader> and C<XML::LibXML>. The
C<XML::LibXML> parsing mode is more robust, but takes much more memory
especially for large osm files. The C<XML::LibXML::Reader> parsing
mode is work in progress but the only option to parse large osm files.

Currently C<XML::LibXML::Reader> is the default parsing mode.

=head1 BUGS/TODO

There are a lot of bugs and unsolved issues.

=over

=item * It is not clear whether to put cycle data to F<radwege> or
F<radwege_exact>. In the long run, F<radwege> should be completely
replaced by F<radwege_exact>.

=item * BBBike should be fixed to handle normal WGS84 coordinates for
everything. Currently the best we get is the C<polar_coord_hack>
mentioned in L</EXPERIMENTS>.

=item * Tunnel mound optimization needed! Problem visible in
Nord-Süd-Tunnel. Possible implementation: remember the end points with
the neighbor point (that is, for A B C D E remember A B and E D). This
structure points to the data record and is indexed by the end points.
Before doing the bbd output do another processing step: for every
remembered item check whether there is another item with the same end
point but another neighbor point. If such an item exists, then add the
"_" (no mound) attribute to the Tu category on the right side.

=item * It seems that "holes" in buildings are specified by just a
closed <way> without any name and other tag. Implementation
suggestion: put all the closed ways without any other tags into a
special bucket and output at the end of the corresponding layer.
Question: how to get the corresponding layer? Check for inclusion?

Update: there is usually also a relation with outer and inner roles.

=item * Look at the Reichstag. Get rid of the multiple stars (is this
a bbbike or osm2bbd task?)

=item * Currently the url tag will be output as a url directive into
the bbd file. Maybe use a info file instead, because currently the
info support in bbbike is better than the directive support? Or make
the directive support in bbbike better?

=back

=head1 AUTHOR

Slaven Rezic

=head1 SEE ALSO

L<osm2bbd-postprocess>, L<downloadosm>.

=cut

