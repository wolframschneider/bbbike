#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: osm2bbd,v 1.12 2008/01/12 22:02:09 eserte Exp eserte $
# Author: Slaven Rezic
#
# Copyright (C) 2008 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib "$FindBin::RealBin/..";

use Data::Dumper;
use Getopt::Long;
use IO::File;
use XML::LibXML;

sub epoch2isodate (;$);
sub touch ($);

my $o;
my $f;
my $v;
my $encoding = "utf-8";

my $map;
my $center;
GetOptions("o=s" => \$o,
	   "f" => \$f,
	   "v" => \$v,
	   "map=s" => \$map,
	   "center=s" => \$center,
	   "encoding=s" => \$encoding,
	  )
    or die <<EOF;
usage: $0 [-v] [-f] [-encoding enc] [-map bbbike -center lon,lat] -o directory osmfile ...
EOF

my @osm_files = @ARGV;
if (!@osm_files) {
    die <<EOF;
Please specify one or more osm files. To download an osm file, you can use
for example
wget -O filename.osm http://www.openstreetmap.org/api/0.5/map?bbox=x0,y0,x1,y1
EOF
}

if (!$o) {
    die "Please specify (non-existent) output directory with -o option.\n";
}
if (!$f && -e $o) {
    die "Output directory <$o> must not exist (or specify -f to force overwrite).\n";
}

my $p = XML::LibXML->new;

my %unhandled;
my %out;

my $do_amenity = sub {
    my($node) = @_;
    my @or;
    my $F = $node->tagName eq 'way' ? "F:" : ""; # area or not?
    my $amenity = $node->findvalue('./tag[@k="amenity"]/@v');
    if ($amenity eq 'place_of_worship') {
	my $religion = $node->findvalue('./tag[@k="religion"]/@v');
	if (!$religion || $religion eq 'christian') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:church"];
	} elsif ($religion eq 'jewish') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:synagogue"];
	} else {
	    $unhandled{"amenity-religion-$religion"}++;
	}
    } elsif ($amenity eq 'museum') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:museum"];
    } elsif ($amenity eq 'hospital') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:hospital"];
    } elsif ($amenity =~ m{^theat(?:er|re)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:theater"];
    } elsif ($amenity =~ m{^(shopping|shopping_centre)$}) {
	push @or, ["sehenswuerdigkeit", $F."Shop"];
    } elsif ($amenity =~ m{^(arts_center|courthouse|library|police|post_office|public_building|townhall|university)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW"];
    } else {
	$unhandled{"amenity-$amenity"}++;
    }
    @or;
};

my $conv = sub {
    my($lon,$lat) = @_;
    "$lon,$lat";
};
if ($map) {
    if ($map ne 'bbbike') {
	die "Only -map bbbike is supported.\n";
    }
    require Karte::Polar;
    require Karte::Standard;

    my($dx,$dy) = (0,0);
    if ($center) {
	my($c_lon,$c_lat) = split /,/, $center;
	($dx,$dy) = $Karte::Standard::obj->trim_accuracy($Karte::Polar::obj->map2standard($c_lon,$c_lat));
    }

    $conv = sub {
	my($lon,$lat) = @_;
	my($x,$y) = $Karte::Standard::obj->trim_accuracy($Karte::Polar::obj->map2standard($lon,$lat));
	($x-$dx).",".($y-$dy);
    };
}

my %node2ll;
for my $osm_file (@osm_files) {
    warn "Parse $osm_file for nodes...\n" if $v;
    my $root = $p->parse_file($osm_file)->documentElement;
    for my $node ($root->findnodes("/osm/node")) {
	my $id = $node->findvalue('./@id');
	next if exists $node2ll{$id};
	my $lat = $node->findvalue('./@lat');
	my $lon = $node->findvalue('./@lon');
	$node2ll{$id} = $conv->($lon,$lat);

	my @or;

	my $name = $node->findvalue('./tag[@k="name"]/@v');
	my $railway_cat = $node->findvalue('./tag[@k="railway"]/@v');
	my $highway_cat = $node->findvalue('./tag[@k="highway"]/@v');
	my $amenity = $node->findvalue('./tag[@k="amenity"]/@v');

	if ($railway_cat) {
	    if ($railway_cat eq 'station') {
		if ($name =~ m{^U\s}) {
		    push @or, ["ubahnhof", "UA"]; # note: not zones; XXX how to distinguish U, S and Regionalbahn correctly???
		} elsif ($name =~ m{^S\s}) {
		    push @or, ["sbahnhof", "SA"]; # - " -
		} else {
		    push @or, ["rbahnhof", "RA"]; # - " -
		}
		# fix name, remove "Bahnhof":
		if ($name) {
		    $name =~ s{^([US]\s*)?(?:Bahnhof|Bhf\.?)\s+(.+)}{$1$3};
		}
	    } elsif ($railway_cat =~ m{^(crossing|level_crossing)$}) {
		push @or, ["ampeln", "B"];
	    } else {
		$unhandled{"node-railway=$railway_cat"}++;
	    }
	} elsif ($highway_cat) {
	    if ($highway_cat eq 'traffic_signals') {
		push @or, ["ampeln", "X"];
	    } else {
		$unhandled{"node-highway=$highway_cat"}++;
	    }
	} elsif ($amenity) {
	    push @or, $do_amenity->($node);
	}

	for my $or (@or) {
	    my($out_file, $cat) = @$or;
	    push @{$out{$out_file}}, [$name, [$node2ll{$id}], $cat];
	}
    }
}

my %seenway;
for my $osm_file (@osm_files) {
    warn "Parse $osm_file for ways...\n" if $v;
    my $root = $p->parse_file($osm_file)->documentElement;
    for my $way ($root->findnodes('/osm/way[@visible="true"]')) {
	my $id = $way->findvalue('./@id');
	next if exists $seenway{$id};
	$seenway{$id} = 1;

	my @or;

	my @nodes = map { $_->textContent } $way->findnodes('./nd/@ref');
	my $name = $way->findvalue('./tag[@k="name"]/@v');
	my $highway_cat = $way->findvalue('./tag[@k="highway"]/@v');
	my $waterway_cat = $way->findvalue('./tag[@k="waterway"]/@v');
	my $railway_cat = $way->findvalue('./tag[@k="railway"]/@v');
	my $boundary = $way->findvalue('./tag[@k="boundary"]/@v');
	my $admin_level = $way->findvalue('./tag[@k="admin_level"]/@v');
	my $natural = $way->findvalue('./tag[@k="natural"]/@v');
	my $oneway = $way->findvalue('./tag[@k="oneway"]/@v');
	my $sport = $way->findvalue('./tag[@k="sport"]/@v');
	my $leisure = $way->findvalue('./tag[@k="leisure"]/@v');
	my $cycleway = $way->findvalue('./tag[@k="cycleway"]/@v');
	my $landuse = $way->findvalue('./tag[@k="landuse"]/@v');
	my $route = $way->findvalue('./tag[@k="route"]/@v');
	my $amenity = $way->findvalue('./tag[@k="amenity"]/@v');

	my $do_cycleway = sub {
	    my @or;
	    if      ($cycleway eq 'lane') {
		push @or, ["radwege_exact", "RW4"];
	    } elsif ($cycleway eq 'track') {
		push @or, ["radwege_exact", "RW1"];
	    } elsif ($cycleway eq 'opposite') {
		push @or, ["radwege_exact", "RW9"];
	    } else {
		$unhandled{"cycleway-$cycleway"}++;
	    }
	    @or;
	};

	if ($highway_cat) {
	    my $is_motorway = 0;
	    if      ($highway_cat =~ m{^(motorway|motorway_link|trunk|trunk_link)$}) {
		push @or, ["strassen_bab", "BAB"];
		$is_motorway = 1;
	    } elsif ($highway_cat =~ m{^(primary|primary_link|secondary)$}) {
		push @or, ["strassen", "HH"];
	    } elsif ($highway_cat eq 'tertiary') {
		push @or, ["strassen", "H"];
	    } elsif ($highway_cat =~ m{^(residential|unclassified)$}) {
		push @or, ["strassen", "N"];
	    } elsif ($highway_cat eq 'cycleway') {
		push @or, ["strassen", "NN"];
	    CYCLEWAY_KEY: {
		    if ($cycleway) {
			my @sub_or = $do_cycleway->();
			if (@sub_or) {
			    push @or, @sub_or;
			    last CYCLEWAY_KEY;
			}
		    }
		    # fallback
		    push @or, ["radwege_exact", "RW1"];
		}
	    } elsif ($highway_cat eq 'unsurfaced') {
		push @or, ["strassen", "N"];
		push @or, ["qualitaet_s", "Q2", name => ($name ? "$name: " : "") . "unbefestigte Straße"];
	    } elsif ($highway_cat eq 'track') {
		push @or, ["strassen", "NN"];
		push @or, ["qualitaet_s", "Q2", name => ($name ? "$name: " : "") . "Pfad"];
	    } elsif ($highway_cat eq 'footway') {
		push @or, ["strassen", "NN"];
		push @or, ["handicap_s", "q1", name => ($name ? "$name: " : "") . "Fußweg"];
	    } elsif ($highway_cat eq 'pedestrian') {
		push @or, ["strassen", "NN"];
		push @or, ["handicap_s", "q4", name => ($name ? "$name: " : "") . "Fußgängerzone"];
	    } else {
		$unhandled{"highway=$highway_cat"}++;
	    }
	    if ($oneway && !$is_motorway) {
		if ($oneway =~ m{^(yes|true)$}) {
		    push @or, ["gesperrt", "1", reversed => 1];
		} else {
		    $unhandled{"oneway=$oneway"}++;
		}
	    }
	} elsif ($waterway_cat) {
	    if      ($waterway_cat eq 'riverbank') {
		push @or, ["wasserstrassen", "F:W"];
	    } elsif ($waterway_cat eq 'canal') {
		push @or, ["wasserstrassen", "W"];
	    } elsif ($waterway_cat eq 'river') {
		push @or, ["wasserstrassen", "W1"];
	    } elsif ($waterway_cat eq 'stream') {
		push @or, ["wasserstrassen", "W2"];
	    } else {
		$unhandled{"waterway=$waterway_cat"}++;
	    }
	} elsif ($railway_cat) {
	    if      ($railway_cat eq 'subway') {
		push @or, ["ubahn", "U"]; # no zones here
	    } elsif ($railway_cat eq 'rail') {
		push @or, ["rbahn", "R"];
	    } elsif ($railway_cat eq 'preserved') {
		# ignore
	    } elsif ($railway_cat eq 'service') {
		push @or, ["rbahn", "RG"];
	    } elsif ($railway_cat =~ m{^(abandoned|disused)$}) {
		push @or, ["rbahn", "R0"];
	    } elsif ($railway_cat =~ m{\btram\b}) {
		# ignore it.
		# Might be on the street and would then go to comments_tram, but we don't know it from osm data
	    } else {
		$unhandled{"railway=$railway_cat"}++;
	    }
	} elsif ($boundary) {
	    if      ($boundary eq 'administrative') {
		if ($admin_level == 8) {
		    push @or, ["berlin_ortsteile", "Z"];
		} else {
		    $unhandled{"boundary=administrative,admin_level=$admin_level"}++;
		}
	    } else {
		$unhandled{"boundary=$boundary"}++;
	    }   
	} elsif ($natural) {
	    if      ($natural eq 'water') {
		push @or, ["wasserstrassen", "F:W"];
	    } elsif ($natural eq 'wood') {
		push @or, ["flaechen", "F:Forest"];
	    } elsif ($natural eq 'land') {
		my $place = $way->findvalue('./tag[@k="place"]/@v');
		my $island = $way->findvalue('./tag[@k="island"]/@v');
		if (($place && $place eq 'island') ||
		    ($island && $island =~ m{^(yes|true)$})
		   ) {
		    push @or, ["wasserstrassen", "F:I"];
		}
	    } else {
		$unhandled{"natural=$natural"}++;
	    }
	} elsif ($sport) {
	    if      ($sport =~ m{^(soccer|athletics)$}) {
		push @or, ["flaechen", "F:Sport"];
	    } else {
		$unhandled{"sport=$sport"}++;
	    }
	} elsif ($leisure) {
	    if      ($leisure eq 'park') {
		push @or, ["flaechen", "F:P"];
	    } elsif ($leisure eq 'stadium') {
		push @or, ["flaechen", "F:Sport"];
	    } else {
		$unhandled{"leisure=$leisure"}++;
	    }
	} elsif ($cycleway) {
	    push @or, $do_cycleway->();
	} elsif ($landuse) {
	    if      ($landuse eq 'cemetery') {
		push @or, ["flaechen", "F:Cemetery"];
	    } elsif ($landuse eq 'industrial') {
		push @or, ["flaechen", "F:Industrial"];
	    } elsif ($landuse eq 'allotments') {
		push @or, ["flaechen", "F:Orchard"];
	    } else {
		$unhandled{"landuse=$landuse"}++;
	    }
	} elsif ($route) {
	    if      ($route eq 'ferry') {
	    TRY_FERRY: {
		    my @comments;
		    my $day_on = $way->findvalue('./tag[@k="day on"]/@v');
		    my $day_off = $way->findvalue('./tag[@k="day off"]/@v');
		    my $bicycle = $way->findvalue('./tag[@k="bicycle"]/@v');
		    if ($day_on && $day_off) {
			push @comments, "$day_on - $day_off";
		    }
		    if ($bicycle && $bicycle !~ m{^(yes|true)$}) {
			if ($bicycle =~ m{^(no|false)$}) {
			    last TRY_FERRY;
			}
			push @comments, "bicycle=$bicycle";
		    }
		    my $comments = join("; ", @comments);
		    push @or, ["faehren", "Q"];
		    if ($comments) {
			push @or, ["comments_ferry", "CS", name => $comments];
		    }
		}
	    } else {
		$unhandled{"route=$route"}++;
	    }
	} elsif ($amenity) {
	    push @or, $do_amenity->($way);
	}

	if (!@or) {
	    for my $tag ($way->findnodes('./tag')) {
		my($key,$val) = ($tag->findvalue('./@k'),
				 $tag->findvalue('./@v'));
		next if $key =~ m{^(name|created_by)$};
		if ($name) { $name .= "; " }
		$name .= "$key:$val";
	    }
	    push @or, ["unspecified", "X"];
	}

	for my $or (@or) {
	    my($out_file, $cat, %args) = @$or;

	    my $name = $name;
	    my @nodes = @nodes;
	    if ($args{reversed}) {
		@nodes = reverse @nodes;
	    }
	    if ($args{name}) {
		$name = $args{name};
	    }
	    push @{$out{$out_file}}, [$name, [map { $node2ll{$_} } @nodes], $cat];
	}
    }
}

if (!mkdir $o) {
    die "Cannot create output directory <$o>: $!" if !$f;
}
chdir $o
    or die "Cannot chdir to $o: $!";
while(my($filename,$data) = each %out) {
    print STDERR "$filename... ";
    open my $ofh, ">:encoding($encoding)", "$filename~"
	or die "Can't write to file <$filename~> in directory <$o>: $!";
    print $ofh <<EOF;
#: #: -*- coding: $encoding -*-
EOF
    if ($encoding ne 'iso-8859-1') {
	print $ofh <<EOF;
#:encoding: $encoding
EOF
    }
    if (!$map) {
	print $ofh <<EOF;
#:map: polar
EOF
    } elsif ($map ne 'bbbike') {
	print $ofh <<EOF;
#:map: $map
EOF
    }
my $isodate = epoch2isodate;
print $ofh <<EOF;
#:date: $isodate
#:
# Converted from openstreetmap data using $0
# DO NOT EDIT THIS FILE! Edit the original openstreetmap data!
#
EOF
    for my $rec (@$data) {
	my($name, $coords, $cat) = @$rec;
	print $ofh "$name\t$cat " . join(" ", @$coords) . "\n";
    }
    close $ofh
	or die "Error while closing: $!";
    rename "$filename~", $filename
	or die "Can't rename $filename~ to $filename: $!";
    print STDERR "\n";
}

# required files:
for my $file (qw(gesperrt wasserumland wasserumland2 hoehe
		 orte orte2 qualitaet_l handicap_l
		 berlin deutschland orte_city)) {
    touch $file;
}
for (qw(cyclepath misc path route tram kfzverkehr scenic)) {
    touch "comments_$_";
}
if (!-d "temp_blockings") {
    mkdir "temp_blockings";
}
touch "temp_blockings/bbbike-temp-blockings.pl";

if (%unhandled) {
    print "Unhandled categories:\n";
    local $Data::Dumper::Sortkeys = 1;
    print Dumper (\%unhandled);
}

sub touch ($) {
    my $file = shift;
    sysopen my $fh, $file, O_WRONLY|O_CREAT|O_NONBLOCK|O_NOCTTY
	or die "Can't create $file: $!";
    close $fh
	or die "Can't close $file: $!";
}

# REPO BEGIN
# REPO NAME epoch2isodate /home/e/eserte/work/srezic-repository 
# REPO MD5 a728acec57691739e2273d6c4836ecc1

=head2 epoch2isodate($time)

=for category Date

Return time as ISO 8601 date from given time in seconds since UNIX epoch.

=cut

sub epoch2isodate (;$) {
    my $time = shift || time;
    my @l = localtime $time;
    sprintf("%04d%02d%02d%02d%02d%02d",
	    $l[5]+1900, $l[4]+1, $l[3],
	    $l[2],      $l[1],   $l[0]);
}
# REPO END

__END__

=pod

Hint:

To get the bbox of a bbd file, use:

    perl -l -MKarte::Standard -MKarte::Polar -MStrassen -e '$s=Strassen->new("data/strassen"); ($x1,$y1,$x2,$y2) = $s->bbox; print join(",", $Karte::Polar::obj->standard2map($x1,$y1),$Karte::Polar::obj->standard2map($x2,$y2))'

=cut

