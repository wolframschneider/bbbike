#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: insert_points,v 1.51 2005/05/16 21:12:08 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 1998,2003,2004 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: eserte@users.sourceforge.net
# WWW:  http://bbbike.sourceforge.net/
#

# insert_points:
# Als Eingabe werden drei Punkte erwartet. Der mittlere Punkt ist neu
# und wird zwischen den ersten und dritten Punkt eingefügt. Bei Radwegen
# _gab_ es eine Sonderbehandlung.
# Da diese Funktion gefährlich ist, wird zuerst angezeigt, welche
# Dateien geändert werden.

# -operation insertmulti:
# Like -operation insert, but allow more than one point to be inserted.

# change_points:
# Als Eingabe werden zwei Punkte erwartet. Der erste Punkt wird in allen
# Dateien in den zweiten Punkt umgewandelt.

# change_line:
# Als Eingabe werden drei Punkte erwartet. Die ersten beiden Punkte
# geben die Strecke an, von der der zweite Punkt zum dritten Punkt
# der Eingabe verschoben werden soll. Also:
# Strecke A --- B; B wird nach C verschoben
# grep_point:
# show files containing the point

# XXX deletemulti implementieren XXX was soll das machen? Mehrere Punkte löschen?

# XXX deletelines implementieren: Loeschen von Streckenzuegen

# Mit -tk wird das Programm mit Tk-Interface aufgerufen. Dann werden die
# Argumente in der X11-Selection erwartet (Für Win32: Clipboard).

package BBBikeModify;

# Types
# 0: normal (Strassen.pm)
# 1: (früher) radwege
# 2: ampelschaltung.txt
# 3: comments
# 4: new radwege (like T_NORMAL, but insert to multiple lines)
use constant T_NORMAL => 0;
use constant T_OLD_RADWEGE => 1; # XXX not supported anymore
use constant T_AMPELSCHALTUNG => 2; # ampelschaltung only, ampeln is T_NORMAL
use constant T_COMMENTS => 3; # XXX never implemented
use constant T_RADWEGE => 4;
use constant T_TEMPBLOCK => 5;
use constant T_TEMPBLOCKMAIN => 6;
use constant T_VORFAHRT => 7;
use constant T_MAX => 7;

use constant RET_ERROR    => 0;
use constant RET_NOMOD    => 1;
use constant RET_MODIFIED => 2;

use strict;
use Getopt::Long;

use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
use BBBikeUtil;
use File::Basename;
use Strassen::Dataset;
use Strassen::Core;
use List::Util qw(first);
use File::Copy qw(cp);

use vars qw($datadir);

my $use_tk = 0;
my $report;
my $bbbikerootdir = "..";
my $tempblockingdir;
my $verbose = 0;
my $current_coordsys = '';
my $n;
my @custom_check_files;
my @add_custom_check_files;
my $custom_file_list;
my $add_custom_file_list;
my @add_check_files_noorig;
my %noorig_files;
my $useint; # XXX never used?
my $orig = 1;
my $logfile;
my $ask = 1;
my @special_post_handling_files;

my $operation;

sub process {
    my(@argv) = @_;

    local @ARGV = @argv;

    @custom_check_files = (); # reset
    @add_custom_check_files = (); # reset
    if (!GetOptions('tk!'        => \$use_tk,
		    'bbbikerootdir=s' => \$bbbikerootdir,
		    'datadir=s'  => \$datadir,
		    'logfile=s'  => \$logfile,
		    'tempblockingdir=s' => \$tempblockingdir,
		    'v!'         => \$verbose,
		    'coordsys=s' => \$current_coordsys,
		    'n'          => \$n,
		    'operation=s' => \$operation,
		    'file=s@'    => \@custom_check_files,
		    'addfile=s@' => \@add_custom_check_files,
		    'fl|filelist=s' => \$custom_file_list,
		    'addfl|addfilelist=s' => \$add_custom_file_list,
		    'useint!'    => \$useint,
		    'orig!'      => \$orig,
		    "report!"    => \$report,
		    "ask!"       => \$ask,
		   )) {
	die "Usage!";
    }

    $datadir = "$bbbikerootdir/data" if !defined $datadir;
    $tempblockingdir = "$bbbikerootdir/data/temp_blockings" if !defined $tempblockingdir; # XXX was misc

    for my $def ([$custom_file_list, \@custom_check_files],
		 [$add_custom_file_list, \@add_custom_check_files],
		) {
	my($file_list, $check_files) = @$def;
	if ($file_list) {
	    open(F, $file_list) or die "Can't open $file_list: $!";
	    while(<F>) {
		chomp;
		my $f = $_;
		if (!-r $f) {
		    if (-r "$datadir/$f") {
			$f = "$datadir/$f";
		    } else {
			warn "Cannot handle $f, skipping...\n";
			next;
		    }
		}
		push @$check_files, $f;
	    }
	    close F;
	}
    }

    if ($current_coordsys eq '') {
	@add_check_files_noorig = glob("$tempblockingdir/*.bbd");
    } else {
	@add_check_files_noorig = ();
    }

    if (@add_custom_check_files) {
	push @add_check_files_noorig, @add_custom_check_files;
    }

    warn "Custom check files are @custom_check_files\n" if $verbose and @custom_check_files;
    warn "Additional files to check are @add_check_files_noorig\n" if $verbose and @add_check_files_noorig;

    my($from, @middle, $to, $new_to);
    my $top;
    my $extra;
    my @coords;
    if ($use_tk) {
	require Tk;
	require Tk::ErrorDialog;
	require Tk::Dialog;
	$top = MainWindow->new;
	$top->withdraw;
	my $sel_str = ($^O eq 'MSWin32'
		       ? do { require Tk::Clipboard;
			      $top->Tk::Clipboard::clipboardGet;
			  }
		       : $top->SelectionGet);
	$sel_str =~ s/^\s+//; # my clipboard content is something faulty
	@coords = map { s/\.\d+//g; $_ } split(/\s+/, $sel_str);
    } else {
	@coords = @ARGV;
    }

    if ($operation eq 'insert') {
	($from, $middle[0], $to, $extra) = @coords;
    } elsif ($operation eq 'insertmulti') {
	$from = $coords[0];
	$to = $coords[-1];
	@middle = @coords[1 .. $#coords-1];
    } elsif ($operation eq 'changeline') {
	($from, $to, $new_to, $extra) = @coords;
    } elsif ($operation eq 'change') {
	($from, $to, $extra) = @coords;
    } elsif ($operation =~ /^(grep|delete)$/) {
	($from, $extra) = @coords;
    } elsif ($operation eq 'deletemulti') {
	$from = undef;
	$to = undef;
	@middle = @coords;
    }

    my @cmd_args = ($operation, @coords);
    {
	local $^W = undef;
	warn "from=<$from> middle=<@middle> to=<$to> new_to=<$new_to>\n" if $verbose;
    }

    if (defined $extra) {
	if ($use_tk) {
	    $top->Dialog(-title => $0,
			 -text => 'Zu viele Punkte markiert!',
			 -bitmap => 'error',
			 -buttons => ['OK'])->Show;
	    $top->destroy;
	}
	warn "Too many points ($extra)";
	return RET_ERROR;
    }

    if ($operation eq 'change' && $from eq $to) {
	if ($use_tk) {
	    $top->Dialog(-title => $0,
			 -text => 'Gleicher Punkt, keine Aktion notwendig!',
			 -bitmap => 'info',
			 -buttons => ['OK'])->Show;
	    $top->destroy;
	}
	warn "Same point $from eq $to";
	return RET_NOMOD;
    }

    my $coord_rx = qr/\d+,.*\d+$/;

    if (!defined $from or $from   !~ $coord_rx
	or
	($operation eq 'insert' and (!defined $middle[0] or $middle[0] !~ $coord_rx))
	or
	($operation eq 'insertmulti' and (!@middle or grep { !/$coord_rx/ } @middle))
	or
	($operation eq 'deletemulti' and (!@middle or grep { !/$coord_rx/ } @middle))
	or
	($operation eq 'changeline' and (!defined $new_to or $new_to !~ $coord_rx))
	or
	((!defined $to or $to     !~ $coord_rx) && $operation !~ /^(delete|grep)$/)
       ) {
	if ($use_tk) {
	    my $var_text = ($operation =~ /^(insert|changeline)$/
			    ? "müssen genau drei Punkte"
			    : ($operation eq 'grep'
			       ? "muss genau ein Punkt"
			       : ($operation eq 'insertmulti'
				  ? "mindestens drei Punkte"
				  : ($operation eq 'deletemulti'
				     ? "mindestens ein Punkt"
				     : "müssen genau zwei Punkte"
				    )
				 )
			      )
			   );
	    $top->Dialog(-title => $0,
			 -text => 'In der Auswahl ' . $var_text . ' sein!',
			 -bitmap => 'error',
			 -buttons => ['OK'])->Show;
	    warn "Found operation=$operation from=$from middle=@middle to=$to";
	    $top->destroy;
	    return RET_ERROR;
	} else {
	    if ($operation eq 'insert') {
		die "Usage: $0 from middle to";
	    } elsif ($operation eq 'changeline') {
		die "Usage: $0 from to newto";
	    } elsif ($operation eq 'change') {
		die "Usage: $0 from to";
	    } elsif ($operation =~ /^(grep|delete)$/) {
		die "Usage: $0 point";
	    }
	}
    }

    my @check_files;
    my %file2base;
    my @comments_part_files = map { "comments_$_" } @Strassen::Dataset::comments_types;

    my %ignore_files;
    if (!$orig) {
	%ignore_files = map{("$_-orig"=>1)} @comments_part_files;
	$ignore_files{"radwege-orig"} = 1;
    }

    # These are listed in BASE, but should not be handled...
    $ignore_files{"label-orig"} = 1;
    $ignore_files{"relation_gps-orig"} = 1;

    if (!@custom_check_files) {
	chdir $datadir or die "chdir to $datadir failed: $!";

	if ($operation =~ /^(insert|insertmulti|changeline|change|grep|delete|deletemulti)$/) {
	    # folgende Dateien werden bei insert_points überprüft:
	    # normales Format
	    # XXX gesperrt/gesperrt_car: Die Kategorie 3 müsste
	    # eigentlich gesondert betrachtet werden (wie die Drei-Punkte-Form
	    # von comments). Aber es sollte so auch funktionieren.

	    # "potsdam" ist nicht dabei --- wahrscheinlich nicht notwendig
	    # "plz" ist auch nicht dabei --- hoffentlich schon jetzt gut genug
	    @{$check_files[T_NORMAL]} =
		qw(gesperrt gesperrt_u gesperrt_s gesperrt_r gesperrt_car
		   landstrassen landstrassen2
		   qualitaet_l qualitaet_s
		   handicap_l handicap_s
		   strassen plaetze faehren
		   rbahn
		   sbahn sbahnhof
		   ubahn ubahnhof
		   nolighting
		   flaechen wasserstrassen wasserumland
		   wasserumland2 ampeln hoehe
		   housenumbers green brunnels
		   deutschland
		   fragezeichen
		   exits
		   orte orte2
		   sehenswuerdigkeit
		  );
	    # relation_gps herausgenommen (CVS 2004-07-26, RCS ...)
	    # XXX gehört housenumbers hier rein???

	    # Format von radwege
	    #@{$check_files[T_OLD_RADWEGE]} = qw(radwege);

	    # Besonderer Code für die Die Drei-Punkte-Form von comments bei
	    # insert_points.
	    # XXX ist für vorfahrt implementiert, für andere auch notwendig?
	    # XXX for now use the normal insert ... the additional points have to
	    # be put out manually (but this is easier than do nothing)
	    push @{$check_files[T_NORMAL]}, @comments_part_files;

	    @{$check_files[T_VORFAHRT]} = qw(vorfahrt);

	    @{$check_files[T_RADWEGE]} =
		($orig ? qw(radwege) : qw(radwege_exact));

# 	    if (!$orig) {
# 		my $temp_blockings_dir = "$FindBin::RealBin/../data/temp_blockings";
# 		if (-d $temp_blockings_dir) {
# 		    push @{$check_files[T_NORMAL]},
# 			glob("$temp_blockings_dir/*.bbd");
# 		}
# 	    }

	    @{$check_files[T_TEMPBLOCK]} =
		@add_check_files_noorig if @add_check_files_noorig;

	    for my $orig_src ("$tempblockingdir/bbbike-temp-blockings.pl",
			      "$tempblockingdir/old-bbbike-temp-blockings.pl",
			     ) {
		my $f = "/tmp/" . basename($orig_src, qr{\.pl$}) . ".bbd";
		if (-r $orig_src) {
		    if (!-e $f || -M $orig_src < -M $f) {
			use vars qw(@temp_blocking);
			@temp_blocking = ();
			do $orig_src;
			my $data = "";
			for (@temp_blocking) {
			    $data .= $_->{data} if $_->{data};
			}
			if ($data ne "") {
			    open TEMP, ">$f"
				or die "Can't write to $f: $!";
			    print TEMP $data;
			    close TEMP;
			    push @{$check_files[T_TEMPBLOCKMAIN]}, $f;
			}
		    } else {
			push @{$check_files[T_TEMPBLOCKMAIN]}, $f;
		    }
		    cp $f, "$f~";
		    push @special_post_handling_files, {Original        => $orig_src,
							BBDFile         => $f,
							BBDFileOriginal => "$f~",
						       };
		}
	    }

	}

	open(BASE, "BASE") or die "Can't open BASE: $!";
	while(<BASE>) {
	    chomp;
	    my($file, $base) = split(/\s+/, $_);
	    $file2base{$file} = $base;
	}
	close BASE;

	# user defined files
	%noorig_files = ();

	if ($operation =~ /^(change|grep)$/) {
#XXX	    @{$check_files[T_NORMAL]} = grep { !$ignore_files{$_} } keys %file2base;
# 	    if (!$orig) {
# 		$file2base{'radwege_exact-orig'} = $file2base{'radwege-orig'};
# 		delete $file2base{'radwege-orig'};
# 		push @{$check_files[T_NORMAL]}, "radwege_exact-orig";
# 	    }
	    $file2base{'../misc/ampelschaltung.txt'} = 'B'; # XXX aus ../misc/BASE holen
	    $file2base{'ampelschaltung'} = 'B'; # XXX aus ../misc/BASE holen
	    @{$check_files[T_AMPELSCHALTUNG]} = ('../misc/ampelschaltung.txt', 'ampelschaltung');
#	    $noorig_files{'../misc/ampelschaltung-orig.txt'} = 1;
	}

	{
	    my @f = glob("$ENV{HOME}/.bbbike/data/*.bbd");
	    push @{$check_files[T_NORMAL]}, @f;
	    $noorig_files{$_} = 1 for (@f);
	}

	for (@add_check_files_noorig) {
	    $noorig_files{$_} = 1;
	}

    } else { # custom_check_files
	@{$check_files[T_NORMAL]} = @custom_check_files;
	$noorig_files{$_} = 1 for (@custom_check_files);
	for (T_NORMAL+1 .. T_MAX) {
	    @{$check_files[$_]} = ();
	}
    }

    # uhm... how hackish :-(
    if ($orig) {
#	if ($operation ne 'change') {
	    for my $cf_i (0 .. $#check_files) {
		next if $cf_i == T_TEMPBLOCK || $cf_i == T_TEMPBLOCKMAIN;
		my $cf = $check_files[$cf_i];
		for my $f (@$cf) {
		    next if $noorig_files{$f};
		    if ($f !~ s/\.txt/-orig.txt/) {
			$f .= "-orig";
		    }
		}
	    }
#	}
    } else {
#	if ($operation eq 'change') {
	    for my $cf_i (0 .. $#check_files) {
		next if $cf_i == T_TEMPBLOCK || $cf_i == T_TEMPBLOCKMAIN;
		my $cf = $check_files[$cf_i];
		for my $f (@$cf) {
		    next if $noorig_files{$f};
		    if ($f !~ s/-orig\.txt$/.txt/) {
			$f =~ s/-orig//;
		    }
		}
	    }
#	}
	my %new_file2base;
	while(my($k,$v) = each %file2base) {
	    next if $ignore_files{$k};
	    (my $new_k = $k) =~ s/-orig$//;
	    $new_file2base{$new_k} = "H"; # everything in "standard" coordinates
	}
	%file2base = %new_file2base;
    }

    my @change_files;
    my %change_names;
    my %change_special_flags;

    my @warnings;

    for(my $type = 0; $type <= $#check_files; $type++) {
	foreach my $file (@{$check_files[$type]}) {
	    my $map_char_rx = ($current_coordsys ne ''
			       ? "($current_coordsys)?"
			       : '(B)?'
			      ); # XXX right? ''; # XXX
	    my $map_from = "$map_char_rx$from";
	    my $map_to   = "$map_char_rx$to" if defined $to;
	    open(F, $file) or do {
		my $msg = "Can't open file <$file>";
		warn "$msg.\n";
		push @warnings, "$msg.\n";
		next;
	    };
	    warn "Read $file...\n" if $verbose;
	    my(@data) = <F>;
	    close F;

	    if ($operation =~ /^(insert|insertmulti|changeline)$/) {
		if ($type == T_NORMAL || $type == T_TEMPBLOCK || $type == T_TEMPBLOCKMAIN || $type == T_RADWEGE || $type == T_VORFAHRT) {
		    if ($verbose) {
			warn "Check for ($map_from $map_to|$map_to $map_from)\n";
		    }
		    my @changed = grep(/(?:(?<=\s)|^)(?:$map_from $map_to|$map_to $map_from)\b/, @data);
		    if (@changed) {
			push @{$change_files[$type]}, $file;
			push @{$change_names{$file}},
			    map { /^([^\t]+)/ ? $1 : () } @changed;
			if ($operation eq 'changeline' && first { /(?:\t\S+\s(?:$map_from $map_to|$map_to $map_from)\b|\b(?:$map_from $map_to|$map_to $map_from)$)/ } @data) {
			    push @{$change_special_flags{$file}}, "endpoint";
			}
		    }
		} elsif ($type == T_OLD_RADWEGE) {
		    # XXX not supported anymore
		    if ($verbose) {
			warn "Check for ($map_from\t$map_to|$map_to\t$map_from)\n";
		    }
		    # XXX not necesary anymore???: my @changed = ...
		    if (grep(/^($map_from\t$map_to|$map_to\t$map_from)\b/, @data)) {
			if ($operation eq 'changeline') {
			    my $msg = 'changeline noch nicht für Typ 1 (radwege) implementiert!';
			    if ($use_tk) {
				$top->messageBox(-title => $0,
						 -text => $msg,
						 -icon => 'error');
				$top->destroy;
			    }
			    die $msg;
			}
			push @{$change_files[$type]}, $file;
		    }
		} elsif ($type == T_COMMENTS) {
		    # XXX implement!
		    #my $rx = "P\d.*
		    #if ($verbose) {
		    #warn "Check for ($map_from\t$map_to|$map_to\t$map_from)\n";
		    #}
		}
	    } elsif ($operation =~ /^(change|grep|delete)$/) {
		my $map_rx = ($current_coordsys eq '' ? 'B?' : $current_coordsys.'?');
		# XXX verbose fehlt
		if ($type == T_NORMAL || $type == T_TEMPBLOCK || $type == T_TEMPBLOCKMAIN || $type == T_COMMENTS || $type == T_OLD_RADWEGE || $type == T_RADWEGE || $type == T_VORFAHRT) {
		    if (grep(/(?:(?<=\s)|^)$map_rx$map_from(\b|$)/, @data)) {
			push @{$change_files[$type]}, $file;
			if (first { /\t\S+\s$map_rx$map_from$/ } @data) {
			    push @{$change_special_flags{$file}}, "single-point";
			} elsif (first { /(?:\t\S+\s$map_rx$map_from\b|\b$map_rx$map_from$)/ } @data) {
			    push @{$change_special_flags{$file}}, "endpoint";
			}
		    }
		} elsif ($type == T_AMPELSCHALTUNG) {
		    #warn "XXX NYI $operation for $file";
                    if (grep(/^$map_rx$map_from\b/, @data)) {
			push @{$change_files[$type]}, $file;
		    }
		}
	    }
	}
    }

    if (@warnings) {
	if ($use_tk) {
	    $top->messageBox(-message => join "", @warnings);
	}
    }

    my $dialog_text = "Keine Umwandlung nötig.";
    if ($operation eq 'grep') {
	$dialog_text = "Punkt nicht gefunden.";
    }
    if (!_interpolate(@change_files)) {
	if ($use_tk) {
	    $top->Dialog(-title => $0,
			 -text  => $dialog_text,
			 -bitmap => 'info',
			 -buttons => ['OK'])->Show;
	    $top->destroy;
	} else {
	    print STDERR "$dialog_text.\n";
	}
	return RET_NOMOD;
    }

    if ($report) {
	print join("\n", _interpolate(@change_files)), "\n";
	return RET_NOMOD;
    }

    $dialog_text = "Betroffene Dateien:\n";
    for my $changed_file (_interpolate(@change_files)) {
	$dialog_text .= "\t" . $changed_file;
	if (exists $change_names{$changed_file} &&
		@{ $change_names{$changed_file} }) {
	    $dialog_text .= " (" . join(", ", @{ $change_names{$changed_file} }) . ")";
	}
	if (exists $change_special_flags{$changed_file} &&
		@{ $change_special_flags{$changed_file} }) {
	    $dialog_text .= " (" . join(", ", @{ $change_special_flags{$changed_file} }) . ")";
	}
	$dialog_text .= "\n";
    }
    $dialog_text .= "\nSoll die Umwandlung ($operation) vorgenommen werden?";
    if ($n) {
	$dialog_text .= " (no-clobber mode)";
    }
    my $ans;
    if (!$ask) {
	print STDERR "Doing $operation...\n" if $verbose;
	$ans = 'j';
    } elsif ($use_tk) {
	require Tk::DialogBox;
	my $dia = $top->DialogBox
	    (-title => $0,
	     -buttons => ($operation eq 'grep' ? ['Ok'] : ['Ja', 'Nein']),
	    );
	$dia->add('Label', -text => {insert => 'Punkt einfügen',
				     insertmulti => 'Mehrere Punkte einfügen',
				     changeline => 'Strecke verschieben',
				     change => 'Punkt verschieben',
				     grep => 'Punkt gefunden',
				     delete => 'Punkt löschen',
				    }->{$operation}
		 )->pack;
	$dia->add('Label', -text => 'Betroffene Dateien:')->pack;
	my @check;
	my @orig_change_files;
	for (my $type = 0; $type <= $#change_files; $type++) {
	    next if !defined $change_files[$type];
	    @{$orig_change_files[$type]} = @{$change_files[$type]};
	    $change_files[$type] = [];
	    foreach my $file (@{$orig_change_files[$type]}) {
		my $names = "";
		if (exists $change_names{$file} &&
		    @{ $change_names{$file} }) {
		    $names = join(", ", @{ $change_names{$file} });
		    $names = substr($names, 0, 40)."..." if length $names > 40;
		    $names = " ($names)";
		}
		if (exists $change_special_flags{$file} &&
			@{ $change_special_flags{$file} }) {
		    $names .= " (" . join(", ", @{ $change_special_flags{$file} }) . ")";
		}
		$check[$type]->{$file} = 1;
		$dia->add('Checkbutton',
			  -text => "$file$names",
			  -variable => \$check[$type]->{$file})->pack(-anchor => "w");
	    }
	}
	unless ($operation eq 'grep') {
	    $dia->add('Label',
		      -text => "Soll die Umwandlung vorgenommen werden?")->pack;
	}

	$ans = $dia->Show;
	for (my $type = 0; $type <= $#check_files; $type++) {
	    foreach my $file (@{$orig_change_files[$type]}) {
		push @{$change_files[$type]}, $file
		    if $check[$type]->{$file};
	    }
	}
	if ($ans =~ /ja/i and _interpolate(@change_files)) {
	    $ans = 'j';
	} else {
	    $ans = 'n';
	}
    } else {
	print STDERR "$dialog_text (j/N) ";
	$ans = <STDIN>;
    }

    if ($operation eq 'grep') {
	return RET_NOMOD;
    }

    if ($ans =~ /^j/) {
	# Do the operation!
	my @changed_files;
	for(my $type = 0; $type <= $#check_files; $type++) {
	    foreach my $file (@{$change_files[$type]}) {
		push @changed_files, $file;
		# XXX not used, del?
		my $map_char = (($file2base{$file}||'') eq $current_coordsys ? '' : $current_coordsys);
		my $map_char_rx = ($operation =~ /^(insert|insertmulti|changeline)$/
				   ? ($current_coordsys ne ''
				      ? "(?:$current_coordsys)?"
				      : '(?:B)?'
				     )
				   : ($current_coordsys ne ''
				      ? "($current_coordsys)?"
				      : '(B)?'
				     )
				  );
		if ($type == T_AMPELSCHALTUNG) {
		    $map_char_rx = '';
		}

		my $map_from     = "$map_char_rx$from";
		my $map_new_from;
		if ($operation eq 'change') {
		    $map_new_from = $to;
		}
		my @map_middle;
		my @rev_middle;
		if ($operation =~ /^insert(multi)?$/) {
		    @map_middle = map { "$current_coordsys$_" } @middle;
		    @rev_middle = reverse @map_middle;
		}
		$map_char_rx = "" if !defined $map_char_rx;
		my $map_to;
		$map_to = "$map_char_rx$to" if defined $to;
		my $map_new_to;
		if ($operation eq 'changeline') {
		    $map_new_to = "$new_to";
		}

		if ($operation eq 'change' and $type == T_AMPELSCHALTUNG
		    and length($map_new_from) < length($map_from)) {
		    # mit Leerzeichen auffüllen, da ich mit LHS substr arbeite
		    $map_new_from .= " " x (length($map_from)-length($map_new_from));
		}

#warn "from=$map_from, middle=@map_middle, to=$map_to, new_from=$map_new_from, new_to=$map_new_to\n";

		# auschecken, falls notwendig...
		if (!$n) {
		    my $rcsfile = "RCS/$file,v";
		    if (!-w $file && -f $rcsfile) {
			my $ok = BBBikeUtil::rcs_co($file);
			if (!$ok) {
			    die "Problems while check-out $file";
			}
		    }
		}

		if (!$n) {
		    chmod 0644, "$file~";
		    rename $file, "$file~" or die "rename $file to $file~: $!";
		    open(R, "$file~") or die "Can't open $file~: $!";
		    open(W, ">$file") or die "Can't write to $file: $!";
		} else {
		    open(R, $file) or die "Can't open $file: $!";
		    open(W, ">/tmp/insert_change_points_test") or die "Can't write to file: $!";
		}
		binmode W; # XXX check on NT
		while(<R>) {
		    if ($operation =~ /^insert(multi)?$/) {
			if ($type == T_NORMAL || $type == T_TEMPBLOCK || $type == T_TEMPBLOCKMAIN) {
			    if (/(?:(?<=\s)|^)$map_from $map_to\b/) {
				s/(?:(?<=\s)|^)($map_from) ($map_to)\b/$1 @map_middle $2/;
			    } elsif (/(?:(?<=\s)|^)$map_to $map_from\b/) {
				s/(?:(?<=\s)|^)($map_to) ($map_from)\b/$1 @rev_middle $2/;
			    }
			    print W $_;
			} elsif ($type == T_VORFAHRT) {
			TRY: {
				last if (s/(\t\S+\s+)$map_from( $map_to\b)/$1$map_middle[-1]$2/);
				last if (s/(\t\S+\s+)$map_to( $map_from\b)/$1$map_middle[0]$2/);
				last if (s/(\b$map_from )$map_to$/$1$map_middle[0]/);
				last if (s/(\b$map_to )$map_from$/$1$map_middle[-1]/);
			    }
			    print W $_;
			} elsif ($type == T_RADWEGE) {
			    if (/(?:(?<=\s)|^)$map_from $map_to\b/) {
				(my $first = $_) =~ s/(?:(?<=\s)|^)($map_from) ($map_to)\b/$1 @map_middle/;
				(my $second = $_) =~ s/(?:(?<=\s)|^)($map_from) ($map_to)\b/@map_middle $2/;
				print W "$first$second";
			    } elsif (/(?:(?<=\s)|^)$map_to $map_from\b/) {
				(my $first = $_) =~ s/(?:(?<=\s)|^)($map_to) ($map_from)\b/$1 @rev_middle/;
				(my $second = $_) =~ s/(?:(?<=\s)|^)($map_to) ($map_from)\b/@rev_middle $2/;
				print W "$first$second";
			    } else {
				print W $_;
			    }
			} elsif ($type == T_OLD_RADWEGE) {
			    # XXX not supported anymore
			    if (/^($map_from)\t($map_to)\b(.*)/) {
				print W "$1\t@map_middle$3\n";
				print W "@map_middle\t$2$3\n";
			    } elsif (/^($map_to)\t($map_from)\b(.*)/) {
				print W "$1\t@rev_middle$3\n";
				print W "@rev_middle\t$2$3\n";
			    } else {
				print W $_;
			    }
			}
		    } elsif ($operation eq 'changeline') {
			if ($type == T_NORMAL || $type == T_TEMPBLOCK || $type == T_TEMPBLOCKMAIN || $type == T_RADWEGE || $type == T_VORFAHRT) {
			    if (/(?:(?<=\s)|^)$map_from $map_to\b/) {
				s/(?:(?<=\s)|^)($map_from) $map_to\b/$1 $map_new_to/;
			    } elsif (/(?:(?<=\s)|^)$map_to $map_from\b/) {
				s/(?:(?<=\s)|^)$map_to ($map_from)\b/$map_new_to $1/;
			    }
			    print W $_;
			} elsif ($type == T_OLD_RADWEGE) {
			    die "NYI!!!";
			}
		    } elsif ($operation eq 'delete') {
			if ($type == T_NORMAL || $type == T_TEMPBLOCK || $type == T_TEMPBLOCKMAIN || $type == T_RADWEGE || $type == T_VORFAHRT) {
			    s/\s*$map_from\b//g;
			    if (/^[^\t]\t\S+$/) {
				# remove this record
			    } else {
				print W $_;
			    }
			} else {
			    die "NYI!";
			}
		    } elsif ($operation eq 'change') {
			if ($type == T_NORMAL || $type == T_TEMPBLOCK || $type == T_TEMPBLOCKMAIN || $type == T_RADWEGE || $type == T_VORFAHRT) {
			    s/(?:(?<=\s)|^)$map_from\b/$1$map_new_from/g;
			    print W $_;
			} elsif ($type == T_AMPELSCHALTUNG) {
			    if (/^$map_from\b/) {
				substr($_, 0, length($map_new_from)) = $map_new_from;
			    }
			    print W $_;
			}
		    }
		}
		close W;
		close R;
		if (!$n) {
		    chmod 0644, $file;
		}
	    }
	}
	if (!$n) {
	    do_log(@cmd_args, @changed_files);
	}

	{
	    my @warn_user;
	    for my $def (@special_post_handling_files) {
		my $f_new  = $def->{BBDFile};
		my $f_orig = $def->{BBDFileOriginal};
		require File::Compare;
		if (File::Compare::compare($f_new, $f_orig) != 0) {
		    push @warn_user, $def;
		}
	    }
	    if (@warn_user) {
		my $msg = "Bitte die folgenden Änderungen manuell durchführen:\n";
		for my $def (@warn_user) {
		    $msg .= "zwischen $def->{BBDFileOriginal} und $def->{BBDFile} -> $def->{Original}\n";
		}
		if ($use_tk) {
		    $top->messageBox(-title => "Warning",
				     -message => $msg);
		}
		warn $msg, "\n";
	    }
	}
    }
    return RET_MODIFIED;
}

sub _interpolate {
    my(@a) = @_;
    my @res;
    foreach (@a) {
	push @res, @$_ if ref $_ eq 'ARRAY';
    }
    @res;
}

sub do_log {
    my(@args) = @_;
    my $logfile = $logfile;
    $logfile = "$datadir/datachange.log" if !$logfile;
    warn "Log to $logfile...\n" if $verbose;

    # EDIT line
    my $last_date_line;
    my @l = localtime;
    my $this_date_line = sprintf "%04d-%02d-%02d", $l[5]+1900, $l[4]+1, $l[3];
    my $user = eval { (getpwuid($<))[0] } || $ENV{USER};
    if ($user) {
	$this_date_line .= " by=$user";
    }
    if (eval { require Sys::Hostname }) {
	$this_date_line .= " on=" . Sys::Hostname::hostname();
    }

    # Do we need a current EDIT line?
    my $date_line_needed = 1;
    if (eval { require File::ReadBackwards; 1 }) {
	if (tie *BW, "File::ReadBackwards", $logfile) {
	    while(<BW>) {
		chomp;
		if (/^\#\s+EDIT:\s*(.*)/) {
		    if ($1 eq $this_date_line) {
			$date_line_needed = 0;
			last;
		    }
		}
	    }
	    close BW;
	}
    } else {
	warn "Installation of File::ReadBackwards module advised!\n";
    }

    if (open(LOG, ">>$logfile")) {
	if ($date_line_needed) {
	    print LOG "# EDIT: $this_date_line\n";
	}
	print LOG "@args\n";
	close LOG;
    } else {
	my $msg = "Can't write to $logfile: $!";
	common_message($msg, "warn");
    }
}

sub common_message {
    my($msg, $type) = @_;
    warn $msg;
    if (defined &main::status_message) {
	main::status_message($msg, $type);
    } elsif ($use_tk) {
	require Tk;
	my $top = MainWindow->new;
	$top->withdraw;
	$top->messageBox(-message => $msg);
	$top->destroy;
    }
}

return 1 if caller;

$operation = ($0 =~ /       insert_points$ /x ? 'insert'      :
	      $0 =~ / insert_multi_points$ /x ? 'insertmulti' :
	      $0 =~ /         change_line$ /x ? 'changeline'  :
	      $0 =~ /          grep_point$ /x ? 'grep'        :
	      $0 =~ /        delete_point$ /x ? 'delete'      :
	      $0 =~ /        delete_multi$ /x ? 'deletemulti' :
	      $0 =~ /        deline_lines$ /x = 'deletelines' :
	      					'change'
	     );

my $ret = process(@ARGV);
exit ($ret == RET_ERROR ? 1 : 0);

__END__
