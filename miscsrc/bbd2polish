#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: bbd2polish,v 1.4 2005/07/04 22:17:21 eserte Exp eserte $
# Author: Slaven Rezic
#
# Copyright (C) 2005 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Convert from a set of bbd files into polish format for cgpsmapper

# See http://gps.chrisb.org/en/download.htm

# XXX make configurable everything

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);
use Strassen::Core;
use Strassen::Strasse;
use Karte::Polar;
use Karte::Standard;

my $id = 10000099; # XXX how to choose img id? is there a manual? or
                   # just increment?
my $name = "BBBike map";
my $codepage; # eg. 1252
my $out = "";
$out .= <<EOF;
[IMG ID]
ID=$id
Name=$name
EOF
if (!$codepage) {
    $out .= <<EOF;
LBLcoding=6
EOF
} else {
    $out .= <<EOF;
LBLcoding=9
Codepage=$codepage
EOF
}
$out .= <<EOF;
PreProcess=F
;TreSize=800
TreSize=3000
Elevation=m
Levels=4
Level0=22
Level1=21
Level2=19
Level3=15
Zoom0=1
Zoom1=2
Zoom2=3
Zoom3=4
[END-IMG ID]

[DICTIONARY]
;Since the default is to import all elements, it is not neccesary to define filters for layer 0
;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

Level1RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;           0              1               2               3               4               5               6 
;           123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0

;Level0RGN20=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN20=111111111100000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN20=111111110000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level3RGN20=111111100000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;Level0RGN40=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN40=111110001110010000011100111111101101101111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level2RGN40=111110001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

;Level0RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
[END-DICTIONARY]

;[DICTIONARY]
;;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
;[END-DICTIONARY]

EOF

my $s = Strassen->new("strassen");
$s->init;
while(1) {
    my $r = $s->next;
    my @c = @{ $r->[Strassen::COORDS] };
    last if !@c;

    @c = map {
	my($x,$y) = split /,/, $_;
	my($long, $lat) = $Karte::Polar::obj->trim_accuracy
	    ($Karte::Polar::obj->standard2map($x,$y)
	    );
	[$lat,$long];
    } @c;

    my $name = convert_strname($r->[Strassen::NAME]);
    my $cat = $r->[Strassen::CAT];

    if (@c == 1) {
	my $type = cat2type($cat, "strassenXXX", "poi");
	$out .= <<EOF;
[POI]
Type=$type
Label=$name
Origin0=($c[0]->[0],$c[0]->[1])
Origin1=($c[0]->[0],$c[0]->[1])
[END-POI]

EOF
    } else {
	my $type = cat2type($cat, "strassenXXX", "polyline");
	$out .= <<EOF;
[POLYLINE]
Type=$type
Label=$name
DirIndicator=0
EOF
	my $data0 = join(",", map {
	    "(" . $_->[0] . "," . $_->[1]  . ")"
	} @c) . "\n";
	$out .= "Data0=" . $data0;
	if ($cat ne 'NN') {
	    $out .= "Data1=" . $data0;
	    if ($cat ne 'N') {
		$out .= "Data2=" . $data0;
		if (0 && $cat ne 'H') { # XXX no level3 for now
		    $out .= "Data3=" . $data0;
		}
	    }
	}
	$out .= <<EOF;
[END-POLYLINE]

EOF
    }
}

print $out;

sub cat2type {
    my($cat, $file, $rgn_type) = @_;
    my $cat_attrib;
    if ($cat =~ /^(.*?)::(.*)$/) {
	$cat = $1;
	$cat_attrib = $2;
    }
    # Cat;Cat is not handled yet, see DirIndicator above? XXX
    return 2 if $cat eq 'B' || $cat eq 'HH'; # Principal HWY-thick
    return 3 if $cat eq 'H'; # Principal HWY - medium
    return 4 if $cat eq 'N'; # Arterial Road - medium
    return 6 if $cat eq 'NN'; # Road - thin
    return 20 if $cat =~ /^[RUB][ABC]?$/; # Railroad
    if ($cat eq 'Pl') {
	if ($rgn_type eq 'poi') {
	    # Namedpoint (small point)
	    return 2816;
	} else {
	    return 4;
	}
    }
    warn "Unhandled cat <$cat>\n";
    return 22; # Trail
}

sub convert_strname {
    my $strname = shift;
    $strname = Strasse::strip_bezirk($strname);
    $strname =~ s{[()]}{}g;
    encode_string($strname);
}

sub encode_string {
    my($string) = @_;
    if ($codepage) {
	if ($codepage eq '1252') {
	    $string;
	} else {
	    die "Cannot handle codepage $codepage";
	}
    } else {
	require Text::Unidecode;
	Text::Unidecode::unidecode($string);
    }
}

__END__
