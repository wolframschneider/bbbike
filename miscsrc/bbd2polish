#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: bbd2polish,v 1.10 2005/07/05 01:33:14 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2005 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Convert from a set of bbd files into polish format for cgpsmapper

# See http://gps.chrisb.org/en/download.htm

# XXX make configurable everything

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);
use Strassen::Core;
use Strassen::Strasse;
use Karte::Polar;
use Karte::Standard;

my $id = 10000099; # XXX how to choose img id? is there a manual? or
                   # just increment?
my $name = "BBBike map";
my $codepage; # eg. 1252
my $levels = 4;
my $out = "";
$out .= <<EOF;
[IMG ID]
ID=$id
Name=$name
EOF
if (!$codepage) {
    $out .= <<EOF;
LBLcoding=6
EOF
} else {
    $out .= <<EOF;
LBLcoding=9
Codepage=$codepage
EOF
}
$out .= <<EOF;
PreProcess=F
;TreSize=800
TreSize=3000
Elevation=m
Levels=@{[ $levels + 1 ]}
; with NN
Level0=24
; with N
Level1=23
; with H
Level2=21
; with HH/B
Level3=18
; empty
Level4=16
Zoom0=1
Zoom1=2
Zoom2=3
Zoom3=4
Zoom4=5
[END-IMG ID]

[DICTIONARY]
;Since the default is to import all elements, it is not neccesary to define filters for layer 0
;RGN10 = POI
;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

Level1RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;           0              1               2               3               4               5               6 
;           123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0

;RGN20 = POI with cities
;Level0RGN20=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN20=111111111100000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN20=111111110000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level3RGN20=111111100000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;RGN40 = polyline
;Level0RGN40=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN40=111110001110010000011100111111101101101111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level2RGN40=111000001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level3RGN40=110000001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

;RGN80 = polygon
;Level0RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
[END-DICTIONARY]

;[DICTIONARY]
;;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
;[END-DICTIONARY]

EOF

for my $file (qw(strassen wasserstrassen flaechen sbahn ubahn)) {
    print STDERR "$file...";
    my $s = Strassen->new($file);
    $s->init;
    while(1) {
	my $r = $s->next;
	my @c = @{ $r->[Strassen::COORDS] };
	last if !@c;

	@c = map {
	    my($x,$y) = split /,/, $_;
	    my($long, $lat) = $Karte::Polar::obj->trim_accuracy
		($Karte::Polar::obj->standard2map($x,$y)
		);
	    [$lat,$long];
	} @c;

	my $name = convert_strname($r->[Strassen::NAME]);
	my $cat = $r->[Strassen::CAT];

	if (@c == 1) {
	    my $type = cat2type($cat, $file, "poi");
	    next if !defined $type;
	    $out .= <<EOF;
[POI]
Type=$type
Label=$name
Data0=($c[0]->[0],$c[0]->[1])
EndLevel=1
[END-POI]

EOF
	} elsif ($cat =~ /^F:(.*)/) {
	    $cat = $1;
	    my $type = cat2type($cat, $file, "polygon");
	    next if !defined $type;
	    $out .= <<EOF;
[POLYGON]
Type=$type
;Label=$name
EOF
	    if ("@{$c[0]}" eq "@{$c[-1]}") {
		pop @c;
	    }
	    my $data0 = join(",", map {
		"(" . $_->[0] . "," . $_->[1]  . ")"
	    } @c) . "\n";
	    $out .= "Data0=" . $data0;
	    $out .= <<EOF;
EndLevel=$levels
[END-POLYGON]

EOF
	    
	} else {
	    my $type = cat2type($cat, $file, "polyline");
	    next if !defined $type;
	    $out .= <<EOF;
[POLYLINE]
Type=$type
Label=$name
DirIndicator=0
EOF
	    my $data0 = join(",", map {
		"(" . $_->[0] . "," . $_->[1]  . ")"
	    } @c) . "\n";
	    $out .= "Data0=" . $data0;
	    my $end_level = $levels;
	    if ($file eq 'strassen') {
		$end_level = 0;
		if ($cat ne 'NN') {
		    $end_level = 1;
		    if ($cat ne 'N') {
			$end_level = 2;
			if ($cat ne 'H') {
			    $end_level = 3;
			}
		    }
		}
	    }
	    $out .= <<EOF;
EndLevel=$end_level
[END-POLYLINE]

EOF
	}
    }
    print STDERR "\n";
}

print $out;

sub cat2type {
    my($cat, $file, $rgn_type) = @_;
    my $cat_attrib;
    if ($cat =~ /^(.*?)::(.*)$/) {
	$cat = $1;
	$cat_attrib = $2;
    }
    # Cat;Cat is not handled yet, see DirIndicator above? XXX
    return 2 if $cat eq 'B' || $cat eq 'HH'; # Principal HWY-thick
    return 3 if $cat eq 'H'; # Principal HWY - medium
    return 4 if $cat eq 'N'; # Arterial Road - medium
    return 6 if $cat eq 'NN'; # Road - thin
    return 20 if $cat =~ /^[RUS][ABC]?$/; # Railroad
    return undef if $cat =~ /^[RUS]0$/;
    if ($cat eq 'Pl') {
	if ($rgn_type eq 'poi') {
	    # Namedpoint (small point)
	    return 2816;
	} else {
	    return 4;
	}
    }
    return 0x07 if $cat eq 'Ae';
    return 0x17 if ($cat eq 'P' || $cat eq 'Pabove') && $rgn_type eq 'polygon';
    return 0x3c if $cat eq 'W' && $rgn_type eq 'polygon';
    return 0x1f if $cat =~ /^W\d?$/ && $rgn_type eq 'polyline';
    return 0x13 if $cat eq 'I' && $rgn_type eq 'polygon'; # 0x4b=background -> problems?
    warn "Unhandled cat <$cat>\n";
    return 22; # Trail
}

sub convert_strname {
    my $strname = shift;
    $strname = Strasse::strip_bezirk($strname);
    $strname =~ s{[()]}{}g;
    encode_string($strname);
}

sub encode_string {
    my($string) = @_;
    if ($codepage) {
	if ($codepage eq '1252') {
	    $string;
	} else {
	    die "Cannot handle codepage $codepage";
	}
    } else {
	require Text::Unidecode;
	Text::Unidecode::unidecode($string);
    }
}

__END__
