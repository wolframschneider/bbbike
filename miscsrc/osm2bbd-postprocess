#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: osm2bbd-postprocess,v 1.11 2009/03/01 23:38:18 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");

use vars qw($VERSION);
$VERSION = 0.10;

use Cwd            qw(realpath);
use File::Basename qw(dirname);
use File::Temp     qw(tempfile);
use Getopt::Long;

my @targets = ('wasserstrassen_lowres',
	       'largest_city_is_center',
	       'inaccessible_streets',
	       #'make_long_streets',
	      );
my %skip_target;
my %only_target;

sub usage (;$) {
    my $msg = shift;
    warn $msg, "\n" if $msg;
    die "usage: $0 " . join(" ", map {
	(my $optname = $_) =~ s{_}{-}g;
	"[-skip-$_ | -only-$_]"
    } @targets);
}

GetOptions((map {
    (my $optname = $_) =~ s{_}{-}g;
    ("skip-$optname" => \$skip_target{$_},
     "only-$optname" => \$only_target{$_},
    );
} @targets))
    or usage;

my $miscsrcdir = realpath $FindBin::RealBin;
my $bbbikedir = dirname $miscsrcdir;
my $datadir = shift or usage "Please specify data directory";
$datadir = realpath $datadir;
chdir $datadir or die "Can't chdir to $datadir: $!";

if (grep { $_ } values %only_target) {
    @targets = grep { $only_target{$_} } @targets;
}

for my $target (@targets) {
    if ($skip_target{$target}) {
	print STDERR "Skip target $target.\n";
	next;
    }
    no strict 'refs';
    my $target_sub = "target_$target";
    if (!defined &{$target_sub}) {
	die "No subroutine for $target exists";
    }
    print STDERR "Running target $target ... ";
    &{$target_sub};
    print STDERR "\n";
}

sub target_wasserstrassen_lowres {
    if (-e "wasserstrassen-lowres" && -M "wasserstrassen-lowres" <= -M "wasserstrassen") {
	print STDERR "up-to-date";
	return;
    }
    my(undef, $tmp1) = tempfile(UNLINK => 1, SUFFIX => "-wlores.bbd") or die $!;
    my(undef, $tmp2) = tempfile(UNLINK => 1, SUFFIX => "-wlores.bbd") or die $!;
    my $cmd = <<EOF;
set -e
cat wasserstrassen | $miscsrcdir/grepstrassen --catrx '^(F:W1)\$' > $tmp1
cat wasserstrassen | $miscsrcdir/grepstrassen --catrx '^(W1|W2|F:W)\$' --minarea 3 >> $tmp1
$^X $miscsrcdir/simplify_streets -tolerance 300 -algorithm 'douglas-peucker' $tmp1 > $tmp2
mv $tmp2 wasserstrassen-lowres
chmod 644 wasserstrassen-lowres
EOF
    system $cmd;
    die "The command $cmd failed: $?" if $? != 0;
}

# Note: this is not perfect. It just picks the first of the cities
# with largest category. Should probably dump more information (e.g.
# population) in osm2bbd process and use this for better sorting.
sub target_largest_city_is_center {
    my $meta = eval { _load_meta() };
    if ($@) {
	print STDERR $@->{msg};
	return;
    }
    if ($meta->{center}) {
	print STDERR "center already set in meta.yml, do not overwrite, skipping";
	return;
    }
    require Data::Dumper;
    require Strassen::Core;
    my $max = undef;
    my $s = Strassen->new("$datadir/orte");
    $s->init;
    while() {
	my $r = $s->next;
	last if !@{ $r->[Strassen::COORDS()] };
	if (!defined $max || $max->[Strassen::CAT()] < $r->[Strassen::CAT()]) {
	    $max = $r;
	}
    }
    if (defined $max) {
	print STDERR "setting $max->[Strassen::NAME()] ($max->[Strassen::COORDS()][0]) as center ";
	$meta->{center} = [ split /,/, $max->[Strassen::COORDS()][0] ];
	DumpFile("meta.yml~", $meta);

	open my $ofh, ">", "meta.dd~"
	    or die "Cannot write to meta.dd~: $!";
	print $ofh Data::Dumper->new([$meta],['meta'])->Sortkeys(1)->Useqq(1)->Dump;
	close $ofh
	    or die "While closing meta.dd~: $!";
	rename "meta.dd~", "meta.dd"
	    or die "While renaming meta.dd~ to meta.dd: $!";
	rename "meta.yml~", "meta.yml"
	    or die "While renaming meta.yml~ to meta.yml: $!";
    }
}

sub target_inaccessible_streets {
    if (-e "inaccessible_strassen" &&
	-M "inaccessible_strassen" <= -M "strassen" &&
	-M "inaccessible_strassen" <= -M "gesperrt") {
	print STDERR "up-to-date";
	return;
    }
    my(undef, $tmp) = tempfile(UNLINK => 1, SUFFIX => "-inaccessible.bbd") or die $!;
    my $cmd = <<EOF;
set -e
$miscsrcdir/search_inaccessible_points -q -cache -shorter -street $datadir/strassen -blocked $datadir/gesperrt -blockedtype einbahn -blockedtype sperre > $tmp
mv $tmp inaccessible_strassen
chmod ugo-wx inaccessible_strassen
EOF
    system $cmd;
    die "The command $cmd failed: $?" if $? != 0;
}

sub target_make_long_streets {
    die <<EOF;
NYI, Strassen::Combine still have bugs. Also there must be some "tag"
in the generated file to prevent useless re-calculation of the file.
EOF
}

sub _load_meta {
    # assume to be in the right directory
    if (!eval { require YAML::Syck; YAML::Syck->import(qw(LoadFile DumpFile)); 1 } &&
	!eval { require YAML;       YAML      ->import(qw(LoadFile DumpFile)); 1 }
       ) {
	die +{ msg => "no YAML/YAML::Syck available, skipping",
	       code => 'NO_YAML',
	     };
    }
    my $meta = eval { LoadFile("XXXmeta.yml") };
    if (!$meta) {
	die +{ msg => "cannot load meta.yml, skipping",
	       code => 'INVALID_META',
	     };
    }
    $meta;
}
