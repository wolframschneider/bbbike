#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: osm2bbd-postprocess,v 1.19 2009/05/05 22:22:35 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");

use vars qw($VERSION);
$VERSION = 0.10;

use Cwd            qw(realpath);
use File::Basename qw(dirname);
use File::Temp     qw(tempfile);
use Getopt::Long;

my @targets = ('wasserstrassen_lowres',
	       'largest_city_is_center',
	       'inaccessible_streets',
	       #'make_long_streets',
	       'mount',
	      );
# Targets run by default (exclude obscure ones here)
my @run_targets =
    grep { !m{^(
		  mount
	      )$}x
	  }
    @targets;

my %skip_target;
my %only_target;

sub usage (;$) {
    my $msg = shift;
    warn $msg, "\n" if $msg;
    die "usage: $0 [--debug=0..2] [-force]\n" . join(" ", map {
	(my $optname = $_) =~ s{_}{-}g;
	"\t[-skip-$optname | -only-$optname]\n"
    } @targets) . "\tdatadir\n";
}

my $debug = 1;
my $force;
GetOptions(
	   (map {
	       (my $optname = $_) =~ s{_}{-}g;
	       ("skip-$optname" => \$skip_target{$_},
		"only-$optname" => \$only_target{$_},
	       );
	   } @targets), 
	   "debug=i" => \$debug,
	   "force!" => \$force,
	  )
    or usage;

my $miscsrcdir = realpath $FindBin::RealBin;
my $bbbikedir = dirname $miscsrcdir;
my $datadir = shift or usage "Please specify data directory";
$datadir = realpath $datadir;
chdir $datadir or die "Can't chdir to $datadir: $!";

if (grep { $_ } values %only_target) {
    @run_targets = grep { $only_target{$_} } @targets;
}

for my $target (@run_targets) {
    if ($skip_target{$target}) {
	print STDERR "Skip target $target.\n";
	next;
    }
    no strict 'refs';
    my $target_sub = "target_$target";
    if (!defined &{$target_sub}) {
	die "No subroutine for $target exists";
    }
    print STDERR "Running target $target ... " if $debug;
    &{$target_sub};
    print STDERR "\n" if $debug;
}

sub target_wasserstrassen_lowres {
    if (!$force && -e "wasserstrassen-lowres" && -M "wasserstrassen-lowres" <= -M "wasserstrassen") {
	print STDERR "up-to-date";
	return;
    }
    my(undef, $tmp1) = tempfile(UNLINK => 1, SUFFIX => "-wlores.bbd") or die $!;
    my(undef, $tmp2) = tempfile(UNLINK => 1, SUFFIX => "-wlores.bbd") or die $!;
    my $cmd = <<EOF;
set -e
cat wasserstrassen | $miscsrcdir/grepstrassen --catrx '^(F:W1)\$' > $tmp1
cat wasserstrassen | $miscsrcdir/grepstrassen --catrx '^(W1|W2|F:W)\$' --minarea 3 >> $tmp1
$^X $miscsrcdir/simplify_streets -tolerance 300 -algorithm 'douglas-peucker' $tmp1 > $tmp2
mv -f $tmp2 wasserstrassen-lowres
chmod ugo-wx,ugo+r wasserstrassen-lowres
EOF
    system $cmd;
    die "The command $cmd failed: $?" if $? != 0;
}

# Note: this is not perfect. It just picks the first of the cities
# with largest category. Should probably dump more information (e.g.
# population) in osm2bbd process and use this for better sorting.
sub target_largest_city_is_center {
    my $meta = eval { _load_meta() };
    if ($@) {
	print STDERR $@->{msg};
	return;
    }
    if (!$force && $meta->{center}) {
	print STDERR "center already set in meta.yml, do not overwrite, skipping" if $debug;
	return;
    }
    require Data::Dumper;
    require Strassen::Core;
    my $max = undef;
    my $s = Strassen->new("$datadir/orte");
    $s->init;
    while() {
	my $r = $s->next;
	last if !@{ $r->[Strassen::COORDS()] };
	if (!defined $max || $max->[Strassen::CAT()] < $r->[Strassen::CAT()]) {
	    $max = $r;
	}
    }
    if (defined $max) {
	print STDERR "setting $max->[Strassen::NAME()] ($max->[Strassen::COORDS()][0]) as center ";
	$meta->{center} = [ split /,/, $max->[Strassen::COORDS()][0] ];
	DumpFile("meta.yml~", $meta);

	open my $ofh, ">", "meta.dd~"
	    or die "Cannot write to meta.dd~: $!";
	print $ofh Data::Dumper->new([$meta],['meta'])->Sortkeys(1)->Useqq(1)->Dump;
	close $ofh
	    or die "While closing meta.dd~: $!";
	rename "meta.dd~", "meta.dd"
	    or die "While renaming meta.dd~ to meta.dd: $!";
	rename "meta.yml~", "meta.yml"
	    or die "While renaming meta.yml~ to meta.yml: $!";
    }
}

sub target_inaccessible_streets {
    if (!$force &&
	-e "inaccessible_strassen" &&
	-M "inaccessible_strassen" <= -M "strassen" &&
	-M "inaccessible_strassen" <= -M "gesperrt") {
	print STDERR "up-to-date";
	return;
    }

    # XXX This is a bug somewhere, maybe integer operation is used
    # somewhere?
    require Strassen::Core;
    my $glob_dir = Strassen->get_global_directives("$datadir/strassen");
    if ($glob_dir->{map} && $glob_dir->{map}[0] !~ m{^(bbbike|standard)$}) {
	print STDERR "only map=bbbike currently supported, skipping";
	return;
    }

    my(undef, $tmp) = tempfile(UNLINK => 1, SUFFIX => "-inaccessible.bbd") or die $!;
    my $cmd = <<EOF;
set -e
$miscsrcdir/search_inaccessible_points -q -cache -shorter -street $datadir/strassen -blocked $datadir/gesperrt -blockedtype einbahn -blockedtype sperre > $tmp
mv -f $tmp inaccessible_strassen
chmod ugo-wx,ugo+r inaccessible_strassen
EOF
    system $cmd;
    die "The command $cmd failed: $?" if $? != 0;
}

sub target_make_long_streets {
    die <<EOF;
NYI, Strassen::Combine still have bugs. Also there must be some "tag"
in the generated file to prevent useless re-calculation of the file.
EOF
}

sub target_mount {
    if (!$force &&
	-e "mount" && (-M "mount" <= -M "hoehe" &&
		       -M "mount" <= -M "gesperrt" &&
		       -M "mount" <= -M "strassen")
       ) {
	print STDERR "up-to-date";
	return;
    }
    my @cmd = ("$FindBin::RealBin/steigung_stat",
	       '-minmount', '1.0',
	       '-commentscompatible',
	       '-tolerant', # do not croak on linesegs with length=0
	       '-sperre', "$datadir/gesperrt",
	       '-str', "$datadir/strassen",
	       '-i', "$datadir/hoehe",
	       '-o', "$datadir/mount~"
	      );
    if ($debug >= 2) {
	print STDERR "Running '@cmd'...\n";
    }
    system @cmd;
    if ($? != 0) {
	die "The command '@cmd' failed: $?";
    }
    rename "$datadir/mount~", "$datadir/mount"
	or die "Can't rename mount~ to mount in $datadir: $!";
}

sub _load_meta {
    # assume to be in the right directory
    if (!eval { require YAML::Syck; YAML::Syck->import(qw(LoadFile DumpFile)); 1 } &&
	!eval { require YAML;       YAML      ->import(qw(LoadFile DumpFile)); 1 }
       ) {
	die +{ msg => "no YAML/YAML::Syck available, skipping",
	       code => 'NO_YAML',
	     };
    }
    my $meta = eval { LoadFile("meta.yml") };
    if (!$meta) {
	die +{ msg => "cannot load meta.yml, skipping",
	       code => 'INVALID_META',
	     };
    }
    $meta;
}
