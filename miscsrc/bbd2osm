#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2009,2010,2011 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);

use Fcntl qw(SEEK_SET);
use File::Temp qw(tempfile);
use Getopt::Long;
use Karte::Polar;
use Karte::Standard;
use Strassen::Core;
use Strassen::Strasse;
use VectorUtil qw(get_polygon_center);

sub usage () {
    die <<EOF;
usage: $0 [-ignore-missing] [-use-orig] [-quiet] [-debug] [datadir]
       $0 [-type area|waterway|highway|railway|ferry] -single bbdfile

Either convert a whole bbbike data directory, or convert a single bbd
file.
EOF
}

my $single_file;
my $single_file_type;
my $fragezeichen_file;
my $ignore_missing;
my $use_orig;
my $shorten_for_garmin;
my $quiet;
my $debug;
my $do_highway_primary_hack = 0;
GetOptions("single=s" => \$single_file,
	   "type=s" => \$single_file_type,
	   "fragezeichen=s" => \$fragezeichen_file,
	   "ignore-missing!" => \$ignore_missing,
	   "use-orig!" => \$use_orig,
	   "shorten-for-garmin!" => \$shorten_for_garmin,
	   "quiet!" => \$quiet,
	   "debug!" => \$debug,
	  )
    or usage;

my $datadir;
if (!$single_file) {
    $single_file_type and usage;
    $datadir = shift || "$FindBin::RealBin/../data";
} else {
    @ARGV and usage;
}

######################################################################
# Max. length on Garmin devices (at least etrex vista hcx) is 151
use constant MAX_LABEL_LENGTH => 151;
use constant MAX_ABBREV_LEVEL => 4;
my %ABBREV_WORD_DEFS = ( 'Uhr' => 'h',
			 'und' => '&',
			 'Montag' => 'Mo',
			 'montags' => 'mo',
			 'Freitag' => 'Fr',
			 'freitags' => 'fr',
			 'Samstag' => 'Sa',
			 'Sonntag' => 'So',
			 'pro Person' => 'p.P.',
			 'Euro' => "\x{20ac}",
			 'EUR' => "\x{20ac}",
			 'bis' => '-',
			 'stündlich' => 'stündl.',
			 'täglich' => 'tägl.',
			 'Minuten' => 'Min',
			 'April' => 'Apr',
			 'August' => 'Aug',
			 'Oktober' => 'Okt',
			 'Fahrzeit' => 'Fahrzt.',
		       );
my $ABBREV_WORD_RX = '(' . join("|", map { '\b'.quotemeta($_).'\b' } keys %ABBREV_WORD_DEFS) . ')';
$ABBREV_WORD_RX = qr{$ABBREV_WORD_RX};
######################################################################

my($nodefh, $nodefile) = tempfile(UNLINK => 1, SUFFIX => "_node.xml");
binmode $nodefh, ':utf8';
my($wayfh, $wayfile) = tempfile(UNLINK => 1, SUFFIX => "_way.xml");
binmode $wayfh, ':utf8';

my $next_node_id = 1;
my $next_way_id = 1;
my %node_id;

my %oneway;
my %no_access;
my %speed0;
my @remember_quality;

my %cat_to_highway = ('B'  => 'primary', # See also $do_highway_primary_hack
		      'HH' => 'primary',
		      'H'  => 'secondary',
		      'NH' => 'tertiary',
		      'N'  => 'residential',
		      'NN' => 'cycleway', # XXX
		      'BAB' => 'motorway',
		     );

my %cat_to_railway = ('U' => 'subway',
		      'S' => 'light_rail',
		      'R' => 'rail',
		     );

my %cat_to_area_landuse = ('Forest'     => 'forest',
			   'Cemetery'   => 'cemetery',
			   'Industrial' => 'industrial',
			   # 'Ae' => 'airport', # does not exist
			   'Orchard'    => 'allotments',
			   'Sport'      => 'sports',
			   'Green'      => 'village_green',
			  );
my %cat_to_area_leisure = ('P'          => 'park',
			   'Pabove'     => 'park',
			  );

my($min_lat, $max_lat, $min_lon, $max_lon);

if ($single_file) {
    $single_file_type ||= 'highway';
    my $subname = 'handle_' . $single_file_type . '_like';
    no strict 'refs';
    if (!defined &{$subname}) {
	die "Invalid type $single_file_type, no callback function exists for that.\n";
    }
    my $sub = \&{$subname};
    Strassen->new_stream($single_file)->read_stream($sub);
} else {
    # NODE-like
    do_file("$datadir/ampeln", \&handle_trafficsignals_like);
    if (-r "$datadir/zebrastreifen") {
	do_file("$datadir/zebrastreifen", \&handle_zebrastreifen_like);
    }
    do_file("$datadir/ubahnhof", \&handle_railway_stations_like);
    do_file("$datadir/sbahnhof", \&handle_railway_stations_like);
    do_file("$datadir/rbahnhof", \&handle_railway_stations_like);
    do_file("$datadir/gesperrt", \&handle_blocked_node_like);

    do_file("$datadir/orte", \&handle_city_like);
    do_file("$datadir/orte2", \&handle_city_like);
    do_file("$datadir/ortsschilder", \&handle_city_limit_like);
    do_file("$datadir/berlin_ortsteile", \&handle_berlin_citypart_like);

    do_file("$datadir/comments_ferry", \&handle_ferry_info_like);

    # WAY-like
    do_file("$datadir/gesperrt", \&handle_blocked_way_like);
    do_file("$datadir/handicap_s", \&handle_handicap_like);
    do_file("$datadir/handicap_l", \&handle_handicap_like);
    do_file("$datadir/qualitaet_s", \&handle_handicap_like);
    do_file("$datadir/qualitaet_l", \&handle_handicap_like);

    do_file("$datadir/flaechen", \&handle_area_like);

    do_file("$datadir/wasserstrassen", \&handle_waterway_like);
    do_file("$datadir/wasserumland", \&handle_waterway_like);
    do_file("$datadir/wasserumland2", \&handle_waterway_like);

    do_file("$datadir/faehren", \&handle_ferry_like);

    do_file("$datadir/strassen", \&handle_berlin_highway_like);
    do_file("$datadir/strassen_bab", \&handle_anywhere_highway_like); # don't do address handling here, so use "anywhere"
    do_file("$datadir/landstrassen", \&handle_anywhere_highway_like);
    do_file("$datadir/landstrassen2", \&handle_anywhere_highway_like);

    dump_quality();
	
    if (!$fragezeichen_file) {
	$fragezeichen_file = -r "$datadir/../tmp/fragezeichen-nextcheck.bbd" ? "$datadir/../tmp/fragezeichen-nextcheck.bbd" : "$datadir/fragezeichen";
    }
    do_file($fragezeichen_file, \&handle_fixme_like);

    do_file("$datadir/ubahn", \&handle_railway_like);
    do_file("$datadir/sbahn", \&handle_railway_like);
    do_file("$datadir/rbahn", \&handle_railway_like);

    # Use -orig files here, because it has more information (RW? etc.)
    if (-r "$datadir/radwege-orig") {
	do_file("$datadir/radwege-orig", \&handle_cycleway_like);
    }
    if (-r "$datadir/comments_cyclepath-orig") {
	do_file("$datadir/comments_cyclepath-orig", \&handle_cycleway_like);
    }
}

sub do_file {
    my($file, $cb) = @_;
    $file .= "-orig" if $use_orig;
    eval {
	Strassen->new_stream($file)->read_stream($cb);
    };
    if ($@) {
	if ($ignore_missing) {
	    warn "Cannot find or handle $file, skipping..\n" unless $quiet;
	} else {
	    die $@;
	}
    }
}

sub handle_blocked_node_like {
    my($r, $dir) = @_;
    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    my $attribs;
    if ($cat eq 'BNP') {
	if ($r->[Strassen::NAME] =~ m{drängelgitter}i) {
	    $attribs = { barrier => 'cycle_barrier' };
	} else {
	    $attribs = { barrier => 'bollard' }; #  (which is a quite bold assumption)
	}
    } elsif ($cat eq '0') {
	if ($r->[Strassen::NAME] =~ m{(\d+)\s+Stufe}) { # XXX see steps_stats.pl for more possible regexps, should go into a module!
	    $attribs->{step_count} = $1;
	}
	$attribs->{highway} = 'steps'; # not good: steps are in osm usually lines, not nodes!
    }
    if ($attribs) {
	get_node_ids($r, $attribs); # as a side-effect, create the nodes
    }
}

sub handle_blocked_way_like {
    my($r, $dir) = @_;
    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };
    for my $node_id_i (1 .. $#node_ids) {
	if ($cat eq '1') {
	    $oneway{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1; # in osm oneway is the open direction, not the closed
	} elsif ($cat eq '2') {
	    $no_access{$node_ids[$node_id_i-1].' '.$node_ids[$node_id_i]} = 1;
	    $no_access{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1;
	}
    }
}

sub handle_handicap_like {
    my($r, $dir) = @_;
    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	($cat_hin, $cat_rueck) = ($r->[Strassen::CAT], $r->[Strassen::CAT]);
    }
    for ($cat_hin, $cat_rueck) {
	if (defined $_) {
	    ($_) = $_ =~ m{^([^:]+)};
	}
    }
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };
    for my $node_id_i (1 .. $#node_ids) {
	if ($cat_hin =~ m{^[qQ][34]$}) {
	    $speed0{$node_ids[$node_id_i-1].' '.$node_ids[$node_id_i]} = 1; # XXX correct direction
	}
	if (defined $cat_rueck) {
	    if ($cat_rueck =~ m{^[qQ][34]$}) {
		$speed0{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1;
	    }
	}
    }

    my($quality_hin) = $cat_hin =~ m{^Q(\d+)}; # XXX maybe support for +/-?
    my $quality = $quality_hin;
    if (defined $cat_rueck) {
	my($quality_rueck) = $cat_rueck =~ m{^Q(\d+)}; # XXX maybe support for +/-?
	if (defined $quality_rueck && (!defined $quality_hin || $quality_rueck > $quality_hin)) {
	    $quality = $quality_rueck;
	}
    }
    if (defined $quality) {
	push @remember_quality, [\@node_ids, $quality];
    }
}

sub handle_berlin_highway_like   { _handle_highway_like('Berlin', @_) }
sub handle_anywhere_highway_like { _handle_highway_like(undef, @_) }

sub _handle_highway_like {
    my($city, $r, $dir) = @_;

    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    if ($cat eq 'Pl') {
	# XXX maybe handle later...
	return;
    }
    my $highway_tag = $cat_to_highway{$cat};
    if (!defined $highway_tag) {
	warn "Ignore cat='$r->[Strassen::CAT]'...\n";
	return;
    }

    my @node_ids = get_node_ids($r);

    # split streets
    my @segments;
    my $last_tags;
    my @last_tags;
    my $begin_split_index = 0;
    for my $node_idx (1 .. $#node_ids) {
	my $forward_spec = $node_ids[$node_idx-1].' '.$node_ids[$node_idx];
	my $backward_spec = $node_ids[$node_idx].' '.$node_ids[$node_idx-1];
	my @this_tags = (
			 ($oneway{$forward_spec}||''),
			 ($oneway{$backward_spec}||''),
			 ($no_access{$forward_spec}||''),
			 ($speed0{$forward_spec}||''),
			 ($speed0{$backward_spec}||''),
			);
	my $this_tags = join(" ", @this_tags);
	if (defined $last_tags) {
	    if ($last_tags ne $this_tags) {
		# we need to split
		push @segments, [[@node_ids[$begin_split_index..$node_idx-1]], [@last_tags]];
		$begin_split_index = $node_idx-1;
		$last_tags = $this_tags;
		@last_tags = @this_tags;
	    }
	} else {
	    $last_tags = $this_tags;
	    @last_tags = @this_tags;
	}
    }
    push @segments, [[@node_ids[$begin_split_index..$#node_ids]], [@last_tags]];

    my($name, @cityparts) = Strasse::split_street_citypart($r->[Strassen::NAME]);
    _xmlify($name);

    # This is the most reasonable scheme to set is_in/addr tags, to
    # get it best working in the "Find" screen of Garmin:
    #
    # for streets in Berlin (defined $city):
    # * is_in:county => "Berlin"
    # * addr:city => first citypart (if any)
    #
    # for streets outside Berlin (@cityparts exist)
    # * addr:city => first citypart (usually there is exactly one)
    #
    # If any of these tags is set, then also set addr:country
    my %is_in;
    if (defined $city) {
	$is_in{'is_in:county'} = $city; # XXX lying for Berlin, so we have cityparts in addr:city and Berlin in is_in:county
	if (@cityparts) {
	    $is_in{'addr:city'} = $cityparts[0];
	}
    } else {
	if (@cityparts) {
	    $is_in{'addr:city'} = $cityparts[0];
	}
    }
    if (%is_in) {
	$is_in{'addr:country'} = 'DE'; # XXX not always true, some streets are in Poland and Czech Republic
    }

    for my $segment (@segments) {
	my @node_ids = @{$segment->[0]};
	my($oneway, $oneway_reversed, $no_access, $speed0, $speed0_reversed) = @{$segment->[1]};

	if ($oneway_reversed) {
	    @node_ids = reverse @node_ids;
	    $oneway = 1;
	}

	my $any_speed0 = $speed0 || $speed0_reversed; # XXX for the real thing I had to split the way into two directions...
	    
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	print $wayfh qq{  <tag k="name" v="$name" />\n};
	while(my($k,$v) = each %is_in) {
	    _xmlify($v);
	    print $wayfh qq{  <tag k="$k" v="$v" />\n};
	}
	if ($any_speed0) {
	    print $wayfh qq{  <tag k="highway" v="footway" />\n};
	    print $wayfh qq{  <tag k="bicycle" v="yes" />\n};
	} else {
	    if ($do_highway_primary_hack && $highway_tag =~ m{^(primary|secondary)$}) {
		print $wayfh qq{  <tag k="highway" v="tertiary" />\n};
		print $wayfh qq{  <tag k="bbbike:render" v="highway_${highway_tag}" />\n};
	    } else {
		print $wayfh qq{  <tag k="highway" v="$highway_tag" />\n};
	    }
	}
	if ($oneway) {
	    print $wayfh qq{  <tag k="oneway" v="yes" />\n};
	}
	if ($no_access) {
	    print $wayfh qq{  <tag k="access" v="no" />\n};
	    print $wayfh qq{  <tag k="bicycle" v="no" />\n}; # access=no is not enough
	}

	if (0) {
	    print $wayfh qq{  <tag k="addr:street" v="$name" />\n};
	    print $wayfh qq{  <tag k="addr:housenumber" v="0" />\n}; # XXX pure faked
	    print $wayfh qq{  <tag k="addr:country" v="DE" />\n};
	    if (@cityparts) {
		# parse street numbers out
		@cityparts = grep {
		    my($type, $nr) = Strasse::parse_street_type_nr($_);
		    !defined $type;
		} @cityparts;
		if (@cityparts) {
		    _xmlify($cityparts[0]);
		    # XXX hack: use only first
		    print $wayfh qq{  <tag k="addr:city" v="$cityparts[0]" />\n};
		}
	    }
	}

	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub handle_fixme_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME] || 'FIXME';
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="FIXME" v="$name" />\n};
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_railway_like {
    my($r, $dir) = @_;

    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    return if $cat !~ m{^([USR])([ABC0]?)$};
    my $railway_cat = $cat_to_railway{$1};
    return if !defined $railway_cat;
    my $is_abandoned = defined $2 && $2 eq '0';

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    print $wayfh qq{  <tag k="railway" v="$railway_cat" />\n};
    if ($is_abandoned) {
	print $wayfh qq{  <tag k="abandoned" v="yes" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_waterway_like {
    my($r, $dir) = @_;

    my($is_area, $cat);
    if ($r->[Strassen::CAT] =~ m{^F:([^:]+)}) {
	$is_area = 1;
	$cat = $1;
    } else {
	$cat = $r->[Strassen::CAT] =~ m{^([^:]+)};
    }
    # XXX handling W0,W1 etc. missing

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    if ($is_area) {
	print $wayfh qq{  <tag k="natural" v="water" />\n};
    } else {
	print $wayfh qq{  <tag k="waterway" v="river" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_ferry_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    print $wayfh qq{  <tag k="route" v="ferry" />\n};
    # XXX description from comments_ferry missing
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_ferry_info_like {
    my($r, $dir) = @_;

    my $label = shorten_label($r->[Strassen::NAME]);

    get_node_id_from_center($r, { note => $label });
}

sub handle_area_like {
    my($r, $dir) = @_;

    if ($r->[Strassen::CAT] !~ m{^F:([^:]+)}) {
	return; # should never happen
    }
    my $cat = $1;
    my($landuse, $leisure);
    $landuse = $cat_to_area_landuse{$cat};
    if (!defined $landuse) {
	$leisure = $cat_to_area_leisure{$cat};
	if (!defined $leisure) {
	    #warn "Ignoring $cat...\n";
	    return;
	}
    }

    my @node_ids = get_node_ids($r);
    push @node_ids, $node_ids[0] unless $node_ids[0] == $node_ids[$#node_ids];

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    if (defined $landuse) {
	print $wayfh qq{  <tag k="landuse" v="$landuse" />\n};
    } else {
	print $wayfh qq{  <tag k="leisure" v="$leisure" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_trafficsignals_like {
    my($r, $dir) = @_;
    my $cat = $r->[Strassen::CAT];

    my $attribs;
    if      ($cat =~ m{^X}) {
	$attribs = { highway => 'traffic_signals' };
    } elsif ($cat =~ m{^F}) {
	$attribs = { highway => 'crossing', crossing => 'traffic_signals' };
    } elsif ($cat =~ m{^B}) {
	$attribs = { railway => 'level_crossing',
		     ($cat =~ m{0$} ? (abandoned => 'yes') : ()), # not accurate, may be also seldomly used
		   };
    } else {
	# ignore
	return;
    }

    get_node_ids($r, $attribs); # as a side-effect, create the nodes
}

sub handle_zebrastreifen_like {
    my($r) = @_;
    get_node_ids($r, { highway => 'crossing',
		       crossing => 'uncontrolled',
		       crossing_ref => 'zebra',
		     });
}

sub handle_railway_stations_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $is_ubahn = $cat =~ m{^U};
    my $is_sbahn = $cat =~ m{^S};
    my $is_abandoned = $cat =~ m{0$};
    my $attribs = { railway => 'station', # no distinction between halt and station
		    name => ($is_ubahn ? 'U ' : $is_sbahn ? 'S ' : '') . $r->[Strassen::NAME],
		    ($is_abandoned ? ("abandoned" => "yes") : ()),
		  };
    if      ($is_ubahn) {
	$attribs->{station} = 'subway';
    } elsif ($is_sbahn) {
	$attribs->{station} = 'light_rail';
    } elsif ($cat =~ m{^R}) {
	# Regional/Fernbahnhof
    } else {
	warn "Unhandled railway station-like category $cat\n";
	return;
    }

    get_node_ids($r, $attribs);
}

sub handle_city_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $place;
    if      ($cat >= 5) {
	$place = 'city';
    } elsif ($cat >= 3) {
	$place = 'town';
    } elsif ($cat >= 1) {
	$place = 'village';
    } else {
	$place = 'hamlet';
    }
    get_node_ids($r, { name  => format_place_label($r->[Strassen::NAME]),
		       place => $place,
		     });
}

sub handle_city_limit_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $traffic_sign_name;
    if ($cat eq 'OS') {
	$traffic_sign_name = 'city_limit';
    } elsif ($cat eq 'OHT') {
	# kein offizielles OSM-Tag
	# englische Übersetzung von "Ortshinweistafel" aus:
	# http://de.wikipedia.org/wiki/Datei:Zeichen_385.svg
	$traffic_sign_name = 'locality_name';
    } else {
	warn "Unhandled city-limit like category '$cat'";
	return;
    }
    my $attribs = { traffic_sign => $traffic_sign_name,
		    name         => format_place_label($r->[Strassen::NAME]),
		  };
    get_node_ids($r, $attribs);
}

sub handle_berlin_citypart_like {
    my($r) = @_;
    my($sxy) = join ",", get_polygon_center(map { split/,/ } @{ $r->[Strassen::COORDS] });
    get_node_id($sxy, { place => 'suburb',
			name  => $r->[Strassen::NAME],
			'is_in:county' => 'Berlin',
			'addr:country' => 'DE',
		      });
    # And add Berlin:
    if ($r->[Strassen::NAME] eq 'Mitte') {
	get_node_id($sxy, { place => 'county', # XXX lying
			    name  => 'Berlin',
			    'addr:country' => 'DE',
			  });
    }
}

sub handle_cycleway_like {
    my($r, $dir) = @_;
    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	($cat_hin, $cat_rueck) = ($r->[Strassen::CAT], $r->[Strassen::CAT]);
    }
    for ($cat_hin, $cat_rueck) {
	if (defined $_) {
	    ($_) = $_ =~ m{^([^:]+)};
	}
    }
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };

    my $extra_tags_for_dualdir = sub {
	my $extra_tags = '';
	my $hin_mandatory   = ($cat_hin||'') eq 'RW2';
	my $rueck_mandatory = ($cat_rueck||'') eq 'RW8';
	if ($hin_mandatory && $rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($hin_mandatory || $rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mixed" />\n};
	} elsif (!$hin_mandatory && !$rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} else {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	}
	$extra_tags;
    };

    for my $def ([$cat_hin, +1], [$cat_rueck, -1]) {
	my($cat, $direction) = @$def;
	next if !defined $cat || $cat eq '';
	my $extra_tags;
	# Check for Zweirichtungsradweg first
	if (($cat_hin||'') =~ m{^(RW|RW1|RW2|RW\?)$} && ($cat_rueck||'') =~ m{^(RW8|RW8\?|RW9|RW9\?)$}) {
	    if ($direction == +1) {
		$extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
		$extra_tags .= qq{  <tag k="bbbike:cycleway_type" v="dualdir" />\n};
		$extra_tags .= $extra_tags_for_dualdir->();
	    }
	} elsif (($cat_rueck||'') =~ m{^(RW|RW1|RW2|RW\?)$} && ($cat_hin||'') =~ m{^(RW8|RW8\?|RW9|RW9\?)$}) {
	    if ($direction == -1) {
		$extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
		$extra_tags .= qq{  <tag k="bbbike:cycleway_type" v="dualdir" />\n};
		$extra_tags .= $extra_tags_for_dualdir->();
	    }
	} elsif ($cat eq 'RW' || $cat eq 'RW?' || $cat eq 'RW8?') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	} elsif ($cat eq 'RW1' || $cat eq 'RW9') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} elsif ($cat eq 'RW2' || $cat eq 'RW8') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($cat eq 'RW3') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} elsif ($cat eq 'RW4') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($cat eq 'RW4?') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	} elsif ($cat eq 'RW5') {
	    $extra_tags .= qq{  <tag k="psv" v="yes" />\n};
	    if ($r->[Strassen::NAME()] =~ m{(Busspur ist immer gültig|Busspur gilt immer)}) {
		$extra_tags .= qq{  <tag k="bbbike:times" v="always" />\n};
	    }
	} elsif ($cat eq 'RW5?') {
	    $extra_tags .= qq{  <tag k="psv" v="yes" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:times" v="unknown" />\n};
	} elsif ($cat eq 'RW6') {
	    # living street XXX
	} elsif ($cat eq 'RW7') {
	    # Fahrradstraße XXX
	} elsif ($cat eq 'RW10') {
	    # Nebenfahrbahn XXX
	} elsif ($cat eq 'RW0') {
	    # kein Radweg
	} else {
	    warn "Unexpected category '$cat'...";
	}
	if ($extra_tags) {
	    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	    my @node_ids = $direction == +1 ? @node_ids : reverse(@node_ids);
	    for my $node_id (@node_ids) {
		print $wayfh qq{  <nd ref="$node_id"/>\n};
	    }
	    my $name = $r->[Strassen::NAME];
	    if (defined $name && $name ne '') {
		_xmlify($name);
		print $wayfh qq{  <tag k="name" v="$name" />\n};
	    }
	    print $wayfh $extra_tags;
	    print $wayfh qq{</way>\n};
	    $next_way_id++;
	}
    }
}

seek $nodefh, 0, SEEK_SET
    or die $!;
seek $wayfh, 0, SEEK_SET
    or die $!;

binmode STDOUT, ':utf8';
print qq{<osm version="0.6" generator="bbd2osm">\n};
print qq{<bound box="$min_lat,$min_lon,$max_lat,$max_lon" origin="http://www.bbbike.de" />\n};
while(<$nodefh>) {
    print $_;
}
while(<$wayfh>) {
    print $_;
}
print qq{</osm>\n};

sub get_node_ids {
    my($r, $attribs) = @_;
    my @node_ids;
    for my $sxy (@{ $r->[Strassen::COORDS] }) {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
	my $this_node_id = maybe_add_node($px, $py, $attribs);
	push @node_ids, $this_node_id;
    }
    @node_ids;
}

sub get_node_id {
    my($sxy, $attribs) = @_;
    my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
    maybe_add_node($px, $py, $attribs);
}

sub get_node_id_from_center {
    my($r, $attribs) = @_;
    my $c = $r->[Strassen::COORDS];
    my $sxy;
    if (@$c % 2 == 1) {
	$sxy = $c->[@$c/2];
    } else {
	my($x0,$y0) = split /,/, $c->[@$c/2 - 1];
	my($x1,$y1) = split /,/, $c->[@$c/2];
	$sxy = (($x1-$x0)/2+$x0) . ',' . (($y1-$y0)/2+$y0);
    }
    my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
    maybe_add_node($px, $py, $attribs);
}

sub maybe_add_node {
    my($px, $py, $attribs) = @_;
    my $pxy = $px.','.$py;
    my $this_node_id = $node_id{$pxy};
    if (!defined $this_node_id) {
	$this_node_id = $node_id{$pxy} = $next_node_id++;
	print $nodefh qq{<node id="$this_node_id" lat="$py" lon="$px" user="eserte" visible="true" };
	if ($attribs) {
	    print $nodefh qq{>\n};
	    while(my($k,$v) = each %$attribs) {
		_xmlify($k);
		_xmlify($v);
		print $nodefh qq{  <tag k="$k" v="$v"/>\n};
	    }
	    print $nodefh qq{</node>\n};
	} else {
	    print $nodefh qq{/>\n};
	}

	$min_lon = $px if !defined $min_lon || $min_lon > $px;
	$max_lon = $px if !defined $max_lon || $max_lon < $px;
	$min_lat = $py if !defined $min_lat || $min_lat > $py;
	$max_lat = $py if !defined $max_lat || $max_lat < $py;

    }
    $this_node_id;
}

sub _xmlify {
    $_[0] =~ s{&}{&#38;}g; # XXX hack to xml-ify
    $_[0] =~ s{"}{&#34;}g;
    $_[0] =~ s{<}{&#60;}g;
    $_[0] =~ s{>}{&#62;}g;
}

sub dump_quality {
    for my $def (@remember_quality) {
	my($node_ids, $quality) = @$def;
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@$node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	print $wayfh qq{  <tag k="bbbike:quality" v="Q$quality" />\n};
	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub shorten_label {
    my $s = shift;
    if ($shorten_for_garmin) {
	my $abbrev_level = 1;
	while (length $s > MAX_LABEL_LENGTH) {
	    if ($abbrev_level > MAX_LABEL_LENGTH) {
		$s =~ s{$ABBREV_WORD_RX}{$ABBREV_WORD_DEFS{$1}}g;
		if (length $s > MAX_LABEL_LENGTH) {
		    warn "Label <$s> too long and may not be shortened further...\n" if $debug;
		}
		last;
	    }
	    $s = Strasse::short($s, $abbrev_level);
	    $abbrev_level++;
	}
    }
    $s;
}

sub format_place_label {
    my $s = shift;
    my($name, $add) = split /\|/, $s;
    $name . (defined $add ? ' ' . $add : '');
}

__END__

=head1 NAME

bbd2osm - generate osm files out of bbd files

=head1 SYNOPSIS

Convert a whole bbbike data directory. For the default data directory
use

    bbd2osm > out.osm

For a specified data directory use

    bbd2osm /path/to/datadir > out.osm

For a single bbd file use

    bbd2osm -single in.bbd -type ... > out.osm

Refer to the usage for allowed types.

=head1 TODO

Currently the way and node ids start at 1 and increment by one. This
means clashes are possible if these data and "real" osm is mixed.
Maybe I should check if the various osm tools can handle negative or
non-numeric ids, or if there's a private id range documented.

Implement handling of BNP:...

Do again some testing and work for the C<$do_highway_primary_hack>.
The Garmin seems aggressively avoid all primary and secondary highways
when doing routing for cyclists, leading to strange routes, at least
when trying it in Berlin. The idea was to render primary and secondary
roads, but to have internally a lower class, e.g. tertiary. First
tests were not successful, though...

=head1 AUTHOR

Slaven Rezic

=cut
