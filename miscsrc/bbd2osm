#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2009,2010,2011,2012 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);

use Fcntl qw(SEEK_SET);
use File::Temp qw(tempfile);
use Getopt::Long;
use Geography::Berlin_DE ();
use Karte::Polar;
use Karte::Standard;
use PLZ;
use Strassen::Core;
use Strassen::Strasse;
use VectorUtil qw(get_polygon_center);

sub usage () {
    die <<EOF;
usage: $0 [-ignore-missing] [-use-orig] [-quiet] [-debug] [datadir] [-optimize-for garmin|mapnik|mapnik-bbbike]
       $0 [-type area|waterway|highway|railway|ferry] -single bbdfile

Either convert a whole bbbike data directory, or convert a single bbd
file.
EOF
}

my $single_file;
my $single_file_type;
my $fragezeichen_file;
my $ignore_missing;
my $use_orig;
my $optimize_for_string = '';
my $shorten_for_garmin;
my $quiet;
my $debug;
my $do_highway_primary_hack = 0;
GetOptions("single=s" => \$single_file,
	   "type=s" => \$single_file_type,
	   "fragezeichen=s" => \$fragezeichen_file,
	   "ignore-missing!" => \$ignore_missing,
	   "use-orig!" => \$use_orig,
	   "optimize-for=s" => \$optimize_for_string,
	   "shorten-for-garmin!" => \$shorten_for_garmin,
	   "quiet!" => \$quiet,
	   "debug!" => \$debug,
	  )
    or usage;

use constant OPTIMIZE_FOR_NONE           => 0;
use constant OPTIMIZE_FOR_GARMIN         => 1;
use constant OPTIMIZE_FOR_MAPNIK         => 2;

use constant OPTIMIZE_FOR_MAPNIK_STYLE_NONE    => 0;
use constant OPTIMIZE_FOR_MAPNIK_STYLE_DEFAULT => 1;
use constant OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE  => 2;
my $optimize_for              = OPTIMIZE_FOR_NONE;
my $optimize_for_mapnik_style = OPTIMIZE_FOR_MAPNIK_STYLE_NONE;
if ($optimize_for_string) {
    if ($optimize_for_string !~ m{^(garmin|mapnik|mapnik-bbbike)$}) {
	warn "-optimize-for takes only value 'garmin' or 'mapnik' or 'mapnik-bbbike'\n";
	usage;
    }
    if ($optimize_for_string eq 'garmin') {
	$shorten_for_garmin = 1;
	$optimize_for = OPTIMIZE_FOR_GARMIN;
    } elsif ($optimize_for_string eq 'mapnik') {
	$optimize_for              = OPTIMIZE_FOR_MAPNIK;
	$optimize_for_mapnik_style = OPTIMIZE_FOR_MAPNIK_STYLE_DEFAULT;
    } elsif ($optimize_for_string eq 'mapnik-bbbike') {
	$optimize_for              = OPTIMIZE_FOR_MAPNIK;
	$optimize_for_mapnik_style = OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE;
    } else {
	die "Should never happen (optimize_for=$optimize_for_string)";
    }
}

my $datadir;
if (!$single_file) {
    $single_file_type and usage;
    $datadir = shift || "$FindBin::RealBin/../data";
} else {
    @ARGV and usage;
}

######################################################################
# Max. length on Garmin devices (at least etrex vista hcx) is 151
use constant MAX_LABEL_LENGTH => 151;
use constant MAX_ABBREV_LEVEL => 4;
my %ABBREV_WORD_DEFS = ( 'Uhr' => 'h',
			 'und' => '&',
			 'Montag' => 'Mo',
			 'montags' => 'mo',
			 'Freitag' => 'Fr',
			 'freitags' => 'fr',
			 'Samstag' => 'Sa',
			 'Sonntag' => 'So',
			 'pro Person' => 'p.P.',
			 'Euro' => "\x{20ac}",
			 'EUR' => "\x{20ac}",
			 'bis' => '-',
			 'stündlich' => 'stündl.',
			 'täglich' => 'tägl.',
			 'Minuten' => 'Min',
			 'April' => 'Apr',
			 'August' => 'Aug',
			 'Oktober' => 'Okt',
			 'Fahrzeit' => 'Fahrzt.',
		       );
my $ABBREV_WORD_RX = '(' . join("|", map { '\b'.quotemeta($_).'\b' } keys %ABBREV_WORD_DEFS) . ')';
$ABBREV_WORD_RX = qr{$ABBREV_WORD_RX};
######################################################################

my($nodefh, $nodefile) = tempfile(UNLINK => 1, SUFFIX => "_node.xml");
binmode $nodefh, ':utf8';
my($wayfh, $wayfile) = tempfile(UNLINK => 1, SUFFIX => "_way.xml");
binmode $wayfh, ':utf8';
my($relationfh, $relationfile) = tempfile(UNLINK => 1, SUFFIX => "_relation.xml");
binmode $relationfh, ':utf8';

my $next_node_id = 1;
my $next_way_id = 1;
my $next_relation_id = 1;
my %node_id;

my %oneway;
my %no_access;
my %speed0;
my @remember_quality;
my @remember_handicap;
my %remember_steps; # node_id -> { steps => ... }

my %cat_to_highway = ('B'  => 'primary', # See also $do_highway_primary_hack
		      'HH' => 'primary',
		      'H'  => 'secondary',
		      'NH' => 'tertiary',
		      'N'  => 'residential',
		      'NN' => 'cycleway', # XXX
		      'BAB' => 'motorway', # or motorroad (Kfz-Straße)
		     );

my %cat_to_railway = ('U' => 'subway',
		      'S' => 'light_rail',
		      'R' => 'rail',
		      'RG' => 'rail', # XXX is there a better tag?
		      'RP' => 'narrow_gauge', # not quite correct, but in most cases a good approximation
		     );

my %cat_to_area_landuse = ('Forest'     => 'forest',
			   'Cemetery'   => 'cemetery',
			   'Industrial' => 'industrial',
			   # 'Ae' => 'airport', # does not exist
			   'Orchard'    => 'allotments',
			   ($optimize_for != OPTIMIZE_FOR_MAPNIK ? ('Sport' => 'sports') : ()),
			   'Green'      => 'village_green',
			  );
my %cat_to_area_leisure = ('P'          => 'park',
			   'Pabove'     => 'park',
			   ($optimize_for == OPTIMIZE_FOR_MAPNIK ? ('Sport' => 'sports_centre') : ()),
			  );

my %bbbikequality_to_smoothness = (0 => 'excellent',    # Q0
				   1 => 'good',         # Q1
				   2 => 'intermediate', # Q2
				   3 => 'bad',          # Q3
				  );

my $geo = Geography::Berlin_DE->new; # currently hardcoded for Berlin

my $plz = PLZ->new;
$plz->load;
my $street_to_citypart = $plz->make_any_hash(PLZ::FILE_NAME, PLZ::FILE_CITYPART);

my($min_lat, $max_lat, $min_lon, $max_lon);

if ($single_file) {
    $single_file_type ||= 'highway';
    my $subname = 'handle_' . $single_file_type . '_like';
    no strict 'refs';
    if (!defined &{$subname}) {
	die "Invalid type $single_file_type, no callback function exists for that.\n";
    }
    my $sub = \&{$subname};
    Strassen->new_stream($single_file)->read_stream($sub);
} else {
    # NODE-like
    do_file("$datadir/ampeln", \&handle_trafficsignals_like);
    if (-r "$datadir/zebrastreifen") {
	do_file("$datadir/zebrastreifen", \&handle_zebrastreifen_like);
    }
    do_file("$datadir/ubahnhof", \&handle_railway_stations_like);
    do_file("$datadir/sbahnhof", \&handle_railway_stations_like);
    do_file("$datadir/rbahnhof", \&handle_railway_stations_like);
    do_file("$datadir/gesperrt", \&handle_blocked_node_like);

    do_file("$datadir/orte", \&handle_city_like);
    do_file("$datadir/orte2", \&handle_city_like);
    do_file("$datadir/ortsschilder", \&handle_city_limit_like);
    do_file("$datadir/berlin_ortsteile", \&handle_berlin_citypart_like);

    do_file("$datadir/comments_ferry", \&handle_ferry_info_like);
    do_file("$datadir/comments_scenic", \&handle_comments_scenic_like);

    # WAY-like
    do_file("$datadir/gesperrt", \&handle_blocked_way_like);
    do_file("$datadir/handicap_s", \&handle_handicap_like);
    do_file("$datadir/handicap_l", \&handle_handicap_like);
    do_file("$datadir/qualitaet_s", \&handle_handicap_like);
    do_file("$datadir/qualitaet_l", \&handle_handicap_like);

    do_file("$datadir/flaechen", \&handle_area_like);

    do_file("$datadir/wasserstrassen", \&handle_waterway_like);
    do_file("$datadir/wasserumland", \&handle_waterway_like);
    do_file("$datadir/wasserumland2", \&handle_waterway_like);

    do_file("$datadir/faehren", \&handle_ferry_like);

    do_file("$datadir/strassen", \&handle_berlin_highway_like);
    do_file("$datadir/strassen_bab", \&handle_anywhere_highway_like); # don't do address handling here, so use "anywhere"
    do_file("$datadir/landstrassen", \&handle_anywhere_highway_like);
    do_file("$datadir/landstrassen2", \&handle_anywhere_highway_like);

    # XXX not enabled by default
    if (0 && $optimize_for_mapnik_style == OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE) {
	do_file("$datadir/comments_route", \&handle_comments_route_like);
    }

    dump_quality();
    dump_handicap();
	
    if (!$fragezeichen_file) {
	$fragezeichen_file = -r "$datadir/../tmp/fragezeichen-nextcheck.bbd" ? "$datadir/../tmp/fragezeichen-nextcheck.bbd" : "$datadir/fragezeichen";
    }
    do_file($fragezeichen_file, \&handle_fixme_like);

    do_file("$datadir/ubahn", \&handle_railway_like);
    do_file("$datadir/sbahn", \&handle_railway_like);
    do_file("$datadir/rbahn", \&handle_railway_like);

    # Use -orig files here, because it has more information (RW? etc.)
    if (-r "$datadir/radwege-orig") {
	do_file("$datadir/radwege-orig", \&handle_cycleway_like);
    }
    if (-r "$datadir/comments_cyclepath-orig") {
	do_file("$datadir/comments_cyclepath-orig", \&handle_cycleway_like);
    }

    do_file("$datadir/berlin_ortsteile", \&handle_citypart_like);
}

sub do_file {
    my($file, $cb) = @_;
    $file .= "-orig" if $use_orig;
    eval {
	Strassen->new_stream($file)->read_stream($cb);
    };
    if ($@) {
	if ($ignore_missing) {
	    warn "Cannot find or handle $file, skipping..\n" unless $quiet;
	} else {
	    die $@;
	}
    }
}

sub handle_blocked_node_like {
    my($r, $dir) = @_;
    my($cat, $cat_attribs) = $r->[Strassen::CAT] =~ m{^([^:]+)(?:::(.*))?};

    # Don't render if the output is map-only
    if ($optimize_for == OPTIMIZE_FOR_MAPNIK && ($cat_attribs||'') =~ /\bigndisp\b/) {
	return;
    }

    my $attribs;
    if ($cat eq 'BNP') {
	if ($r->[Strassen::NAME] =~ m{drängelgitter}i) {
	    $attribs = { barrier => 'cycle_barrier' };
	} else {
	    $attribs = { barrier => 'bollard' }; #  (which is a quite bold assumption)
	}
    } elsif ($cat eq '0') {
	if ($r->[Strassen::NAME] =~ m{(\d+)\s+Stufe}) { # XXX see steps_stats.pl for more possible regexps, should go into a module!
	    $attribs->{step_count} = $1;
	}
	if ($optimize_for == OPTIMIZE_FOR_GARMIN ||
	    $optimize_for == OPTIMIZE_FOR_MAPNIK) {
	    if (@{$r->[Strassen::COORDS]} == 1) {
		my @node_ids = get_node_ids($r);
		$remember_steps{$node_ids[0]} = {
						 $attribs->{step_count} ? (steps => $attribs->{step_count}) : (),
						};
		return; # handled later
	    } else {
		our $MULTI_NODE_STEPS_WARNING_SEEN;
		if (!$MULTI_NODE_STEPS_WARNING_SEEN++) {
		    warn "No support for multi-node steps yet...";
		}
	    }
	}
	$attribs->{highway} = 'steps'; # not good: steps are in osm usually lines, not nodes!
    }
    if ($attribs) {
	get_node_ids($r, $attribs); # as a side-effect, create the nodes
    }
}

sub handle_blocked_way_like {
    my($r, $dir) = @_;
    my($cat, $cat_attribs) = $r->[Strassen::CAT] =~ m{^([^:]+)(?:::(.*))?};

    # Don't render if the output is map-only
    if ($optimize_for == OPTIMIZE_FOR_MAPNIK && ($cat_attribs||'') =~ /\bigndisp\b/) {
	return;
    }

    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };
    for my $node_id_i (1 .. $#node_ids) {
	if ($cat eq '1' || $cat eq '1s') {
	    $oneway{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1; # in osm oneway is the open direction, not the closed
	} elsif ($cat eq '2') {
	    $no_access{$node_ids[$node_id_i-1].' '.$node_ids[$node_id_i]} = 1;
	    $no_access{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1;
	}
    }
}

sub handle_handicap_like {
    my($r, $dir) = @_;
    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	($cat_hin, $cat_rueck) = ($r->[Strassen::CAT], $r->[Strassen::CAT]);
    }

    my($cat_attrib_hin, $cat_attrib_rueck);
    for my $def (
		 [\$cat_hin,   \$cat_attrib_hin],
		 [\$cat_rueck, \$cat_attrib_rueck],
		) {
	my($cat_ref, $cat_attrib_ref) = @$def;
	if (defined $$cat_ref) {
	    ($$cat_ref, $$cat_attrib_ref) = $$cat_ref =~ m{^
							   ([^:]+)
							   (?:::(.*))?
							   $}x;
	}
    }
    if (defined $cat_attrib_hin && $cat_attrib_hin =~ m{\bigndisp\b}) {
	# This is most likely generated from an "1s" record. Don't
	# render it, because we cannot distinguish between directions
	# in the osm output.
	return;
    }

    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };

    if ($optimize_for == OPTIMIZE_FOR_MAPNIK) {
	# no q3/q4 hacks for map display, please
    } else {
	# hack: %speed0 has information for downgrading a highway due
	# to speed limitations (bicycle only)
	for my $node_id_i (1 .. $#node_ids) {
	    if ($cat_hin =~ m{^[qQ][34]$}) {
		$speed0{$node_ids[$node_id_i-1].' '.$node_ids[$node_id_i]} = 1; # XXX correct direction
	    }
	    if (defined $cat_rueck) {
		if ($cat_rueck =~ m{^[qQ][34]$}) {
		    $speed0{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1;
		}
	    }
	}
    }

    for my $def (
		 ['Q', \@remember_quality],
		 ['q', \@remember_handicap],
		) {
	my($catprefix,$varref) = @$def;
	my($quality_hin) = $cat_hin =~ m{^\Q$catprefix\E(\d+)}; # note: no support for +/-
	my $quality = $quality_hin;
	if (defined $cat_rueck) {
	    my($quality_rueck) = $cat_rueck =~ m{^\Q$catprefix\E(\d+)}; # note: support for +/-?
	    if (defined $quality_rueck && (!defined $quality_hin || $quality_rueck > $quality_hin)) {
		$quality = $quality_rueck;
	    }
	}
	if (defined $quality) {
	    push @$varref, [\@node_ids, $quality];
	}
    }
}

sub handle_berlin_highway_like   { _handle_highway_like('Berlin', @_) }
sub handle_anywhere_highway_like { _handle_highway_like(undef, @_) }

sub _handle_highway_like {
    my($city, $r, $dir) = @_;

    my($cat, $cat_attribs) = $r->[Strassen::CAT] =~ m{^([^:]+)(?:::(.*))?};
    if ($cat eq 'Pl') {
	# XXX maybe handle later...
	return;
    }

    # Don't render if the output is map-only
    if ($optimize_for == OPTIMIZE_FOR_MAPNIK && ($cat_attribs||'') =~ /\bigndisp\b/) {
	return;
    }

    my $highway_tag = $cat_to_highway{$cat};
    if (!defined $highway_tag) {
	warn "Ignore cat='$r->[Strassen::CAT]'...\n";
	return;
    }

    my($name, @cityparts) = Strasse::split_street_citypart($r->[Strassen::NAME]);
    if (!@cityparts && defined $city && $city eq 'Berlin') {
	# Find citypart from PLZ.pm
	my $res = $street_to_citypart->{$name};
	if ($res) {
	    push @cityparts, keys %$res;
	}
    }

    my($ref_type, $ref_nr, $ref);
    if (defined $name) {
	($ref_type, $ref_nr) = Strasse::parse_street_type_nr($name);
	if (defined $ref_type) {
	    if ($ref_type eq 'BAB' || $ref_type eq 'B') {
		# Note: original osm data have "A " for motorways or
		# "B " for Bundestraßen prefixed. I deliberately do
		# NOT prefix anything, because this prefix is
		# superfluous in a map view --- the shield form is
		# enough to show the type of street
		$ref = $ref_nr;
	    }
	}
    }

    if ($optimize_for_mapnik_style == OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE) {
	if ($highway_tag eq 'motorway') {
	    if (defined $ref_type && $ref_type ne 'BAB') {
		$highway_tag = 'motorroad';
	    }
	}
    }

    my $tunnel;
    my $bridge;
    if ($cat_attribs) {
	if ($cat_attribs =~ m{Tu}) { # may be _Tu or Tu_, too
	    $tunnel = 1;
	} elsif ($cat_attribs =~ m{Br}) {
	    $bridge = 1;
	}
    }

    my @node_ids = get_node_ids($r);

    # split streets
    my @segments;
    my $last_tags;
    my @last_tags;
    my $begin_split_index = 0;
    for my $node_idx (1 .. $#node_ids) {
	my $forward_spec = $node_ids[$node_idx-1].' '.$node_ids[$node_idx];
	my $backward_spec = $node_ids[$node_idx].' '.$node_ids[$node_idx-1];
	my $in_steps = (exists $remember_steps{$node_ids[$node_idx]} ||
			exists $remember_steps{$node_ids[$node_idx-1]}
		       ) ? 1 : 0;
	my @this_tags = (
			 ($oneway{$forward_spec}||''),
			 ($oneway{$backward_spec}||''),
			 ($no_access{$forward_spec}||''),
			 ($speed0{$forward_spec}||''),
			 ($speed0{$backward_spec}||''),
			 $in_steps,
			);
	my $this_tags = join(" ", @this_tags);
	if (defined $last_tags) {
	    if ($last_tags ne $this_tags) {
		# we need to split
		push @segments, [[@node_ids[$begin_split_index..$node_idx-1]], [@last_tags]];
		$begin_split_index = $node_idx-1;
		$last_tags = $this_tags;
		@last_tags = @this_tags;
	    }
	} else {
	    $last_tags = $this_tags;
	    @last_tags = @this_tags;
	}
    }
    push @segments, [[@node_ids[$begin_split_index..$#node_ids]], [@last_tags]];

    # Usually the descriptive street names in the form "(A - B)" are
    # only clutter for the mapnik or garmin maps. Also the "[...]"
    # additions can be removed here.
    #
    # Theoretically these names could be used in garmin's address
    # search. But it seems that the longish "(A - B)" names are
    # winning over the shorter street names, so avoid them also here.
    if ($optimize_for == OPTIMIZE_FOR_GARMIN ||
	$optimize_for == OPTIMIZE_FOR_MAPNIK) {
	undef $name if $name =~ m{^\(.*\)$};
	if (defined $name) {
	    $name =~ s{\s+\[.*\]$}{};
	}
    }
    _xmlify($name);

    # This is the most reasonable scheme to set is_in/addr tags, to
    # get it best working in the "Find" screen of Garmin:
    #
    # for streets in Berlin (defined $city):
    # * is_in:county => "Berlin"
    # * addr:city => first citypart (if any)
    #
    # for streets outside Berlin (@cityparts exist)
    # * addr:city => first citypart (usually there is exactly one)
    #
    # If any of these tags is set, then also set addr:country
    my %is_in;
    if (defined $city) {
	$is_in{'is_in:county'} = $city; # XXX lying for Berlin, so we have cityparts in addr:city and Berlin in is_in:county XXX should be activated only for $optimize_for=garmin
	if (@cityparts) {
	    $is_in{'addr:city'} = $cityparts[0];
	}
    } else {
	if (@cityparts) {
	    $is_in{'addr:city'} = $cityparts[0];
	}
    }
    if (%is_in) {
	$is_in{'addr:country'} = 'DE'; # XXX not always true, some streets are in Poland and Czech Republic
    }

    for my $segment (@segments) {
	my @node_ids = @{$segment->[0]};
	my($oneway, $oneway_reversed, $no_access, $speed0, $speed0_reversed, $in_steps) = @{$segment->[1]};

	if ($oneway_reversed) {
	    @node_ids = reverse @node_ids;
	    $oneway = 1;
	}

	my $any_speed0 = $speed0 || $speed0_reversed; # XXX for the real thing I had to split the way into two directions...
	    
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	if (defined $name) {
	    print $wayfh qq{  <tag k="name" v="$name" />\n};
	}
	while(my($k,$v) = each %is_in) {
	    _xmlify($v);
	    print $wayfh qq{  <tag k="$k" v="$v" />\n};
	}
	if ($in_steps) {
	    print $wayfh qq{  <tag k="highway" v="steps" />\n};
	    ##XXX NYI:
	    #if ($steps =~ m{\d+}) {
	    #print $wayfh qq{  <tag k="step_count" v="$steps" />\n};
	    #}
	} elsif ($any_speed0) {
	    print $wayfh qq{  <tag k="highway" v="footway" />\n};
	    print $wayfh qq{  <tag k="bicycle" v="yes" />\n};
	} else {
	    if ($do_highway_primary_hack && $highway_tag =~ m{^(primary|secondary)$}) {
		print $wayfh qq{  <tag k="highway" v="tertiary" />\n};
		print $wayfh qq{  <tag k="bbbike:render" v="highway_${highway_tag}" />\n};
	    } else {
		print $wayfh qq{  <tag k="highway" v="$highway_tag" />\n};
	    }
	}
	if ($oneway) {
	    print $wayfh qq{  <tag k="oneway" v="yes" />\n};
	}
	if ($no_access) {
	    print $wayfh qq{  <tag k="access" v="no" />\n};
	    print $wayfh qq{  <tag k="bicycle" v="no" />\n}; # access=no is not enough
	}
	if ($tunnel) {
	    print $wayfh qq{  <tag k="tunnel" v="yes" />\n};
	}
	if ($bridge) {
	    print $wayfh qq{  <tag k="bridge" v="yes" />\n};
	}
	if ($ref) {
	    my $xml_ref = $ref; _xmlify($xml_ref);
	    print $wayfh qq{  <tag k="ref" v="$xml_ref" />\n};
	}

	if (0) {
	    print $wayfh qq{  <tag k="addr:street" v="$name" />\n};
	    print $wayfh qq{  <tag k="addr:housenumber" v="0" />\n}; # XXX pure faked
	    print $wayfh qq{  <tag k="addr:country" v="DE" />\n};
	    if (@cityparts) {
		# parse street numbers out
		@cityparts = grep {
		    my($type, $nr) = Strasse::parse_street_type_nr($_);
		    !defined $type;
		} @cityparts;
		if (@cityparts) {
		    _xmlify($cityparts[0]);
		    # XXX hack: use only first
		    print $wayfh qq{  <tag k="addr:city" v="$cityparts[0]" />\n};
		}
	    }
	}

	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub handle_fixme_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME] || 'FIXME';
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="FIXME" v="$name" />\n};
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_fixme_cat_like {
    my($r, $dir) = @_;
    my $cat = $r->[Strassen::CAT];

    my $attribs = { 'bbbike:fixme_cat' => $cat };

    get_node_ids($r, $attribs); # as a side-effect, create the nodes
}

sub handle_railway_like {
    my($r, $dir) = @_;

    my($cat, $cat_attribs) = $r->[Strassen::CAT] =~ m{^([^:]+)(?:::(.*))?};
    return if $cat !~ m{^([USR]|RP|RG)([ABC0]|Bau)?$};
    my $railway_cat = $cat_to_railway{$1};
    return if !defined $railway_cat;
    my $is_abandoned = defined $2 && $2 eq '0';
    my $is_construction = defined $2 && $2 eq 'Bau';

    my $tunnel;
    my $bridge;
    if ($cat_attribs) {
	if ($cat_attribs =~ m{Tu}) { # may be _Tu or Tu_, too
	    $tunnel = 1;
	} elsif ($cat_attribs =~ m{Br}) {
	    $bridge = 1;
	}
    }

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    print $wayfh qq{  <tag k="railway" v="$railway_cat" />\n};
    if ($is_abandoned) {
	print $wayfh qq{  <tag k="abandoned" v="yes" />\n};
    } elsif ($is_construction) {
	print $wayfh qq{  <tag k="construction" v="yes" />\n};
    }
    if ($tunnel) {
	print $wayfh qq{  <tag k="tunnel" v="yes" />\n};
    }
    if ($bridge) {
	print $wayfh qq{  <tag k="bridge" v="yes" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_waterway_like {
    my($r, $dir) = @_;

    my($is_area, $cat);
    if ($r->[Strassen::CAT] =~ m{^F:([^:]+)}) {
	$is_area = 1;
	$cat = $1;
    } else {
	$cat = $r->[Strassen::CAT] =~ m{^([^:]+)};
    }
    # XXX handling W0,W1 etc. missing

    my @node_ids = get_node_ids($r, undef, is_area => $is_area);

    my $name = format_waterway_label($r->[Strassen::NAME]);
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    if ($is_area) {
	print $wayfh qq{  <tag k="natural" v="water" />\n};
    } else {
	print $wayfh qq{  <tag k="waterway" v="river" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_ferry_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    print $wayfh qq{  <tag k="route" v="ferry" />\n};
    # XXX description from comments_ferry missing
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_ferry_info_like {
    my($r, $dir) = @_;

    my $label = shorten_label($r->[Strassen::NAME]);

    get_node_id_from_center($r, { note => $label });
}

sub handle_comments_scenic_like {
    my($r, $dir) = @_;
    my $cat = $r->[Strassen::CAT];
    if ($cat =~ m{^View(?:$|:)}) {
	my $label = shorten_label($r->[Strassen::NAME]);
	my $attribs = { tourism => 'viewpoint',
			name => $label,
		      };
	get_node_ids($r, $attribs); # as a side-effect, create the nodes
    } else {
	return;
    }
}

sub handle_area_like {
    my($r, $dir) = @_;

    if ($r->[Strassen::CAT] !~ m{^F:([^:|]+)(.*)}) {
	return; # should never happen
    }
    my($cat, $rest) = ($1, $2);
    my %tags;
    if ($rest =~ m{^\|(religion):(.*)$}) { # XXX could support more attributes here
	$tags{$1} = $2;
    }
    my($landuse, $leisure);
    $landuse = $cat_to_area_landuse{$cat};
    if (!defined $landuse) {
	$leisure = $cat_to_area_leisure{$cat};
	if (!defined $leisure) {
	    #warn "Ignoring $cat...\n";
	    return;
	}
    }

    my @node_ids = get_node_ids($r, undef, is_area => 1);
    push @node_ids, $node_ids[0] unless $node_ids[0] == $node_ids[$#node_ids];

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    if (defined $landuse) {
	print $wayfh qq{  <tag k="landuse" v="$landuse" />\n};
    } else {
	print $wayfh qq{  <tag k="leisure" v="$leisure" />\n};
    }
    while(my($k,$v) = each %tags) {
	_xmlify($k);
	_xmlify($v);
	print $wayfh qq{  <tag k="$k" v="$v" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_trafficsignals_like {
    my($r, $dir) = @_;
    my $cat = $r->[Strassen::CAT];

    my $attribs;
    if      ($cat =~ m{^X}) {
	$attribs = { highway => 'traffic_signals' };
    } elsif ($cat =~ m{^F}) {
	if ($optimize_for == OPTIMIZE_FOR_MAPNIK) {
	    if ($optimize_for_mapnik_style == OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE) {
		# Use a non-standard tag value here
		$attribs = { highway => 'traffic_signals_pedestrian' };
	    } else {
		# Treat LSA-X and LSA-F the same, otherwise LSA-F will not
		# be rendered at all in mapnik using default or german style.
		# This is because there's no "crossing" column in the
		# planet database.
		$attribs = { highway => 'traffic_signals' };
	    }
	} else {
	    $attribs = { highway => 'crossing', crossing => 'traffic_signals' };
	}
    } elsif ($cat =~ m{^B}) {
	$attribs = { railway => 'level_crossing',
		     ($cat =~ m{0$} ? (disused => 'yes') : ()), # not accurate, may be also seldomly used
		   };
    } else {
	# ignore
	return;
    }

    get_node_ids($r, $attribs); # as a side-effect, create the nodes
}

sub handle_zebrastreifen_like {
    my($r) = @_;
    get_node_ids($r, { highway => 'crossing',
		       crossing => 'uncontrolled',
		       crossing_ref => 'zebra',
		     });
}

sub handle_railway_stations_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $is_ubahn = $cat =~ m{^U};
    my $is_sbahn = $cat =~ m{^S};
    my $is_abandoned = $cat =~ m{0$};
    my $is_construction = $cat =~ m{Bau$};
    my $is_optimize_for_mapnik_bbbike_style = $optimize_for_mapnik_style == OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE;
    my $name = (
		$is_optimize_for_mapnik_bbbike_style
		? ''
		: ($is_ubahn ? 'U ' : $is_sbahn ? 'S ' : '')
	       ) . $r->[Strassen::NAME];
    ##XXX $is_construction handling for mapnik_bbbike_style is missing
    my $attribs = { railway => ($is_construction
				? 'construction'
				: 'station' # no distinction between halt and station
			       ),
		    ($is_abandoned ? ("abandoned" => "yes") : ()),
		    ($is_construction ? ("construction" => "station") : ()), # more construction-related attribs set later
		    name => $name,
		  };
    if      ($is_ubahn) {
	if ($is_optimize_for_mapnik_bbbike_style) {
	    $attribs->{railway} = 'station_subway';
	} else {
	    $attribs->{station} = 'subway';
	}
    } elsif ($is_sbahn) {
	if ($is_optimize_for_mapnik_bbbike_style) {
	    $attribs->{railway} = 'station_light_rail';
	} else {
	    $attribs->{station} = 'light_rail';
	}
    } elsif ($cat =~ m{^R}) {
	# Regional/Fernbahnhof
	if ($cat =~ m{^RP}) {
	    if ($optimize_for_mapnik_style == OPTIMIZE_FOR_MAPNIK_STYLE_BBBIKE) {
		$attribs->{railway} = 'station_narrow_gauge';
	    } else {
		$attribs->{'bbbike:station_type'} = 'RP';
	    }
	}
    } else {
	warn "Unhandled railway station-like category $cat\n";
	return;
    }

    if ($is_construction && $attribs->{station}) {
	$attribs->{'construction:station'} = delete $attribs->{station};
    }

    get_node_ids($r, $attribs);
}

sub handle_city_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $place;
    if      ($cat >= 5) {
	$place = 'city';
    } elsif ($cat >= 3) {
	$place = 'town';
    } elsif ($cat >= 1) {
	$place = 'village';
    } else {
	$place = 'hamlet';
    }
    get_node_ids($r, { name  => format_place_label($r->[Strassen::NAME]),
		       place => $place,
		     });
}

sub handle_city_limit_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $traffic_sign_name;
    if ($cat eq 'OS') {
	$traffic_sign_name = 'city_limit';
    } elsif ($cat eq 'OHT') {
	# kein offizielles OSM-Tag
	# englische Übersetzung von "Ortshinweistafel" aus:
	# http://de.wikipedia.org/wiki/Datei:Zeichen_385.svg
	$traffic_sign_name = 'locality_name';
    } else {
	warn "Unhandled city-limit like category '$cat'";
	return;
    }
    my $attribs = { traffic_sign => $traffic_sign_name,
		    name         => format_place_label($r->[Strassen::NAME]),
		  };
    get_node_ids($r, $attribs);
}

sub handle_berlin_citypart_like {
    if ($optimize_for == OPTIMIZE_FOR_GARMIN) {
	# XXX not sure if this is even necessary for the Garmin...
	my($r) = @_;
	my($sxy) = join ",", get_polygon_center(map { split/,/ } @{ $r->[Strassen::COORDS] });
	get_node_id($sxy, { place => 'suburb',
			    name  => $r->[Strassen::NAME],
			    'is_in:county' => 'Berlin',
			    'addr:country' => 'DE',
			  });
	# And add Berlin:
	if ($r->[Strassen::NAME] eq 'Mitte') {
	    get_node_id($sxy, { place => 'county', # XXX lying
				name  => 'Berlin',
				'addr:country' => 'DE',
			      });
	}
    }
}

sub handle_cycleway_like {
    my($r, $dir) = @_;
    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	($cat_hin, $cat_rueck) = ($r->[Strassen::CAT], $r->[Strassen::CAT]);
    }
    for ($cat_hin, $cat_rueck) {
	if (defined $_) {
	    ($_) = $_ =~ m{^([^:]+)};
	}
    }
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };

    my $extra_tags_for_dualdir = sub {
	my $extra_tags = '';
	my $hin_mandatory   = ($cat_hin||'') eq 'RW2';
	my $rueck_mandatory = ($cat_rueck||'') eq 'RW8';
	if ($hin_mandatory && $rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($hin_mandatory || $rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mixed" />\n};
	} elsif (!$hin_mandatory && !$rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} else {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	}
	$extra_tags;
    };

    for my $def ([$cat_hin, +1], [$cat_rueck, -1]) {
	my($cat, $direction) = @$def;
	next if !defined $cat || $cat eq '';
	my $extra_tags;
	# Check for Zweirichtungsradweg first
	if (($cat_hin||'') =~ m{^(RW|RW1|RW2|RW\?)$} && ($cat_rueck||'') =~ m{^(RW8|RW8\?|RW9|RW9\?)$}) {
	    if ($direction == +1) {
		$extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
		$extra_tags .= qq{  <tag k="bbbike:cycleway_type" v="dualdir" />\n};
		$extra_tags .= $extra_tags_for_dualdir->();
	    }
	} elsif (($cat_rueck||'') =~ m{^(RW|RW1|RW2|RW\?)$} && ($cat_hin||'') =~ m{^(RW8|RW8\?|RW9|RW9\?)$}) {
	    if ($direction == -1) {
		$extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
		$extra_tags .= qq{  <tag k="bbbike:cycleway_type" v="dualdir" />\n};
		$extra_tags .= $extra_tags_for_dualdir->();
	    }
	} elsif ($cat eq 'RW' || $cat eq 'RW?' || $cat eq 'RW8?') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	} elsif ($cat eq 'RW1' || $cat eq 'RW9') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} elsif ($cat eq 'RW2' || $cat eq 'RW8') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($cat eq 'RW3') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} elsif ($cat eq 'RW4') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($cat eq 'RW3?' || $cat eq 'RW4?') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	} elsif ($cat eq 'RW5') {
	    $extra_tags .= qq{  <tag k="psv" v="yes" />\n};
	    if ($r->[Strassen::NAME()] =~ m{Busspur (?:.*)?ist immer gültig}) {
		$extra_tags .= qq{  <tag k="bbbike:times" v="always" />\n};
	    }
	} elsif ($cat eq 'RW5?') {
	    $extra_tags .= qq{  <tag k="psv" v="yes" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:times" v="unknown" />\n};
	} elsif ($cat eq 'RW6') {
	    # living street XXX
	} elsif ($cat eq 'RW7') {
	    # Fahrradstraße XXX
	} elsif ($cat eq 'RW10') {
	    # Nebenfahrbahn XXX
	} elsif ($cat eq 'RW0') {
	    # kein Radweg
	} else {
	    warn "Unexpected category '$cat'...";
	}
	if ($extra_tags) {
	    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	    my @node_ids = $direction == +1 ? @node_ids : reverse(@node_ids);
	    for my $node_id (@node_ids) {
		print $wayfh qq{  <nd ref="$node_id"/>\n};
	    }
	    if ($optimize_for == OPTIMIZE_FOR_MAPNIK) {
		# avoid creating labels for cyclepaths
	    } else {
		my $name = $r->[Strassen::NAME];
		if (defined $name && $name ne '') {
		    _xmlify($name);
		    print $wayfh qq{  <tag k="name" v="$name" />\n};
		}
	    }
	    print $wayfh $extra_tags;
	    print $wayfh qq{</way>\n};
	    $next_way_id++;
	}
    }
}

## XXX very very experimental. will probably change
## i.e. ref should probably be the $nr, and image will be resolved somewhere else
## (in a template creating the mapnik include files)
sub handle_comments_route_like {
    my($r, $dir) = @_;
    if ($geo && $geo->can('parse_street_type_nr')) {
	my $name = $r->[Strassen::NAME];
	my($type, $nr, $do_round, $image) = $geo->parse_street_type_nr($r->[$name]);
	if (defined $type) {
	    my @node_ids = get_node_ids($r);
	    _xmlify($name);
	    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	    for my $node_id (@node_ids) {
		print $wayfh qq{  <nd ref="$node_id"/>\n};
	    }
	    print $wayfh qq{  <tag k="route" v="bicycle" />\n};
	    print $wayfh qq{  <tag k="name" v="$name" />\n};
	    if ($image) {
		_xmlify($image);
		print $wayfh qq{  <tag k="ref" v="$image" />\n};
	    }
	    print $wayfh qq{</way>\n};
	    $next_way_id++;
	}
    }
}

# See bbbike-aux/misc/mk-green-ampel-net.pl
sub handle_trafficlightmap_like {
    my($r, $dir) = @_;
    if ($r->[Strassen::CAT] !~ m{^(green|red)X;}) {
	warn "Unexpected category $r->[Strassen::CAT], ignoring...";
	return;
    }
    my $cat = $1;
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
#    print $wayfh qq{  <tag k="bbbike:trafficlightmap" v="$cat" />\n};
#    print $wayfh qq{  <tag k="bbbike:tlm" v="$cat" />\n};
    #XXX hack, reuse bus lane signature here
    if ($cat eq 'green') {
	print $wayfh qq{  <tag k="cycleway" v="lane" />\n};
	print $wayfh qq{  <tag k="bbbike:usage" v="mandatory" />\n};
    } elsif ($cat eq 'red') {
	print $wayfh qq{  <tag k="psv" v="yes" />\n};
	print $wayfh qq{  <tag k="bbbike:times" v="always" />\n};
    } else {
	die;
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_citypart_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r, undef, is_area => 1);
    push @node_ids, $node_ids[0] unless $node_ids[0] == $node_ids[$#node_ids];

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="admin_level" v="4" />\n};
    print $wayfh qq{  <tag k="boundary" v="administrative" />\n};
    print $wayfh qq{</way>\n};

    my @way_ids = $next_way_id;
    $next_way_id++;

    print $relationfh qq{<relation id="$next_relation_id">\n};
    for my $way_id (@way_ids) {
	print $relationfh qq{  <member type="way" ref="$way_id" role="outer" />\n};
    }
    print $relationfh qq{  <tag k="admin_level" v="10" />\n};
    print $relationfh qq{  <tag k="boundary" v="administrative" />\n};
    print $relationfh qq{  <tag k="name" v="$name" />\n};
    print $relationfh qq{  <tag k="name:prefix" v="Ortsteil" />\n};
    print $relationfh qq{  <tag k="place" v="suburb" />\n};
    print $relationfh qq{  <tag k="type" v="multipolygon" />\n};
    print $relationfh qq{</relation>\n};

    $next_relation_id++;
}

seek $nodefh, 0, SEEK_SET
    or die $!;
seek $wayfh, 0, SEEK_SET
    or die $!;
seek $relationfh, 0, SEEK_SET
    or die $!;

binmode STDOUT, ':utf8';
print qq{<osm version="0.6" generator="bbd2osm">\n};
print qq{<bound box="$min_lat,$min_lon,$max_lat,$max_lon" origin="http://www.bbbike.de" />\n};
while(<$nodefh>) {
    print $_;
}
while(<$wayfh>) {
    print $_;
}
while(<$relationfh>) {
    print $_;
}
print qq{</osm>\n};

sub get_node_ids {
    my($r, $attribs, %opts) = @_;
    my @node_ids;
    for my $sxy (@{ $r->[Strassen::COORDS] }) {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
	my $this_node_id = maybe_add_node($px, $py, $attribs);
	push @node_ids, $this_node_id;
    }
    if ($opts{is_area}) {
	if ($r->[Strassen::COORDS][0] ne $r->[Strassen::COORDS][-1]) {
	    push @node_ids, $node_ids[0];
	}
    }
    @node_ids;
}

sub get_node_id {
    my($sxy, $attribs) = @_;
    my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
    maybe_add_node($px, $py, $attribs);
}

sub get_node_id_from_center {
    my($r, $attribs) = @_;
    my $c = $r->[Strassen::COORDS];
    my $sxy;
    if (@$c % 2 == 1) {
	$sxy = $c->[@$c/2];
    } else {
	my($x0,$y0) = split /,/, $c->[@$c/2 - 1];
	my($x1,$y1) = split /,/, $c->[@$c/2];
	$sxy = (($x1-$x0)/2+$x0) . ',' . (($y1-$y0)/2+$y0);
    }
    my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
    maybe_add_node($px, $py, $attribs);
}

sub maybe_add_node {
    my($px, $py, $attribs) = @_;
    my $pxy = $px.','.$py;
    my $this_node_id = $node_id{$pxy};
    if (!defined $this_node_id) {
	$this_node_id = $node_id{$pxy} = $next_node_id++;
	print $nodefh qq{<node id="$this_node_id" lat="$py" lon="$px" user="eserte" visible="true" };
	if ($attribs) {
	    print $nodefh qq{>\n};
	    while(my($k,$v) = each %$attribs) {
		_xmlify($k);
		_xmlify($v);
		print $nodefh qq{  <tag k="$k" v="$v"/>\n};
	    }
	    print $nodefh qq{</node>\n};
	} else {
	    print $nodefh qq{/>\n};
	}

	$min_lon = $px if !defined $min_lon || $min_lon > $px;
	$max_lon = $px if !defined $max_lon || $max_lon < $px;
	$min_lat = $py if !defined $min_lat || $min_lat > $py;
	$max_lat = $py if !defined $max_lat || $max_lat < $py;

    }
    $this_node_id;
}

sub _xmlify {
    return if !defined $_[0];
    $_[0] =~ s{&}{&#38;}g; # XXX hack to xml-ify
    $_[0] =~ s{"}{&#34;}g;
    $_[0] =~ s{<}{&#60;}g;
    $_[0] =~ s{>}{&#62;}g;
}

sub dump_quality {
    for my $def (@remember_quality) {
	my($node_ids, $quality) = @$def;
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@$node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	print $wayfh qq{  <tag k="bbbike:quality" v="Q$quality" />\n};
	my $smoothness = $bbbikequality_to_smoothness{$quality};
	if ($smoothness) {
	    print $wayfh qq{  <tag k="smoothness" v="$smoothness" />\n};
	} else {
	    warn "Cannot map quality '$quality' to smoothness level";
	}
	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub dump_handicap {
    for my $def (@remember_handicap) {
	my($node_ids, $handicap) = @$def;
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@$node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	print $wayfh qq{  <tag k="bbbike:handicap" v="q$handicap" />\n};
	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub shorten_label {
    my $s = shift;
    if ($shorten_for_garmin) {
	my $abbrev_level = 1;
	while (length $s > MAX_LABEL_LENGTH) {
	    if ($abbrev_level > MAX_LABEL_LENGTH) {
		$s =~ s{$ABBREV_WORD_RX}{$ABBREV_WORD_DEFS{$1}}g;
		if (length $s > MAX_LABEL_LENGTH) {
		    warn "Label <$s> too long and may not be shortened further...\n" if $debug;
		}
		last;
	    }
	    $s = Strasse::short($s, $abbrev_level);
	    $abbrev_level++;
	}
    }
    $s;
}

sub format_place_label {
    my $s = shift;
    my($name, $add) = split /\|/, $s;
    $name . (defined $add ? ' ' . $add : '');
}

sub format_waterway_label {
    my $s = shift;
    if ($optimize_for == OPTIMIZE_FOR_MAPNIK) {
	if (defined $s) {
	    $s =~ s{\|.*}{};
	}
    }
    $s;
}

__END__

=head1 NAME

bbd2osm - generate osm files out of bbd files

=head1 SYNOPSIS

Convert a whole bbbike data directory. For the default data directory
use

    bbd2osm > out.osm

For a specified data directory use

    bbd2osm /path/to/datadir > out.osm

For a single bbd file use

    bbd2osm -single in.bbd -type ... > out.osm

Refer to the usage for allowed types.

=head1 DESCRIPTION

=head2 Garmin optimizations

With the switch C<< -optimize-for=garmin >> some optimizations for
later usage with mkgmap are done:

=over

=item * steps support

mkgmap expect multi-node steps, where the original BBBike data has
only one-node steps. In this mode a hack is done to create multi-node
step segments, which exceed to the neighboring nodes.

=item * shorten labels

Maximum length on Garmin devices (verified on etrex Vista HCX) is 151.
There are some heuristics used to abbreviate some common (german)
words. Also the function L<Strasse/short> is called with the
abbreviation level 4.

=back

=head2 Mapnik optimizations

With the switch C<< -optimize-for=mapnik >> some optimizations for
later usage with mapnik (and the default osm styles) are done:

=over

=item * No q3/q4 hacks are done here

=item * Street names in "(...)" are not rendered

=item * Street name parts in "[...]" are stripped

=item * Special pedestrian traffic lights handling needed

=item * Remove "|..." part in waterways

=back

The switch C<< -optimize-for=mapnik-bbbike >> turns on optimization if
using mapnik with the special bbbike style:

=over

=item * For pedestrian-only traffic lights use the non-standard tag
value "traffic_signals_pedestrian"

=item * Railway stations may have the non-standard tag values
"station_subway", "station_light_rail", or "station_narrow_gauge"

=back

=head2 TODO

Currently the way and node ids start at 1 and increment by one. This
means clashes are possible if these data and "real" osm is mixed.
Maybe I should check if the various osm tools can handle negative or
non-numeric ids, or if there's a private id range documented.

Implement handling of BNP:...

Do again some testing and work for the C<$do_highway_primary_hack>.
The Garmin seems aggressively avoid all primary and secondary highways
when doing routing for cyclists, leading to strange routes, at least
when trying it in Berlin. The idea was to render primary and secondary
roads, but to have internally a lower class, e.g. tertiary. First
tests were not successful, though...

=head1 AUTHOR

Slaven Rezic

=cut
