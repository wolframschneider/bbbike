#!/usr/local/bin/perl
#
# osm2bbd-poi - for a point of interest (POI), find the nearest cross
#
# env CITY=data-osm/Berlin ./miscsrc/osm2bbd-poi data-osm/Berlin 13.2840194,52.5585

use vars qw($VERSION);
$VERSION = 0.1;

BEGIN {
    $ENV{'BBBIKE_DATADIR'} = $ENV{'DATA_DIR'} = $ENV{CITY};
}

use Getopt::Long;
use CGI;
use Data::Dumper;

use lib '.';
use lib 'lib';
use Karte::Polar;
use Strassen;
use Strassen::Dataset;

use strict;
use warnings;

my $debug = 1;
my @poi_files =
  qw( _education _oepnv faehren icao kinos kneipen orte rbahnhof restaurants sbahnhof sehenswuerdigkeit ubahnhof);

#push @poi_files, "_building";

my $use_exact_streetchooser = 1;
my $use_cooked_street_data;
my $use_polar     = 1;
my $data_is_wgs84 = 1;

my $q = new CGI;
my $kr;
my $str;
my $crossings;
my $g_str;

if ($use_polar) {
    no warnings 'redefine';

    require Strassen::Util;
    *Strassen::Util::strecke   = \&Strassen::Util::strecke_polar;
    *Strassen::Util::strecke_s = \&Strassen::Util::strecke_s_polar;
    if ( defined &StrassenNetz::make_net_PP ) {
        *StrassenNetz::make_net = \&StrassenNetz::make_net_PP;
    }
}

sub new_kreuzungen {
    if ( !$kr ) {
        all_crossings();
        my $str = get_streets();
        $kr = new Kreuzungen(
            Hash     => $crossings,
            Strassen => $str
        );
        $kr->make_grid( UseCache => 1 );
    }
    $kr;
}

sub all_crossings {
    if ( scalar keys %$crossings == 0 ) {
        my $str = get_streets();
        $crossings = $str->all_crossings(
            RetType  => 'hash',
            UseCache => 1
        );
    }
}

sub get_streets {
    my ($scope) = shift || $q->param("scope") || "city";
    $scope =~ s/^all,//;
    if ( $g_str && $g_str->{Scope} eq $scope ) {
        return $g_str;
    }
    my @f = (
        "strassen",
        ( $scope =~ /region/ ? "landstrassen" : () ),
        ( $scope eq 'wideregion' ? "landstrassen2" : () ),
    );

    if ( $q->param("addnet") ) {
        for my $addnet ( $q->param("addnet") ) {
            if ( $addnet =~ /^(?:  )$/x ) {    # no addnet support for now
                push @f, $addnet;
            }
        }
    }

    # XXX do not use Strassen::StrassenNetz::add_faehre, so better
    # display in route list is possible
    if ( defined $q->param('pref_ferry') && $q->param('pref_ferry') eq 'use' ) {
        push @f, 'faehren';
    }

    # Should be last:
    if ( defined $q->param("pref_fragezeichen")
        && $q->param("pref_fragezeichen") eq 'yes' )
    {
        push @f, "fragezeichen";
    }

    my $use_cooked_street_data = $use_cooked_street_data;
    while (1) {
        my @f = @f;
        if ($use_cooked_street_data) {
            @f = map {

                # Note: no "cooked" version for faehren available
                $_ eq "faehren" ? $_ : "$_-cooked"
            } @f;
        }
        eval {
            if ( @f == 1 )
            {
                $g_str = new Strassen $f[0];
            }
            else {
                $g_str = new MultiStrassen @f;
            }
        };
        if ($@) {
            if ($use_cooked_street_data) {
                warn
qq{Maybe the "cooked" version for <@f> is missing? Try again the normal version...};
                $use_cooked_street_data = 0;
                next;
            }
            else {
                die $@;
            }
        }
        last;
    }
    $g_str->{Scope} = $scope;

    if ( !$use_cooked_street_data ) {
        my $i_s;
        eval { $i_s = new Strassen "inaccessible_strassen" };
        if ($i_s) {
            $g_str = $g_str->new_with_removed_points($i_s);
            $g_str->{Scope} = $scope;
        }
    }

    $crossings = {};

    $g_str;
}

sub get_nearest_crossing_coords {
    my ( $x, $y ) = @_;
    new_kreuzungen();
    my $xy;
    while (1) {
        if ($use_exact_streetchooser) {
            my $str = get_streets();
            my $ret = $str->nearest_point( "$x,$y", FullReturn => 1 );
            $xy = $ret->{Coord};

            print Dumper($ret) if $debug >= 2;

            if ( $xy && !$kr->crossing_exists($xy) ) {

         # This may happen, because nearest_point does also return Kurvenpointe,
         # whereas $kr has only real Kreuzungen. Find a real Kreuzung...
                my @street_coords =
                  @{ $ret->{StreetObj}->[ Strassen::COORDS() ] || [] };

                # find this point in @street_coords
                my $start_index = 0;
                for ( ; $start_index <= $#street_coords ; $start_index++ ) {
                    last if ( $street_coords[$start_index] eq $xy );
                }
                if ( $start_index > $#street_coords ) {

                    # This may happen if there's really no "nearest point".
                    # Hopefully we'll get one after incrementing the scope,
                    # see below.
                }
                else {
                    my $before_xy;
                    my $after_xy;
                    for ( my $i = $start_index - 1 ; $i >= 0 ; $i-- ) {
                        if ( $kr->crossing_exists( $street_coords[$i] ) ) {
                            $before_xy = $street_coords[$i];
                            last;
                        }
                    }
                    for (
                        my $i = $start_index + 1 ;
                        $i <= $#street_coords ;
                        $i++
                      )
                    {
                        if ( $kr->crossing_exists( $street_coords[$i] ) ) {
                            $after_xy = $street_coords[$i];
                            last;
                        }
                    }
                    if ( !$before_xy && !$after_xy ) {
                        warn
"Harmless? Cannot find any real crossing in <@street_coords>\n"
                          ;    #, scope is <@{[ $q->param('scope') ]}>";
                    }
                    else {
                        if ( $after_xy && $before_xy ) {

                            # choose nearest
                            if (
                                Strassen::Util::strecke_s(
                                    "$x,$y", $before_xy
                                ) <
                                Strassen::Util::strecke_s( "$x,$y", $after_xy )
                              )
                            {
                                $xy = $before_xy;
                            }
                            else {
                                $xy = $after_xy;
                            }
                        }
                        elsif ($before_xy) {
                            $xy = $before_xy;
                        }
                        elsif ($after_xy) {
                            $xy = $after_xy;
                        }
                    }
                }

            }
        }
        else {
            $xy = ( ( $kr->nearest_loop( $x, $y ) )[0] );
        }
        last if defined $xy;
        my $new_scope = increment_scope();
        last if !defined $new_scope;
        get_streets_rebuild_dependents();
    }

    $xy;
}

# Increment scope and return the new scope, or undef if the largest scope
# is already used. Call get_streets_rebuild_dependents after.
sub increment_scope {
    my $scope = $q->param("scope") || "";
    if ( $scope eq "" || $scope eq "city" ) {
        $scope = "region";
    }
    elsif ( $scope eq "region" ) {
        $scope = "wideregion";
    }
    else {
        return undef;
    }
    $q->param( "scope", $scope );
    $scope;
}

sub get_streets_rebuild_dependents {

    #$g_str = get_streets();
}

sub get_poi {
    my @files = @_;

    my @points;
    foreach my $file (@files) {
        $file = $ENV{'BBBIKE_DATADIR'} . "/$file";

        if ( !-f $file ) {
            warn "$file does not exists, skip...\n" if $debug >= 1;
            next;
        }

        my $fh;
        if ( $file =~ /\.gz$/ ) {
            open $fh, '-|', 'gzip', '-dc', $file
              or die "Can't run zcat on $file: $!";
        }
        else {
            open $fh, $file or die "open file '$file': $!\n";
        }

        my @p = get_poi_fh($fh);
        push( @points, @p ) if scalar(@p);
    }

    return @points;
}

sub get_poi_fh {
    my $fh = shift;
    binmode $fh, ":utf8";

    my @p;
    while (<$fh>) {
        next if /^\s*#/;
        next if /^\s+/;
        next if /^\s*$/;

        my ( $poi, $rest ) = split "\t", $_;

        my ( $type, $first_coord, @coords ) = split " ", $rest;
        $type =~ s/:.*//;

        push @p, [ $poi, $type, $first_coord ];
    }

    return @p;
}

sub usage () {
    <<EOF;
usage: env CITY=city $0 [ options ] poi

--debug=0..2      debug level, default $debug
--poi-file file	  files with points of interests
EOF
}

binmode \*STDIN,  ":utf8";
binmode \*STDOUT, ":utf8";
binmode \*STDERR, ":utf8";

my $help;
my $ret = GetOptions(
    "debug=i"    => \$debug,
    "poi-file=s" => \@poi_files,
    "help"       => \$help
);

die usage if $help || !$ret;

my @points;

# 13.2840194,52.5585185
if ( $ARGV[0] ) {
    push @points, [ "foo", "X", $ARGV[0] ];
}
else {
    push @points, &get_poi(@poi_files);
}

foreach my $poi (@points) {
    my ( $x, $y ) = split( ",", $poi->[2] );

    my $point = get_nearest_crossing_coords( $x, $y ) || "";
    print $poi->[0], " ", $poi->[1], " $point\n";
}

