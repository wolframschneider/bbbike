#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: check_points,v 1.13 2004/09/04 12:52:40 eserte Exp eserte $
# Author: Slaven Rezic
#
# Copyright (C) 1998,2004 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: eserte@users.sourceforge.net
# WWW:  http://bbbike.sourceforge.net
#

# Überprüft, ob alle Punkte aus der ersten Datei in min. einer der folgenden
# Dateien vorkommt (z.B. alle Ampeln müssen in Straßen vorhanden sein...)

package BBBike::check_points;

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
use Strassen::Core;
use Strassen::MultiStrassen;
use Strassen::Kreuzungen;
use Getopt::Long;

use vars qw(%str_obj %hash);

@Strassen::datadirs = ("$FindBin::RealBin/../data");

sub doit {
    local(@ARGV) = @_;

    my $ampelschaltung_source;
    my $ampelschaltung2_source;
    my $warn; # warn only instead of failing
    my $usecache = 1;
    my $usememcache = 1;
    my $q;
    my $do_report = 0;

    GetOptions("ampelschaltung!" => \$ampelschaltung_source,
	       "ampelschaltung2!" => \$ampelschaltung2_source,
	       "warn!" => \$warn,
	       "cache!" => \$usecache,
	       "memcache!" => \$usememcache,
	       "q|quiet!" => \$q,
	       "report!" => \$do_report,
	      ) or die <<EOF;
usage: $0 [-ampelschaltung] [-ampelschaltung2] [-[no]warn] [-[no]cache]
          [-[no]keepnet] [-[no]quiet | -q] [-report] checkfile againstfile ...
EOF

    my $file = shift @ARGV || die "file to check missing";
    my(@check) = @ARGV;
    if (!@ARGV) {
	die "files to check against missing!";
    }

    my $s1;
    if ($ampelschaltung_source ||
	$ampelschaltung2_source) {
	# no usememcache for this one
	$s1 = new Strassen;
	open(D, $file) or die "Can't open $file: $!";
	while(<D>) {
	    next if /^#/;
	    chomp;
	    my @l;
	    if ($ampelschaltung_source) {
		@l = split(/\t/o, $_);
	    } else {
		if (/^(\d+,\d+)\s+(\S+)/) {
		    @l = ($1, $2);
		} else {
		    next;
		}
	    }
	    push @{ $s1->{Data} }, "$l[1]\tX $l[0]";
	}
	close D;
    } else {
	if ($usememcache && $str_obj{$file}) {
	    $s1 = $str_obj{$file};
	} else {
	    $s1 = new Strassen $file;
	}
	if ($usememcache && !$str_obj{$file}) {
	    $str_obj{$file} = $s1;
	}
    }

    my $s2;
    my $check_token = join("_", sort @check);
    if ($usememcache && $hash{$check_token}) {
	$s2 = $hash{$check_token};
    } else {
	if ($usecache) {
	    my $check_str = MultiStrassen->new(@check);
	    my $cr = Kreuzungen->new(Strassen => $check_str,
				     UseCache => 1,
				     Kurvenpunkte => 1,
				     RetType => 'hash',
				    );
	    $s2 = $cr->{Hash};
	} else {
	    foreach my $checkfile (@check) {
		my $str2 = new Strassen $checkfile;
		$str2->init;
		while(1) {
		    my $ret = $str2->next;
		    last if !@{$ret->[1]};
		    foreach (@{$ret->[1]}) {
			$s2->{$_}++;
		    }
		}
	    }
	}
	if ($usememcache) {
	    $hash{$check_token} = $s2;
	}
    }

    my @error_points;
    my $fail = 0;
    $s1->init;
    while(1) {
	my $ret = $s1->next;
	last if !@{$ret->[1]};
	my @error;
	foreach (@{$ret->[1]}) {
	    if (!exists $s2->{$_} && $_ ne '*') {
		push(@error, $_);
	    }
	}
	if (@error) {
	    print STDERR "Error in $ret->[0]: " . join(" ", @error) . "\n" unless $q;
	    $fail++ unless $warn;
	    push @error_points, @error if $do_report;
	}
    }

    if ($do_report && @error_points) {
	my $line = 1;
	print join("\n", map { ($line++) . "\tX $_" } @error_points), "\n";
    }

    return ($fail ? 1 : 0);
}

return 1 if caller;

exit doit(@ARGV);

