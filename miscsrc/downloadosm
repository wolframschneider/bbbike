#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: downloadosm,v 1.19 2009/01/24 22:31:18 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2008,2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Download a data from openstreetmap into the specified directory
# (option -o). The dataset may be used by osm2bbd for further
# conversion.

# Call script without arguments for usage.

use strict;
use FindBin;
use lib "$FindBin::RealBin/..";

use File::Basename qw(dirname);
use File::Glob qw(bsd_glob);
use Getopt::Long;
use LWP::UserAgent;

use BBBikeUtil qw(is_in_path);

sub save_pwd (&);

our $VERSION = "0.02";

use constant TIMEOUT => 600;

my $ua = eval {
    require LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("downloadosm/$VERSION LWP/$LWP::VERSION [part of BBBike]");
    $ua->default_headers->push_header("Accept-Encoding" => "gzip");
    $ua->timeout(TIMEOUT);
    $ua;
};
if ($@) {
    warn "Cannot load LWP::UserAgent, will fallback to wget or curl...\n";
}

my $debug = 1;
my $do_reload;
my $min_age;
my $n;
my $o;
my $xstep = 0.01;
my $ystep = 0.01;

sub usage () {
    die <<EOF;
usage: $0 -o directory x0 y0 x1 y1
       $0 -reload existing.osm ...

First form:  specify a bbox (four parameters, x0 y0 x1 y1)
Second form: refresh existing osm files downloaded with this tool
             Alternatively specify a directory containing osm files

-n:        no exec
-debug i:  set debugging/verbosity level (default=$debug)
-xstep x:  set steps on the x axis (default=$xstep)
-ystep y:  set steps on the y axis (default=$ystep)
-step  xy: set steps for both the x and y axis

With -reload:
-minage days: download only files which are older than days days
              handy if a download process aborted and should be
              restarted

For all of Berlin use:
    $0 13.010982 52.337651 13.761388 52.675354
EOF
}

GetOptions("reload!" => \$do_reload,
	   "minage=i" => \$min_age,
	   "o=s" => \$o,
	   "debug=i" => \$debug,
	   "n" => \$n,
	   "xstep=f" => \$xstep,
	   "ystep=f" => \$ystep,
	   "step=f" => sub {
	       $xstep = $ystep = $_[1];
	   },
	  )
    or usage;
my @reload;
if ($do_reload) {
    @reload = @ARGV;
    if (!@reload) {
	die "Please specify .osm files to reload!";
    }
} else {
    if (!@ARGV) {
	usage;
    }
}

if (@reload == 1 && -d $reload[0]) {
    @reload = bsd_glob("$reload[0]/*.osm");
}

if (@reload) {
    if ($min_age) {
	@reload = grep { -M $_ >= $min_age || -z $_ } @reload;
    }
    for my $reload (@reload) {
	if (!-r $reload) {
	    die "The file <$reload> does not exist or is not readable.\n";
	}
    }
    for my $reload (@reload) {
	my $ltlnqr = qr{[-+]?\d+\.\d+};
	if ($reload !~ m{($ltlnqr),($ltlnqr),($ltlnqr),($ltlnqr)\.osm$}) {
	    die "The file name <$reload> does not look correct, i.e. created by this tool.\n";
	}
	my($x,$y,$xend,$yend) = ($1,$2,$3,$4);
	save_pwd {
	    my $dir = dirname($reload);
	    chdir $dir
		or die "Can't chdir to $dir: $!";
	    download_osm_tile($x,$y,$xend,$yend, 1);
	};
    }
} else {
    my @bbox = @ARGV;
    if (@bbox == 2) { # assume x1,y1 x2,y2
	@bbox = ((split /,/, $bbox[0]),
		 (split /,/, $bbox[1])
		);
	if (grep { !defined $_ } @bbox) {
	    die "Input arguments does not seem to be in format x1,y1 x2,y2";
	}
    }
    if (@bbox != 4) {
	usage;
    }
    if (!$o) {
	warn "-o option is missing\n";
	usage;
    }
    if (!-d $o) {
	warn "Creating directory $o...\n" if $debug;
	mkdir $o;
    }
    chdir $o
	or die "Cannot change to directory $o: $!\n";

    my($x1,$y1,$x2,$y2) = @bbox;

    ($x1,$x2) = ($x2,$x1) if $x1 > $x2;
    ($y1,$y2) = ($y2,$y1) if $y1 > $y2;

    use constant FIXPOINTS => 6;
    my $xstep_fix = FixPoint->new($xstep, FIXPOINTS);
    my $ystep_fix = FixPoint->new($ystep, FIXPOINTS);
    my $x1_fix    = FixPoint->new($x1, FIXPOINTS);
    my $x2_fix    = FixPoint->new($x2, FIXPOINTS);
    my $y1_fix    = FixPoint->new($y1, FIXPOINTS);
    my $y2_fix    = FixPoint->new($y2, FIXPOINTS);

    for(my $x_fix = $x1_fix; $x_fix <= $x2_fix; $x_fix+=$xstep_fix) {
	for(my $y_fix = $y1_fix; $y_fix <= $y2_fix; $y_fix+=$ystep_fix) {
	    my $xend_fix = $x_fix+$xstep_fix;
	    my $yend_fix = $y_fix+$ystep_fix;
	    download_osm_tile($x_fix->numify,$y_fix->numify,$xend_fix->numify,$yend_fix->numify, 0);
	} 
    }
}

sub download_osm_tile {
    my($x,$y,$xend,$yend, $reload) = @_;
    my $url = "http://www.openstreetmap.org/api/0.5/map?bbox=$x,$y,$xend,$yend";
    my $dest = "download_$x,$y,$xend,$yend.osm";
    if ((-s $dest || -s "$dest.gz") && !$reload) {
	warn "$dest already exists, skipping...\n" if $debug;
    } else {
	if ($ua) {
	    if ($n) {
		warn "Would mirror $url to $dest\n";
	    } else {
		if ($debug >= 1) {
		    warn "Mirroring $url -> $dest...\n";
		}
		my $resp = $ua->mirror($url, $dest);
		if (!$resp->is_success) {
		    die "No success while mirroring '$url' to '$dest': " . $resp->status_line;
		} else {
		    if ($resp->header('content-encoding') eq 'gzip' && $dest !~ m{\.gz$}) {
			if ($debug >= 1) {
			    warn "Rename $dest -> $dest.gz...\n";
			}
			rename $dest, "$dest.gz"
			    or die "Cannot rename $dest to $dest.gz: $!";
		    }
		}
	    }
	} else {
	    my @cmd;
	    if ($ua) {
	    } elsif (is_in_path("wget")) {
		@cmd = ('wget', '--timeout=' . TIMEOUT);
		push @cmd, '--verbose' if $debug >= 2;
		push @cmd, '-O', $dest, $url;
	    } elsif (is_in_path("curl")) {
		@cmd = ('curl', '-s', '-S', '-f', '-m', TIMEOUT); 
		push(@cmd, '--verbose') if $debug >= 2;
		push(@cmd, ('-o', $dest, $url));
	    } else {
		die "Neither wget nor curl available, cannot proceed";
	    }

	    if ($n) {
		warn "Would: @cmd\n";
	    } else {
		system(@cmd) == 0
		    or die "Failed while running <@cmd>: $?";
	    }
	}
    }
}

{
    package FixPoint;
    use overload
	'+'  => 'add',
	'0+' => 'numify',
	'fallback' => 1,
	;
    sub new {
	my($class, $number, $prec) = @_;
	$prec = 0 if !defined $prec;
	$number *= 10**$prec;
	bless [$number, $prec], $class;
    }
    sub add {
	my($self, $other) = @_;
	die "NYI" if $self->[1] != $other->[1];
	bless [$self->[0] + $other->[0], $self->[1]], ref $self;
    }
    sub numify {
	my($self) = @_;
	$self->[0] / 10**$self->[1];
    }
}

# REPO BEGIN
# REPO NAME save_pwd /home/e/eserte/work/srezic-repository 
# REPO MD5 0f7791cf8e3b62744d7d5cfbd9ddcb07
sub save_pwd (&) {
    my $code = shift;
    require Cwd;
    my $pwd = Cwd::cwd();
    eval {
	$code->();
    };
    my $err = $@;
    chdir $pwd or die "Can't chdir back to $pwd: $!";
    die $err if $err;
}
# REPO END

__END__
