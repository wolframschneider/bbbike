#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: check_bbbike_temp_blockings,v 1.18 2004/09/07 23:05:39 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2003, 2004 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

package BBBike::check_bbbike_temp_blockings;

use strict;
use vars qw(@temp_blocking);
use FindBin;
use Data::Dumper qw(Dumper);
use Getopt::Long;
use POSIX qw(strftime);

use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
use Strassen::Core;

use vars qw($temp_blockings_dir $temp_blockings_pl);

my $do_output_files;
my $check_net = 1;
my $v;
#my $temp_blockings_dir = "$FindBin::RealBin/../misc/temp_blockings";
if (!defined $temp_blockings_dir) {
    for my $test ("$FindBin::RealBin/data/temp_blockings",
		  "$FindBin::RealBin/../data/temp_blockings",
		 ) {
	if (-d $test) {
	    $temp_blockings_dir = $test;
	    last;
	}
    }
    warn "Can't find temp_blockings directory" if !$temp_blockings_dir;
}
$temp_blockings_pl  = "$temp_blockings_dir/bbbike-temp-blockings.pl"
    if !defined $temp_blockings_pl;
my $file = $temp_blockings_pl;

my $longest_file_length;

sub process {
    local @ARGV = @_;

    if (!GetOptions("outputfiles" => \$do_output_files,
		    "f=s" => \$file,
		    "checknet!" => \$check_net,
		    "v+" => \$v,
		   )) {
	die "usage";
    }
    if (defined $v && $v >= 2) {
	Strassen::set_verbose($v - 1);
    }
}

sub load_file {
    if (!-r $file) {
	die "$file is not readable";
    }
    @temp_blocking = ();
    do $file;
    if (!@temp_blocking) {
	system($^X, "-c", $file);
	die "No \@temp_blocking variable in $file found (perl check returned $?)";
    }
}

sub run_checks {
    for my $o (@temp_blocking) {
	next if !$o; # undefined entry
	if (!exists $o->{from} || !exists $o->{until} ||
	    (!exists $o->{file} && !exists $o->{data}) ||
	    !exists $o->{text}) {
	    die "Incomplete definition: " . Dumper($o);
	}
	if (exists $o->{type} && $o->{type} !~ /^(handicap|gesperrt)$/) {
	    die "Unknown type $o->{type}: " . Dumper($o);
	}
	if (defined $o->{from} && defined $o->{until} &&
	    $o->{from} > $o->{until}) {
	    die "Interval mismatch: " . Dumper($o);
	}

	my $str_obj;
	my $full_path;
	if ($o->{file}) {
	    $full_path = "$temp_blockings_dir/$o->{file}";
	    if (!-e $full_path) {
		die "File $full_path is missing: " . Dumper($o);
	    }
	    if (!((stat($full_path))[2] & 0004)) {
		warn "File $full_path is not readable for world";
	    }
	} elsif ($o->{data}) {
	    eval { 
		$str_obj = Strassen->new_from_data_string($o->{data});
	    };
	    if ($@) {
		warn "Corrupt data for $o->{from} - $o->{until}";
	    }
	}

	# Checks only for future blockings
	if ($check_net && (!defined $o->{until} || $o->{until} > time)) {
	    my $name = _get_name($o);
	    warn "Check $name...\n" if $v;

	    $longest_file_length = length $name
		if !defined $longest_file_length || length $name > $longest_file_length;

	    if ($o->{data} && $str_obj) {
		require File::Temp;
		(my($fh), $full_path) = File::Temp::tempfile(SUFFIX => ".bbd",
							     UNLINK => 1);
		$str_obj->write($full_path);
	    }

	    # Checks for now restricted to Berlin
	    warn "  Check points...\n" if $v;
	    require "$FindBin::RealBin/check_points";
	    my $ret = BBBike::check_points::doit("-q", "-memcache", $full_path, "strassen");
	    if ($ret != 0) {
		# Otherwise do a full region check
		warn "  Check points (wide region)...\n" if $v;
		$ret = BBBike::check_points::doit
		    ("-memcache", $full_path, "strassen", "landstrassen", "landstrassen2");
		if ($ret != 0) {
		    die "File $full_path failed check_points test";
		}
	    }

	    my @opt = $v ? ('-v') : ();
	    warn "  Check neighbors...\n" if $v;
	    require "$FindBin::RealBin/check_neighbour";
	    if (!eval {
		BBBike::check_neighbour::doit
			("-type", "standard", "-data", $full_path,
			 "-against", "strassen", "-keepnet", "-q", @opt);
		1;
	    } && !eval {
		warn "  Check neighbors (wide region)...\n" if $v;
		BBBike::check_neighbour::doit
			("-type", "standard", "-data", $full_path,
			 "-against", "strassen",
			 "-against", "landstrassen",
			 "-against", "landstrassen2",
			 "-keepnet", @opt);
		1;
	    }) {
		die "File $full_path failed check_neighbour test";
	    }
	}
    }
}

sub output_future {
    # Sortieren nach dem nächsten Ereignis (Beginn oder Ende)
    for my $o (map  { $_->[1] }
	       sort { $a->[0] <=> $b->[0] }
	       map  {
		   my $cmp_time;
		   if ($_->{from} >= time) {
		       $cmp_time = $_->{from};
		   } elsif ($_->{until} >= time) {
		       $cmp_time = $_->{until};
		   } else {
		       $cmp_time = $_->{from};
		   }
		   [$cmp_time, $_];
	       }
	       grep { $_ } @temp_blocking) {
	if (!defined $o->{until} || $o->{until} > time) {
	    if ($do_output_files) {
		print _get_name($o), "\n";
	    } else {
		printf STDERR "  %-${longest_file_length}s: %s - %s\n",
		    _get_name($o), format_date($o->{from}),
			format_date($o->{until});
	    }
	}
    }
}

sub return_future {
    my @res;
    for my $i (0 .. $#temp_blocking) {
	if ($temp_blocking[$i]) {
	    $temp_blocking[$i]->{"index"} = $i;
	}
    }
    for my $o (sort { $a->{from} <=> $b->{from} } grep { $_ } @temp_blocking) {
	if (!defined $o->{until} || $o->{until} > time) {
	    push @res, $o;
	}
    }
    @res;
}

sub format_date {
    my $time = shift;
    return sprintf "%-24s", "..." if (!defined $time);
    my @l = localtime $time;
    strftime "%d.%m.%Y %H:%M:%S (%a)", @l;
}

sub _get_name {
    my $o = shift;
    if ($o->{file}) {
	$o->{file};
    } elsif ($o->{text}) {
	my $name = substr($o->{text}, 0, 25);
	$name =~ s/\S+$//;
	$name =~ s/[\.,;\s]+$//;
	$name;
    } else {
	"Data for " . ($o->{from}||"...") ." - " . ($o->{until}||"...");
    }
}

return 1 if caller;

process(@ARGV);
load_file();
run_checks();
output_future();

__END__
