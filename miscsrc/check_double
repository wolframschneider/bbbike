#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 1998,2009,2012 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://bbbike.sourceforge.net
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
use Strassen;
use Getopt::Long;

my %known_specials = map{($_,1)} qw(strassen);

sub usage {
    my $msg = shift;
    warn $msg, "\n" if $msg;
    my $special_string = join(" | ", sort keys %known_specials);
    die <<EOF;
usage: $0 -names | -linesegs | -points [-special $special_string] file ...
EOF
}

my %specials;
my $do_names;
my $do_linesegs;
my $do_points;
GetOptions("names" => \$do_names,
	   "linesegs" => \$do_linesegs,
	   "points" => \$do_points,
	   "special=s" => sub {
	       my $special = $_[1];
	       if (!exists $known_specials{$special}) {
		   usage "Unknown special '$special'";
	       }
	       $specials{$special}++;
	   },
	  )
    or usage;

($do_names xor $do_linesegs xor $do_points) or usage "Please specify one of -names, -points, or -linesegs";

unshift(@Strassen::datadirs, "$FindBin::RealBin/../data");

my @files = @ARGV;
usage "File missing" if !@files;

my @obj;
foreach my $file (@files) {
    my $obj = Strassen->new($file);
    die "Can't create obj for $file" if !$obj;
    push @obj, $obj;
}

my $o = MultiStrassen->new(@obj);

my %h;
$o->init;
while(1) {
    my $r = $o->next;
    my $c = $r->[Strassen::COORDS];
    last if !@$c;
    if ($do_names) {
	push @{ $h{$r->[Strassen::NAME]} }, @$c;
    } elsif ($do_linesegs) {
	if (@$c) {
	    my $cat = $r->[Strassen::CAT];
	    if ($specials{'strassen'}) {
		next if $cat eq 'Pl'; # legally may be doubled
	    }
	    my $bothdirs = $cat !~ m{;};
	    for my $i (1 .. $#$c) {
		push @{ $h{$c->[$i-1].' '.$c->[$i]} }, $r->[Strassen::NAME];
		if ($bothdirs) {
		    push @{ $h{$c->[$i].' '.$c->[$i-1]} }, $r->[Strassen::NAME];
		}
	    }
	}
    } elsif ($do_points) {
	for my $point (@$c) {
	    push @{ $h{$point} }, $r->[Strassen::NAME];
	}
    }
}

my @doubles;
while(my($k,$v) = each %h) {
    if (@$v > 1) {
	push @doubles, $k;
    }
}

if (@doubles) {
    print STDERR "*** ERROR: Found duplicates in @files\n";
    for my $double_key (@doubles) {
	if ($do_names) {
	    print STDERR "* $double_key\tX ", join(" ", @{ $h{$double_key} }), "\n";
	} else {
	    print STDERR "* ", join("; ", @{ $h{$double_key} }), "\tX $double_key\n";
	}
    }
    exit 1;
}

__END__

=head1 NAME

check_double - make sure that things are unique

=head1 SYNOPSIS

    check_double -names strfile ...
    check_double -linesegs strfile ...

=head1 DESCRIPTION

Checks if all names or line segments are unique. Exits with a non-zero
value if not.

=cut
