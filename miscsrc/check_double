#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: check_double,v 1.5 2002/11/06 15:28:22 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 1998,2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: eserte@cs.tu-berlin.de
# WWW:  http://user.cs.tu-berlin.de/~eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
use Strassen;
use Getopt::Long;

my %known_specials = map{($_,1)} qw(strassen);

sub usage {
    my $msg = shift;
    warn $msg, "\n" if $msg;
    my $special_string = join(" | ", sort keys %known_specials);
    die <<EOF;
usage: $0 -names | -linesegs | -points [-special $special_string] file ...
EOF
}

my %specials;
my $do_names;
my $do_linesegs;
my $do_points;
GetOptions("names" => \$do_names,
	   "linesegs" => \$do_linesegs,
	   "points" => \$do_points,
	   "special=s" => sub {
	       my $special = $_[1];
	       if (!exists $known_specials{$special}) {
		   usage "Unknown special '$special'";
	       }
	       $specials{$special}++;
	   },
	  )
    or usage;

($do_names xor $do_linesegs xor $do_points) or usage "Please specify one of -names, -points, or -linesegs";

unshift(@Strassen::datadirs, "$FindBin::RealBin/../data");

my @files = @ARGV;
usage "File missing" if !@files;

my @obj;
foreach my $file (@files) {
    my $obj = Strassen->new($file);
    die "Can't create obj for $file" if !$obj;
    push @obj, $obj;
}

my $o = MultiStrassen->new(@obj);

my %h;
$o->init;
while(1) {
    my $r = $o->next;
    my $c = $r->[Strassen::COORDS];
    last if !@$c;
    if ($do_names) {
	$h{$r->[Strassen::NAME]}++;
    } elsif ($do_linesegs) {
	if (@$c) {
	    my $cat = $r->[Strassen::CAT];
	    if ($specials{'strassen'}) {
		next if $cat eq 'Pl'; # legally may be doubled
	    }
	    my $bothdirs = $cat !~ m{;};
	    for my $i (1 .. $#$c) {
		$h{$c->[$i-1].' '.$c->[$i]}++;
		if ($bothdirs) {
		    $h{$c->[$i].' '.$c->[$i-1]}++;
		}
	    }
	}
    } elsif ($do_points) {
	for my $point (@$c) {
	    $h{$point}++;
	}
    }
}

my @double;
while(my($k,$v) = each %h) {
    if ($v > 1) {
	push @double, $k;
    }
}

if (@double) {
    print join("\n", map { "$_\t$h{$_}" } sort @double), "\n";
    exit 1;
}

__END__

=head1 NAME

check_double - make sure that things are unique

=head1 SYNOPSIS

    check_double -names strfile ...
    check_double -linesegs strfile ...

=head1 DESCRIPTION

Checks if all names or line segments are unique. Exits with a non-zero
value if not.

=cut
