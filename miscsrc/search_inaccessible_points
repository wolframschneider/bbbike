#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: search_inaccessible_points,v 1.9 2006/06/21 20:58:23 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2001,2003,2004 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://bbbike.sourceforge.net/
#

# This script will create a .bbd file of all inaccessible points for
# a given street net (in combination with gesperrt)

use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	 "$FindBin::RealBin/../data",
	);
use Strassen;
use Object::Iterate qw(iterate);
use Getopt::Long;
use strict;

my $s;
my $blocked;
my $refpoint;
my $quiet;
my $usecache;
my $v;

my @s_files;
my @blocked_files;
my @blocked_type;

my @allowed_blocked_type = qw(einbahn sperre tragen wegfuehrung);

if (!GetOptions("street=s@"  => sub { push @s_files, split /,/, $_[1] },
		"blocked=s@" => sub { push @blocked_files, split /,/, $_[1] },
		"blockedtype=s@" => \@blocked_type,
		"refpoint=s" => \$refpoint,
		"q" => \$quiet,
		"cache" => \$usecache,
		"v" => \$v,
	       )) {
    die <<EOF;
usage: $0 [-street file] [-blocked file]
       [-blockedtype type] [-refpoint x,y] [-q] [-v] [-cache]
-street and -blocked may be given multiple times or separated with commas
-blockedtype may be given multiple times and should be one of
             @allowed_blocked_type
EOF
}

if (!$usecache) {
    eval 'use BBBikeXS';
    warn "Can't load BBBikeXS, expect slower operation or specify -cache. $@" if $@;
}

if ($v) {
    Strassen::set_verbose($v);
}

if (!@s_files) { push @s_files, "strassen" }
if (!@blocked_files) { push @blocked_files, "gesperrt" }

# blocked types
if (!@blocked_type) { push @blocked_type, qw/einbahn sperre tragen/ }
my %blocked_type;
my $allowed_blocked_rx = join("|", @allowed_blocked_type);
foreach (@blocked_type) {
    if (/^($allowed_blocked_rx)$/) {
	$blocked_type{$_} = 1;
    } else {
	die "Only @allowed_blocked_type is allowed, not $_";
    }
}

$s = MultiStrassen->new(@s_files);
$blocked = MultiStrassen->new(@blocked_files);

my %carry_points;
$blocked->init;
while(1) {
    my $r = $blocked->next;
    last if !@{$r->[Strassen::COORDS]};
    next if $r->[Strassen::CAT] ne StrassenNetz::BLOCKED_CARRY;
    $carry_points{$r->[Strassen::COORDS][0]}++;
}

#old_search();
new_search();

sub old_search {
    if (!defined $refpoint) {
	# otherwise use first coordinate of first street as reference
	$refpoint = ($s->get(0))->[Strassen::COORDS][0];
    }

    my $net = StrassenNetz->new($s);
    $net->make_net(UseCache => $usecache);
    $net->make_sperre($blocked, %blocked_type);

    # loop over all points
    my $i = 0;
    $s->init;
    while(1) {
	my $r = $s->next;
	last if !@{$r->[Strassen::COORDS]};
	printf STDERR "%3d%%\r", (($i++)/@{$s->{Data}})*100;
	foreach my $c (@{$r->[Strassen::COORDS]}) {
	    next if $c eq $refpoint;
	    my(@r) = $net->search($c, $refpoint, AsObj => 1);
	    if ($r[0]->is_empty) {
		warn "Inaccessible: $c in $r->[Strassen::NAME] (refpoint=$refpoint)\n" if !$quiet;
		print "$r->[Strassen::NAME]\tX $c\n";
	    } else {
		# Simple optimization: use this point as the next refpoint
		# but only if it's not a "carry" point.
		if (!exists $carry_points{$c}) {
		    $refpoint = $c;
		}
	    }
	}
    }
}

sub new_search {
    my $net = StrassenNetz->new($s);
    $net->make_net(UseCache => $usecache);
    $net->make_sperre($blocked, %blocked_type);
    flood_search($net);
}

# XXX Here no handling of carry_points
sub flood_search {
    my($net, $act_coord) = @_;
    my $net_net = $net->{Net};
    if (!defined $act_coord) {
	my $k = each %$net_net;
	$act_coord = $k;
    }

    my($start_x,$start_y) = split /,/, $act_coord;

    my %CLOSED;
    my %OPEN;
    my %PRED;

    my $act_dist = 0;
    $OPEN{$act_coord} = $act_dist;
    $PRED{$act_coord} = undef;

    while (1) {
	$CLOSED{$act_coord} = $act_dist;
	delete $OPEN{$act_coord};

	while (my($neighbor, $dist) = each %{ $net_net->{$act_coord} }) {
	    next if exists $CLOSED{$neighbor} && $CLOSED{$neighbor} <= $act_dist + $dist;
	    $OPEN{$neighbor} = $act_dist + $dist;
	    $PRED{$neighbor} = $act_coord;
	}

	my $new_act_coord;
	my $new_act_dist = 99999999;
	while (my($c, $dist) = each %OPEN) {
	    if ($dist < $new_act_dist) {
		$new_act_coord = $c;
		$new_act_dist = $dist;
	    }
	}
	if (!defined $new_act_coord) {
	    #warn "Nothing more...";
	    last;
	}

	$act_coord = $new_act_coord;
	$act_dist = $new_act_dist;
	# warn $act_dist;
    }

    # Check against streets:
    my $s = $net->{Strassen};
    my %inaccessible;
    iterate {
	for my $c (@{ $_->[Strassen::COORDS] }) {
	    if (!exists $CLOSED{$c}) {
		push @{ $inaccessible{$_->[Strassen::NAME]} }, $c;
		print "$_->[Strassen::NAME]\tX $c\n";
	    }
	}
    } $s;

    if (!$quiet) {
	require Text::Wrap;
	local $Text::Wrap::huge = "overflow";
	print STDERR "Inaccessible:\n";
	for my $name (sort keys %inaccessible) {
	    print STDERR Text::Wrap::wrap("  $name ", " "x(3+length($name)),
					  "(" . join(" ", @{ $inaccessible{$name} }) . ")\n"
					 );
	}
    }
}

__END__
