#!/usr/local/bin/perl
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2001,2003,2004,2015 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://bbbike.de
#

# This script will create a .bbd file of all inaccessible points for
# a given street net (in combination with gesperrt)

use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	 "$FindBin::RealBin/../data",
	);
use Strassen;
use Getopt::Long;

use strict;
use warnings;

my $s;
my $blocked;
my $refpoint;
my $usecache;
my $v;
my $debug;
my $shorter;
my $encoding;
my $map;
my $stats;
my $max_loops = 10;

my @s_files;
my @blocked_files;
my @blocked_type;

my @allowed_blocked_type = qw(einbahn sperre tragen wegfuehrung);

if (!GetOptions("street=s@"  => sub { push @s_files, split /,/, $_[1] },
		"blocked=s@" => sub { push @blocked_files, split /,/, $_[1] },
		"blockedtype=s@" => \@blocked_type,
		"refpoint=s" => \$refpoint,
		"q" => sub { warn "-q option is obsolete" },
		"cache" => \$usecache,
		"v" => \$v,
		"debug" => \$debug,
		"shorter" => \$shorter,
		"encoding=s" => \$encoding,
		"stats!" => \$stats,
		"maxloops=i" => \$max_loops,
	       )) {
    die <<EOF;
usage: $0 [-street file] [-blocked file]
       [-blockedtype type] [-refpoint x,y] [-v] [-cache] [-shorter] [-stats]
       [-encoding encoding]
-street and -blocked may be given multiple times or separated with commas
-blockedtype may be given multiple times and should be one of
             @allowed_blocked_type
-shorter: just output the first street name for a blocking series
EOF
}

if ($map && $map !~ /^(bbbike|standard|wgs84|polar)$/ ) {
    die "Unsupported map: '$map'\n";
}

if (!$usecache) {
    eval 'use BBBikeXS';
    if ($@) {
	warn "Can't load BBBikeXS, expect slower operation or specify -cache.\n";
	if ($v) { warn $@ }
    }
}

if ($v) {
    Strassen::set_verbose($v);
}

if (!@s_files) { push @s_files, "strassen" }
if (!@blocked_files) { push @blocked_files, "gesperrt" }

# blocked types
if (!@blocked_type) { push @blocked_type, qw/einbahn sperre tragen/ }
my %blocked_type;
my $allowed_blocked_rx = join("|", @allowed_blocked_type);
foreach (@blocked_type) {
    if (/^($allowed_blocked_rx)$/) {
	$blocked_type{$_} = 1;
    } else {
	die "Only @allowed_blocked_type is allowed, not $_";
    }
}

$s = MultiStrassen->new(@s_files);
$blocked = MultiStrassen->new(@blocked_files);

{
    my $_encoding = $s->get_global_directive('encoding');
    $encoding = $_encoding if defined $_encoding;
}

{
    my $_map = $s->get_global_directive('map');
    $map = $_map if defined $_map;
}

new_search();

sub new_search {
    my $net = StrassenNetz->new($s);
    $net->make_net(UseCache => $usecache);
    $net->make_sperre($blocked, %blocked_type);

    my $s = $net->{Strassen};

    my $number_unique_points = do {
	my %unique_points;
	$s->init;
	while() {
	    my $r = $s->next;
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;
	    for my $c (@c) {
		$unique_points{$c} = 1;
	    }
	}
	scalar keys %unique_points;
    };

    my @islands;
    if ($refpoint) {
	push @islands, flood_search($net, $refpoint);
    } else {
	$s->init_for_iterator('refpoint');
	my %global_seen;
	my $flood_search_calls = 0;
    ITERATE_OVER_STREETS: while() {
	    my $r = $s->next_for_iterator('refpoint');
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;

	    for my $c (@c) {
		if (!exists $global_seen{$c}) {
		    warn "flood search for refpoint=$c\n" if $debug;
		    my $island = flood_search($net, $c);
		    push @islands, $island;
		    while(my($k) = each %$island) {
			$global_seen{$k} = 1;
		    }
		    if ($debug) {
			warn "... found " . scalar(keys %$island) . " point(s) of total $number_unique_points in island\n";
			warn "global_seen has now " . scalar(keys %global_seen) . " entries\n";
		    }
		    if (scalar(keys %$island) >= $number_unique_points/2) {
			warn "This is large enough, exiting loop.\n" if $debug;
			last ITERATE_OVER_STREETS;
		    }
		    $flood_search_calls++;
		    if ($flood_search_calls > $max_loops) {
			last ITERATE_OVER_STREETS;
		    }
		}
	    }
	}
    }

    @islands = sort { scalar(keys %$b) <=> scalar(keys %$a) } @islands;

    if ($encoding) {
	print "#: #: -*- coding: $encoding -*-\n";
	print "#:encoding: $encoding\n";
	binmode STDOUT, ":encoding($encoding)";
    }
    if ($map) {
	print "#:map: $map\n";
    }
    print "#:title: inaccessible points\n";
    print "#:\n";
    print "# generated by $0\n";
    print "#\n";

    if (@islands >= 1) {
	my $continent = $islands[0];
	my %seen_point;
	$s->init;
	while() {
	    my $r = $s->next;
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;

	    my $name_output = 0;
	    for my $c (@c) {
		if (!exists $continent->{$c} && !$seen_point{$c}) {
		    if (!$shorter || !$name_output || length $r->[Strassen::NAME] <= 3) {
			print $r->[Strassen::NAME];
			$name_output = 1;
		    } else {
			print q{-"-};
		    }
		    print "\tX $c\n";
		    $seen_point{$c} = 1;
		}
	    }
	}
    }

    if ($stats) {
	print STDERR "search_inaccessible_points stats\n";
	if (@islands == 0) {
	    print STDERR "no data records?!\n";
	} else {
	    my $percentage = sub {
		my $index = 0;;
		sprintf "%.1f", 100*scalar(keys %{$islands[$index]})/$number_unique_points;
	    };
	    my $get_refpoint = sub {
		my $index = 0;
		(keys %{$islands[$index]})[0];
	    };
	    my $count_inaccessible_points = sub {
		$number_unique_points - scalar(keys %{$islands[0]});
	    };
	    print STDERR <<EOF;
largest continent:     @{[ $percentage->() ]}%
  ref point:           @{[ $get_refpoint->() ]}
  inaccessible points: @{[ $count_inaccessible_points->() ]}
EOF
	}
    }
}

# XXX Here no handling of carry_points
sub flood_search {
    my($net, $act_coord) = @_;
    my $net_net = $net->{Net};

    my($start_x,$start_y) = split /,/, $act_coord;

    # A mysterious bug affecting perls < 5.18.0 in a following
    # environment:
    # - Linux, e.g. Debian/wheezy (does not happen on FreeBSD)
    # - large dataset (i.e. osm derived data, does not happen
    #   for original bbbike data)
    # If this is given, then the "last if !keys %OPEN" line causes
    # a crash if %OPEN has some 2^16 keys (this number could be
    # coincidence, though):
    #
    # *** glibc detected *** perl5.16.3: munmap_chunk(): invalid pointer: 0x0000000005d4ca18 ***
    #
    # Workaround: explicitely reset the iterator earlier
    # for these perls.
    use constant PERL_HASHMEM_BUG => $] < 5.018;

    my %CLOSED;
    my %OPEN;

    $OPEN{$act_coord} = undef;

    while (1) {
	$CLOSED{$act_coord} = undef;
	delete $OPEN{$act_coord};

	while (my $neighbor = each %{ $net_net->{$act_coord} }) {
	    next if exists $CLOSED{$neighbor};
	    $OPEN{$neighbor} = undef;
	}

	last if !keys %OPEN; # side-effect: resets iterator
	$act_coord = each %OPEN;
	keys %OPEN if PERL_HASHMEM_BUG; # workaround for buggy perls
    }

    return \%CLOSED;
}

__END__
