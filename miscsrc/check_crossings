#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: check_crossings,v 1.7 2007/05/03 19:58:20 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2003,2004 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Checks, whether all crossings are marked as crossings or brunnels.

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);
use VectorUtil;
use Strassen::Core;
use Object::Iterate qw(iterate);
use Getopt::Long;

my $outfile;
my $against;
my $v;
my @ignore_rx;
my $autoflush;
if (!GetOptions("o=s" => \$outfile,
		"against=s" => \$against,
		"v" => \$v,
		"ignore=s" => sub {
		    my @s = split /,/, $_[1];
		    push @ignore_rx, map { '^' . quotemeta($_) . '$' } @s;
		},
		"ignorerx=s" => sub {
		    my @s = split /,/, $_[1];
		    push @ignore_rx, @s;
		},
		"autoflush" => \$autoflush,
	       )) {
    die <<EOF;
usage: $0 [-v] [-autoflush] [-o outfile]
	[-ignore name,name,...] [-ignorerx namerx,namerx,...]
	-against file strassen ...
EOF
}

my $ignore_rx;
if (@ignore_rx) {
    $ignore_rx = "(?:" . join("|", @ignore_rx) . ")";
    $ignore_rx = qr{$ignore_rx};
}

my @files = @ARGV;
@files = "strassen" if !@files;
my $s;
if (@files == 1) {
    $s = Strassen->new($files[0]);
} else {
    require Strassen::MultiStrassen;
    $s = MultiStrassen->new(@files);
}
$s->make_grid(Exact => 1, UseCache => 1);

my $brunnelfile = $against || "brunnels";
my $brunnel = Strassen->new($brunnelfile);
my $brunnelcr = $brunnel->all_crossings(RetType => "hashpos", UseCache => 1,
					Kurvenpunkte => 1);
my %seen;

my $outfh;
if ($outfile) {
    open($outfh, ">$outfile") or die "Can't write to $outfile: $!";
    if ($autoflush) {
	select $outfh; $| = 1; select STDOUT;
    }
}

my $errfh;
if ($autoflush) {
    $errfh = \*STDERR;
} else {
    $errfh = \*STDOUT;
}

iterate {
    my $line = "  "x80;
    my $word = $_->[Strassen::NAME] . "...";
    substr($line,0,length $word) = $word;
    substr($line,79,1) = "\r";
    print $errfh substr($line, 0, 80);
    return if $ignore_rx && $_->[Strassen::NAME] =~ $ignore_rx;
    for my $i (1 .. $#{ $_->[Strassen::COORDS] }) {
	my($p1,$p2) = @{$_->[Strassen::COORDS]}[$i-1,$i];
	my(@grids) = keys %{{ map { ($_=>1) }
				  (join(",", $s->grid(split /,/, $p1)),
				   join(",", $s->grid(split /,/, $p2))) # XXX alle Gitter dazwischen auch!
			  }};
	for my $grid (@grids) {
	    next if !exists $s->{Grid}{$grid};
	    for my $n (@{ $s->{Grid}{$grid} }) {
		my $r = $s->get($n);
		next if $ignore_rx && $r->[Strassen::NAME] =~ $ignore_rx;
		for my $r_i (1 .. $#{ $r->[Strassen::COORDS] }) {
		    my($r1,$r2) = @{$r->[Strassen::COORDS]}[$r_i-1,$r_i];
		    if ($r1 eq $p1 || $r1 eq $p2 || $r2 eq $p1 || $r2 eq $p2) {
			next;
		    }
		    if (exists $brunnelcr->{$r1} ||
			exists $brunnelcr->{$r2} ||
			exists $brunnelcr->{$p1} ||
			exists $brunnelcr->{$p2}) {
			next;
		    }
		    my @sorted_p = sort ($p1, $p2);
		    my @sorted_r = sort ($r1, $r2);
		    if ($seen{"@sorted_p"} &&
			$seen{"@sorted_r"}) {
			next;
		    }
		    if (VectorUtil::intersect_lines(split(/,/, $p1),
						    split(/,/, $p2),
						    split(/,/, $r1),
						    split(/,/, $r2),
						   )) {
			if ($v) {
			    print $errfh "Found: $_->[Strassen::NAME] <=> $r->[Strassen::NAME] $p1 $p2 $r1 $r2\n";
			}
			if ($outfh) {
			    # XXX find exact crossing point!
			    print $outfh "$_->[Strassen::NAME]/$r->[Strassen::NAME]\tX $p1 $p2\n";
			    print $outfh "$_->[Strassen::NAME]/$r->[Strassen::NAME]\tX $r1 $r2\n";
			}

			$seen{"@sorted_p"}++;
			$seen{"@sorted_r"}++;
		    }
		}
	    }
	}
    }
} $s;

__END__
