#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: convert_orig_to_bbd,v 1.9 2008/08/10 18:57:17 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2007 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# This will be the successor of convert2hafas, one day

use strict;

use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	 "$FindBin::RealBin/../data");

use Getopt::Long;

use Strassen::Core;

my $do_strip_tendencies;
my $do_strip_future_categories;
my $un_utf8_ify = 0;
my @keep_directive;
my @special;
if (!GetOptions("strip-tendencies!"        => \$do_strip_tendencies,
		"strip-future-categories!" => \$do_strip_future_categories,
		"unutf8ify!"               => \$un_utf8_ify,
		'keep-directive=s@'	   => \@keep_directive,
		'special=s@'		   => \@special,
	       )) {
    die <<EOF;
usage: $0 [-strip-tendencies] [-strip-future-categories] [-unutf8ify]
          [-keep-directive dir [-keep-directive ...]]
	  [-special ... [-special ...]]
	origbbd > bbd
EOF
}

my $f = shift || "-";
if ($f eq '-') {
    if (-t $f) {
	warn "Read from STDIN...\n";
    }
}

my $s = Strassen->new($f, UseLocalDirectives => 1);
my $new_s = Strassen->new;
$s->init;
while(1) {
    my $r = $s->next;
    last if !@{ $r->[Strassen::COORDS] };

    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	$cat_hin = $cat_rueck = $r->[Strassen::CAT];
    }

    if ($do_strip_tendencies) {
	for ($cat_hin, $cat_rueck) {
	    s{^([qQ]\d)[\+\-]$}{$1};
	}
    }

## Scheint gut auszusehen...
#     if ($do_strip_future_categories) {
# 	for ($cat_hin, $cat_rueck) {
# 	    s{^([USR][ABC0])::_?Tu_?}{$1}; # see also $tunnel_qr in bbbike
# 	}
#     }

    if ($cat_hin ne $cat_rueck) {
	$r->[Strassen::CAT] = $cat_hin . ";" . $cat_rueck;
    } else {
	$r->[Strassen::CAT] = $cat_hin; # XXX unless both directions should be always preserved, see radwege
    }

    my $dir = $s->get_directive;
    if ($dir->{append_comment}) {
	$r->[Strassen::NAME] .= " ($dir->{append_comment}->[0])";
    }

    for my $special (@special) {
	no strict 'refs';
	&{"special_".$special."_handler"}($r, $dir);
    }

    unutf8ify($r->[Strassen::NAME]);

    $new_s->push($r);

    {
	my %copied_dir;
	for my $_dir (@keep_directive) {
	    if ($dir->{$_dir}) {
		$copied_dir{$_dir} = $dir->{$_dir};
	    }
	}
	if (%copied_dir) {
	    $new_s->set_directive_for_current(\%copied_dir);
	}
    }

}

my $glob_dir = $s->get_global_directives;
if ($un_utf8_ify && $glob_dir->{encoding}) {
    $glob_dir->{encoding} = ['iso-8859-1'];
    for (@{ $glob_dir->{'#'} || [] }) {
	s{(-\*-\s*coding:\s*)utf-8(\s*-\*-)}{$1iso-8859-1$2};
    }
}
$new_s->set_global_directives($glob_dir);
print $new_s->as_string;

sub unutf8ify {
    return if !$un_utf8_ify;
    $_[0] = unidecode_any($_[0], "iso-8859-1");
}

sub special_as_of_handler {
    my($r, $dir) = @_;
    if ($dir->{as_of}) {
	my($y,$m,$d) = $dir->{as_of}->[0] =~ m{^(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?$};
	if (defined $y) {
	    my $date = (defined $d ? "$d.$m.$y" :
			defined $m ? "$m/$y" : # with day using ".", without using "/", seems to be natural in German
			$y);
	    $r->[Strassen::NAME] .= " (Stand $date)"; # XXX other lang/english version?
	}
    }
}

# REPO BEGIN
# REPO NAME unidecode_any /home/e/eserte/work/srezic-repository 
# REPO MD5 bd47157f30dee711682b6a173fb1cb02

=head2 unidecode_any($text, $encoding)

Similar to Text::Unidecode::unidecode, but convert to the given
$encoding.

=cut

sub unidecode_any {
    my($text, $encoding) = @_;

    require Text::Unidecode;
    require Encode;

    my $res = "";

    for (split //, $text) {
	my $conv = eval { Encode::encode($encoding, $_, Encode::FB_CROAK()) };
	if ($@) {
	    $res .= Text::Unidecode::unidecode($_);
	} else {
	    $res .= $conv;
	}
    }

    $res;
}
# REPO END

__END__
