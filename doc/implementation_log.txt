2008-08-20  Slaven Rezic  <slaven@rezic.de>

	* define_item_attribs: Wird jetzt sp√§ter aufgerufen, nachdem $city
	verf√ºgbar ist, damit einige Berlin-spezifische Labels √ºberschrieben
	werden. Hoffentlich h√§ngt etwas anderes nicht von der Reihenfolge hier
	ab...

	* fast_plot_str/point: Folgendes TODO habe ich heute implementiert:
	
	| BBBikeXS.pm: the fast plotting routines cannot deal with encodings
	| (utf8!), it seems. At least check for it.

	Damit werden osm-Daten mit utf8-Encoding korrekt im "fast"-Modus
	dargestellt. Es werden aber nur die Encodings iso-8859-1 und utf-8
	unterst√ºtzt (das ist auch in bbd.pod dokumentiert) --- alles andere ist
	heutzutage wahrscheinlich nicht notwendig.

2008-08-17  Slaven Rezic  <slaven@rezic.de>

	* Bahnh√∂fe: Im Zuge des Vorschlags f√ºr eine neue Kartensignatur f√ºr
	Bahnlinien habe ich auch √ºberlegt:

	| F√ºr Bahnh√∂fe k√∂nnte man ein wei√ües Rechteck mit schwarzem Rand nehmen,
	| welches parallel zur Bahnstrecke gedreht ist.

	Mir gef√§llt aber das gegenw√§rtige Eisenbahnsymbol eigentlich. Also keine
	weiteren Aktionen hier n√∂tig.

	* Sehensw√ºrdigkeiten: rot oder grau?

	Sehensw√ºrdigkeiten vielleicht grau statt rot einf√§rben wie beim
	Mapserver? Das sieht nicht so aufdringlich aus. Auch bei anderen
	Ausgabeformaten (BBBikeDraw) √ºberlegen.
	
	Aber: bei osm kann man sich Bebauungsfl√§chen besorgen. Und diese will
	man dann tats√§chlich grau zeichnen. In diesem Fall will man eine
	Unterscheidung haben.

	Wie machen es andere Karten (√∂ffentliche Geb√§ude/bebaute Fl√§chen)? RV:
	rot/grau; Pharus: orange/grau; Pietruska: graurosa (kaum Kontrast)/grau;
	Google: rosa/grau (nur Krankenh√§user); Stadtplandienst: rosa+roter
	Rand/grau
	
	Ergo: rot ist OK! Vielleicht kann man den Kontrast etwas abschw√§chen.
	Vielleicht sollte man beim Mapserver auch wieder zur√ºck zu rot gehen.

	* Windows und GfxConvert: Der TODO-Vorschlag:

	GfxConvert: add more search paths on Windows machines like
  C:/Programme/gs/gs8.14/lib;C:/Programme/GnuWin32/bin

	wurde ungetestet umgesetzt.

	* scale_coords: In scale_width sollte wirklich nur die Breite eines
	Canvas-Items angepasst werden. Da die Skalierung in scalecanvas nach dem
	Aufruf von scale_width erfolgt, m√ºssen Koodinatenanpassungen sp√§ter
	gemacht werden. Dazu ist jetzt scale_coords da.

	Schmutzigerweise ist die "Breiteninformation" f√ºr comm-scenic-View in
	%line_width enthalten.

	* Sch√∂ne Aussicht: eine einigermaﬂen befriedigende Implementation
	existiert jetzt. Der alte Eintrag in TODO hat folgendes vorgeschlagen:

	| Aussichtspunkte-Signatur. Idee: Ich k√∂nnte ein "View"-Symbol wie folgt
	| zeichen: stipple mit einem
	| vollen Kreis f√ºr den Aussichtspunkt f√ºr eine feste Gr√∂√üe, z.B. 20x20
	| Pixel vorbereiten. Die bbd-Kategorie sieht dann so aus:
	| View:start:extent und wird mit createArc gezeichnet. M√∂gliches
	| Problem: beim Zoomen d√ºrfen diese Items nicht angefasst werden oder
	| der Stipple muss sich relativ anpassen. Evtl. kann man ab
	| bestimmten Zoomstufen auf den Stipple verzichten und nur ein
	| Kreissegment zeichnen. (Letzteres ist provisorisch implementiert
	| worden)
	| 
	| Zun√§chst muss ich aber inkscape zum Laufen bekommen, damit ich die
	| volle Signatur f√ºr das Stipple damit zeichnen kann.

	inkscape l√§uft hier mittlerweile, und ein Aussichtspunkt-SVG existiert
	auch. Das Problem ist, dass man den Ankerpunkt von Stipples bei Perl/Tk
	nicht steuern kann. Die Mitte des Stipples *muss* aber mit der Mitte des
	Canvas-Items zusammenfallen, ansonsten funktioniert es nicht.

	Jetzt ist es so gel√∂st, dass in 30¬∞-Schritten Kreissegmente der Breite
	15¬∞ gezeichnet werden.

	* implementation_log.txt: Diese Datei soll vermeiden, dass
	Implementations-Gedanken verloren gehen. Zum Beispiel kann man
	implementierte Punkte aus TODO.pod hierher √ºbertragen und kommentieren.

	Local Variables:
	mode: change-log
	coding: utf-8
	change-log-default-name: "implementation_log.txt"
	tab-width: 2
	left-margin: 2
	End:
