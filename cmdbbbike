#!/usr/bin/perl
# -*- perl -*-

#
# $Id: cmdbbbike,v 4.7 2004/12/14 01:40:20 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2001 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://bbbike.sourceforge.net
#

package BBBikeRouting::Cmdline;
use FindBin;
use lib ($FindBin::RealBin, "$FindBin::RealBin/lib");
use BBBikeRouting;
@ISA = 'BBBikeRouting';
use strict;

sub cmdline_input {
    my $self = shift;

    if (eval { require Getopt::Long; 1 }) {
	if (!Getopt::Long::GetOptions
	    ("vehicle=s" => sub { $self->Context->Vehicle($_[1]) },
	     "algorithm=s" => sub { $self->Context->Algorithm($_[1]) },
	     "xs!" => sub { $self->Context->UseXS($_[1]) },
	     "cache!" => sub { $self->Context->UseCache($_[1]) },
	     "scope=s" => sub { $self->Context->Scope($_[1]) },
	     "v" => sub { require Strassen; Strassen::set_verbose(1);
			  $self->Context->Verbose(1),
		      },
	     "dumproute" => sub { $self->{DumpRoute} = 1 },
	    )) {
	    die <<EOF;
Usage: $0 [-vehicle vehicle] [-[no]cache] [-[no]xs]
        [-algorithm ...] [-scope ...] [-v] [-dumproute] start goal

start and goal may be prefixed with \"city:\" to force cities instead of
streets. start and goal may also be "standard" coordinates instead.
EOF
	}
    } else {
	warn "No Getopt::Long installed...\n";
    }

    if (@ARGV < 2) {
	print "Zu wenige Argumente: mindestens Start- und Zielstraße angeben!\n";
	exit 1;
    }
    if (@ARGV == 2) {
	$self->set_city_or_street($self->Start, $ARGV[0]);
	$self->set_city_or_street($self->Goal,  $ARGV[1]);
    } elsif (@ARGV == 4) {
	$self->Start->Street  ($ARGV[0]);
	$self->Start->Citypart($ARGV[1]);
	$self->Goal->Street   ($ARGV[2]);
	$self->Goal->Citypart ($ARGV[3]);
    } elsif (@ARGV == 3) {
	$self->set_city_or_street($self->Start, shift @ARGV);
	if ($ARGV[0] =~ /^\d+$/) {
	    $self->Start->Citypart(shift @ARGV);
	} elsif ($ARGV[1] =~ /^\d+$/) {
	    $self->Goal->Citypart(pop @ARGV);
	}
	if (@ARGV == 1) {
	    $self->set_city_or_street($self->Goal, shift @ARGV);
	} else {
	    require Geography;
	    my $geo = Geography->new('Berlin', 'DE');
	    $ENV{LANG} = "de";
	    my(@cityparts) = keys %{ $geo->subcitypart_to_citypart };
	    foreach (@cityparts) {
		if ($_ =~ /^\Q$ARGV[0]\E/i) {
		    $self->Start->Citypart ($ARGV[0]);
		    $self->set_city_or_street($self->Goal, $ARGV[1]);
		    last;
		} elsif ($_ =~ /^\Q$ARGV[1]\E/i) {
		    $self->set_city_or_street($self->Goal, $ARGV[0]);
		    $self->Goal->Citypart($ARGV[1]);
		    last;
		}
	    }
	    if (!$self->Goal->Street && !$self->Goal->City) {
		$self->set_city_or_street($self->Goal, $ARGV[0]);
		$self->Goal->Citypart($ARGV[1]);
	    }
	}
    }
}

sub cmdline_output {
    my $self = shift;

    print $self->Start->Street;
#XXX
#      if ($multi_from) {
#  	print " ($from_citypart)";
#      }
    print " - ";
    print $self->Goal->Street;
#      if ($multi_to) {
#  	print " ($to_citypart)";
#      }
    print "\n";

    if ($self->{DumpRoute}) {
	require Data::Dumper;
	print Data::Dumper->new([$self->RouteInfo],[])->Indent(1)->Useqq(1)->Dump;
    } else {
	print
	    join("\n", map { sprintf("%-40s %s", $_->{Street}, $_->{Whole}) }
		 @{ $self->RouteInfo} ), "\n";
    }
}

sub set_city_or_street {
    my($self, $o, $s) = @_;
    if ($s =~ /^(?:city|ort):(.*)$/) {
	$o->City($1);
	$o->Street(undef);
    } elsif ($s =~ /^-?\d+,-?\d+$/) {
	$o->Coord($s);
	require Karte;
	Karte::preload(qw(Standard Polar));
	$Karte::Polar::obj = $Karte::Polar::obj; # -w
	my($long,$lat) = map { [ Karte::Polar::ddd2dms($_) ] } $Karte::Polar::obj->standard2map(split /,/, $s);
	$o->Street(Karte::Polar::dms_human_readable("lat", @$lat) . ", " .
		   Karte::Polar::dms_human_readable("long", @$long));
	$self->fix_position($o);
    } else {
	$o->Street($s);
    }
}

return 1 if caller() or keys %Devel::Trace::; # XXX Tracer bug

######################################################################

package main;

my $routing = BBBikeRouting->new->init_context;
bless $routing, 'BBBikeRouting::Cmdline'; # 5.005 compat

$routing->cmdline_input();
$routing->search();
$routing->cmdline_output();

__END__
