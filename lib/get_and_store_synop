#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: get_and_store_synop,v 1.12 2006/03/05 10:10:21 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2001 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven.rezic@berlin.de
# WWW:  http://www.rezic.de/eserte/
#

#  für Tempelhof (10384):

#  http://131.54.133.44/cgi-bin/ProductSearch.cgi?current=0&fmt=ll&form=20&frame=_top&prdid=AC&T=l&sub=S&icao=10384

#  SMDL10 KAWN 260000 RRA
#  AAXX 26001
#  10384 32983 13401 10121 20102 30171 40231 52002 80001 333 30///
#        55300 81076

# XXX Zum Jahreswechsel ist das Datum am 31.12. um 23:00 falsch und
# muss manuell geändert werden!

# Andere Quelle:
# http://prognose.met.fu-berlin.de/synops.php
# 
# ZCZC SHDL30 EDZW 142300 SXSX 14230 
# 
#  Station Berlin Tegel (10382)
# 
#  10382 42570 61502 11017 21056 30128 40175 58021 81506
#    333 55300 81622 86275
#    555 01035 10000 22024 2300 2405 26029 91004 91104 91203
#        BOT 10000 20001 30000 40001 50015=  
# 
# 
# 
#  Station Berlin Tempelhof (10384)
# 
#  10384 42568 41303 11026 21053 30115 40178 58023 81506
#    333 55300 81622 83273
#    555 01049 10000 22030 2300 2405 26027 91004 91104 91203
#        BOT 11013 21009 31005 41002 50012= 
# 
# 
# 
#  Station Berlin Dahlem (10381)
# 
#  10381 42571 61303 11036 21052 30085 40177 57023 81501
#    333 55300 81620 86075
#    555 01065 10000 22034 2300 2405 91005 91105 91204
#        BOT 11018 21009 31009 41005 50013 666 11029 21037= 
# 
# 
# 
#  Station Potsdam (10379)
# 
#  10379 42962 21305 11034 21057 30048 40176 58024 82030
#    333 55300 20000 30000 40828 82366
#    555 01057 10000 22050 2300 2405 26043 91007 91107 91205
#        BOT 11019 21016 31002 40000 50008= 
# 
# 
# 
#  Station Berlin Schönefeld (10385)
# 
#  10385 42964 41203 11030 21052 30114 40178 58021 80006
#    333 55300 84276
#    555 01052 10000 22028 2300 2405 2505 2502 26026 91004 91104 91203
#        BOT 11004 21002 31002 40001 50014= 
# 
# 
# 
#  Station Berlin Alexanderplatz (10389)
# 
#  10389 46/// ///09 11014 21056 30077 40184 58020
#    333 553//
#    555 01028 10000 22092 23// 24/5 26085 91010 91110 91210
#        BOT 11019 21012 31001 40002 50021= 
# 
# 
# 

use strict;

# for user.cs.tu-berlin.de:
$ENV{PATH} = "/usr/perl/bin:/usr/perl/5/bin:$ENV{PATH}";

my $store_dir = "/home/e/eserte/doc/met/synop";

my %stations = (
		#10378 => 'potsdam_sor', # not available at 131.54.133.44
		10379 => 'potsdam',
		10381 => 'berlin_dahlem',
		10382 => 'berlin_tegel',
		10384 => 'berlin_tempelhof',
		10385 => 'berlin_schoenefeld',
		10389 => 'berlin_alexanderplatz',
		10289 => 'prenzlau', # Grünow - #10289 (53°19'N 13°56'E)
	       );

my $has_getopt_long = 1;
eval 'require Getopt::Long; 1;';
if ($@) {
    $has_getopt_long = 0;
}
if (@ARGV) {
    if (!$has_getopt_long) {
	die "Getopt::Long is not available";
    }
    my $station;
    my $getlast;
    Getopt::Long::GetOptions("station=s" => \$station,
			     "getlast!" => \$getlast,
			    ) or die "usage: $0 [-station station] [-getlast]
station is any of @{[ values %stations ]}
";

    if (!defined $station) {
	die "-station is missing";
    }

    if ($station !~ m{^\d+$} && !exists $stations{$station}) {
	my %station_to_code = reverse %stations;
	my $orig_station = $station;
	$station = $station_to_code{$station};
	if (!defined $station) {
	    die "Can't get station code for $orig_station";
	}
    }

    if ($getlast) {
	my $ret = get_last_from_file($station);
	if (defined $ret) {
	    print $ret;
	    exit 0;
	} else {
	    exit 1;
	}
    } else {
	my $ret = get_synop_from_fu();
	if ($ret && $ret->{synops} && $ret->{synops}{$station}) {
	    print "# $ret->{real_time}\n";
	    print "$ret->{wmo_header}\n";
	    print "$ret->{synops}{$station}\n\n";
	    exit 0;
	} else {
	    exit 1;
	}

# 	# old site:
# 	my $ret = get_synop($station);
# 	if ($ret && defined $ret->{synop} && $ret->{synop} ne "") {
# 	    print "# $ret->{real_time}\n";
# 	    print $ret->{synop};
# 	    exit 0;
# 	} else {
# 	    exit 1;
# 	}
    }
}

my $ret = get_synop_from_fu();
if ($ret && $ret->{synops}) {
    my $real_time = $ret->{real_time};
 STATION:
    while(my($wmo_code, $synop) = each %{ $ret->{synops} }) {
	my $station_name = $stations{$wmo_code};
	if ($station_name && $synop ne "") {
	    my $store_file = "$store_dir/synop_$station_name";
	    #$store_file = "/tmp/synop_$station_name";
	    if (-e $store_file) {
		if (!changed_something($store_file, $real_time)) {
		    next STATION;
		}
	    }

	    if (!open(STORE, ">>$store_file")) {
		warn "Can't write to $store_file: $!";
		next STATION;
	    } else {
		print STORE "#$real_time\n";
		print STORE "$ret->{wmo_header}\n";
		print STORE "$synop\n\n";
		close STORE;
	    }
	}
    }
}
exit; 

# old code, site not working anymore
STATION:
while(my($station_code, $station_name) = each %stations) {
    warn "Trying station $station_name...\n";
    my $store_file = "$store_dir/synop_$station_name";

    my $result = get_synop($station_code);

    my($real_time, $synop, $station_code, $html)
	= @$result{qw(real_time synop station_code html)};

    if (!defined $synop || $synop eq '') {
	warn "No synop found for $station_name in $html";
	next STATION;
    }

    if (-e $store_file) {
	if (!changed_something($store_file, $real_time)) {
	    next STATION;
	}
    }

    if (!open(STORE, ">>$store_file")) {
	warn "Can't write to $store_file: $!";
	next STATION;
    } else {
	print STORE "#$real_time\n";
	print STORE "$synop\n";
	close STORE;
    }
}

sub changed_something {
    my($store_file, $real_time) = @_;
    my(@last_lines) = split /\n/, `tail -20 $store_file`;
    foreach (reverse @last_lines) {
	my($last_time) = $_ =~ /^\#(.*)/;
	if (defined $last_time && $last_time eq $real_time) {
	    warn "No change, last line: $_, this time: $real_time";
	    return 0;
	}
    }
    1;
}

sub get_last_from_file {
    my $station_code = shift;
    my $station_name = $stations{$station_code};
    my $store_file = "$store_dir/synop_$station_name";
    my(@last_lines) = split /\n/, `tail -20 $store_file`;
    @last_lines = reverse @last_lines;
    for my $i (0 .. $#last_lines) {
	if ($last_lines[$i] =~ /^\#(.*)/) {
	    return join("\n", reverse @last_lines[0..$i]) . "\n";
	}
    }
    undef;
}

sub get_synop_from_fu {
    my $ret = {};
    my %synops;
    #my $html = `GET file:/tmp/synops.php.html`;
    my $html = `GET http://prognose.met.fu-berlin.de/synops.php`;
    my $wmo_header;
    if ($html =~ m{(ZCZC[^<]+)}) {
	$wmo_header = $1;
    } else {
	die "Cannot parse wmo header from html <$html>";
    }
    while($html =~ m{<font.*?>\s*((\d{5})\s.*?)</font>}gs) {
	my($synop, $wmo_code) = ($1, $2);
	$synops{$wmo_code} = $synop;
    }

    my($time) = $wmo_header =~ /\S+\s+\S+\s+(\d{6})/;
    my $real_time = synop_time_to_real($time);

    return +{
	     time      => $time,
	     real_time => $real_time,
	     synops    => \%synops,
	     html      => $html,
	     wmo_header => $wmo_header,
	    };
}

sub get_synop {
    my $station_code = shift;

    my $ret = {};
    my $html = `GET "http://131.54.133.44/cgi-bin/ProductSearch.cgi?current=0&fmt=ll&form=20&frame=_top&prdid=AC&T=l&sub=S&icao=$station_code"`;
    #  my $html = <<EOF;
    #  <bla>
    #  <pre>
    #  SNDL10 KAWN 132300 RRA
    #  AAXX 13231
    #  10384 42973 01301 10127 20119 30160 40219 57002 333 55300
    #  </pre>
    #  <bla>
    #  EOF

    my $synop = "";
    if ($html ne '') {
	my $pre_seen = 0;
	foreach (split /\n/, $html) {
	    if (/<pre>/i) {
		$pre_seen++;
	    } elsif ($pre_seen) {
		if (/<\/pre>/i) {
		    last;
		}
		$synop .= "$_\n";
	    }
	}
    }

    if (!defined $synop || $synop eq '') {
	return;
    }

    my($time) = $synop =~ /\S+\s+\S+\s+(\d{6})/;
    my $real_time = synop_time_to_real($time);

    return +{
	     time      => $time,
	     real_time => $real_time,
	     synop     => $synop,
	     html      => $html,
	    };
}

sub synop_time_to_real {
    my $synop_time = shift;
    my($day,$h,$m) = $synop_time =~ /^(..)(..)(..)$/;
    if (!defined $day) {
	die "Can't parse synop time $synop_time";
    }
    my(@l) = localtime;
    my $ld = $l[3];
    my $lm = $l[4]+1;
    if ($ld != $day) {
	if ($day == 1 && $ld >= 28) {
	    # really next month:
	    $lm++;
	} elsif ($ld == 1 && $day >= 28) {
	    # really prev month;
	    $lm--;
	} # else this month
    }
    sprintf "%04d-%02d-%02d %02d:%02d", $l[5]+1900, $lm, $day, $h, $m;
}

__END__
