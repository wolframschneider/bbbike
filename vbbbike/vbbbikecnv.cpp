//=======================================================================
//@V@:Note: This file generated by vgen V1.02 (02:00:29 AM 17 May 1998).
//	vbbbikecnv.cpp:	Source for vbbbikeCanvasPane class
//=======================================================================

#include <iostream>

#include "vbbbikecnv.h"
#include "vbbbikeapp.h"
#include "transpose.h"
#include "bbbike.h"

inline int vbbbikeCanvasPane::getCategory(char* catStr) {
  int cat;
  switch (catStr[0]) {
  case 'H':
    switch (catStr[1]) {
    case 0: cat = Hitem; break;
    case 'H': cat = HHitem; break; // HH
    default: cat = Xitem;
    }
    break;
  case 'N':
    switch (catStr[1]) {
    case 0: cat = Nitem; break;
    case 'H': cat = NHitem; break; // NH
    case 'N': cat = NNitem; break; // NN
    defailt: cat = Xitem;
    }
    break;
  case 'B':
    cat = BABitem;
    break;
  case 'S':
    switch (catStr[1]) {
    case 'A': cat = SAitem; break;
    case 'B': cat = SBitem; break;
    case 'C': cat = SCitem; break;
    default: cat = Xitem;
    }
    break;
  case 'U':
    switch (catStr[1]) {
    case 'A': cat = UAitem; break;
    case 'B': cat = UBitem; break;
    default: cat = Xitem;
    }
    break;
  case 'F':
    if (catStr[1] == ':') {
      if (catStr[2] == 'W')
	cat = Witem | areaMask;
      else if (catStr[2] == 'P' || strcmp(&catStr[2], "FO") == 0)
	cat = Fitem | areaMask;
      else if (catStr[2] == 'B' && strcmp(&catStr[2], "BU") == 0)
	cat = BUitem | areaMask;
      else if (catStr[2] == 'H' && strcmp(&catStr[2], "HB") == 0)
	cat = HBitem | areaMask;
      else if (catStr[2] == 'I' && strcmp(&catStr[2], "IN") == 0)
	cat = INitem | areaMask;
      else
	cat = Xitem | areaMask;
    } else {
      cat = Fitem;
    }
    break;
  case 'W':
    cat = Witem;
    break;
  default:
    cat = Xitem;
  }
  return cat;
}

void vbbbikeCanvasPane::convertData() {

  int lineCount[MAXitem+1];
  int areaCount[MAXitem+1];
  for(int i = 0; i <= MAXitem; i++)
    lineCount[i] = areaCount[i] = 0;

  // get maximum count for each category
  for(int s_i = 0; s_i < ((vbbbikeApp*)theApp)->strCount; s_i++) {
    Strassen *str = ((vbbbikeApp*)theApp)->str[s_i];

    for(int i = 0; i < str->s_anzahl; i++) {
      Strasse *s = str->s[i];
      int cat = getCategory(s->category);
      int isArea = cat & areaMask;
      cat &= catMask;
      if (isArea) {
	areaCount[cat] ++;
      } else {
	lineCount[cat] += s->anzahl;
      }
    }
  }

  // allocate memory for canvas line item arrays
  for(int i = 0; i <= MAXitem; i++) {
    LineItemList[i].list = new CanvasLineItem*[lineCount[i]+1];
    for(int j = 0; j < lineCount[i]; j++) {
      LineItemList[i].list[j] = new CanvasLineItem;
    }
    AreaItemList[i].list = new CanvasAreaItem*[areaCount[i]+1];
    for(int j = 0; j < areaCount[i]; j++) {
      AreaItemList[i].list[j] = new CanvasAreaItem;
    }
  }

  int lineIter[MAXitem+1];
  int areaIter[MAXitem+1];
  for(int i = 0; i <= MAXitem; i++)
    lineIter[i] = areaIter[i] = 0;

  // iterate through all Strassen objects to fill the canvas line item arrays
  for(int s_i = 0; s_i < ((vbbbikeApp*)theApp)->strCount; s_i++) {
    Strassen *str = ((vbbbikeApp*)theApp)->str[s_i];

    for(int i = 0; i < str->s_anzahl; i++) {
      Strasse *s = str->s[i];
      int cat = getCategory(s->category);
      int isArea = cat & areaMask;
      cat &= catMask;

      if (!isArea) {
	for(int j = 1; j < s->anzahl; j++) {
	  int x1,x2,y1,y2;
	  transpose(s->x[j-1], s->y[j-1], x1, y1);
	  transpose(s->x[j],   s->y[j],   x2, y2);
	  LineItemList[cat].list[lineIter[cat]]->set(x1,y1,x2,y2);
	  lineIter[cat]++;
	}
      } else {
	AreaItemList[cat].list[areaIter[cat]]->elements(s->anzahl);
	for(int j = 0; j < s->anzahl; j++) {
	  int x1,y1;
	  transpose(s->x[j], s->y[j], x1, y1);
	  AreaItemList[cat].list[areaIter[cat]]->add(x1, y1);
	}
	areaIter[cat]++;
      }
    }
  }

  for(int i = 0; i <= MAXitem; i++) {
    LineItemList[i].count = lineIter[i];
    AreaItemList[i].count = areaIter[i];
  }
}

//===================>>> vbbbikeCanvasPane::vbbbikeCanvasPane <<<=============
  vbbbikeCanvasPane::vbbbikeCanvasPane()
  {
    convertData();
    dx = dy = 0;
    zoom = 1; // XXX ist noch nicht richtig

    grey = vColor(192,192,192);

    whitePen = vPen(255,255,255);
    blackPen = vPen(0,0,0);
    greenPen = vPen(0,255,0);
    yellowPen = vPen(255,255,0);
    darkYellowPen = vPen(238,238,0);
    bluePen = vPen(0,0,200);
    green3Pen = vPen(0,205,0);
    green4Pen = vPen(0,128,0);
    blue4Pen = vPen(0,0,128);
    lightBluePen = vPen(186,213,247);
    parkGreenPen = vPen(118,196,139);
    buPen = vPen(200,128,128);
    industrialPen = vPen(238,130,238);
    harbourPen = vPen(148,0,211);

    blueBrush = vBrush(0,0,200);
    lightBlueBrush = vBrush(186,213,247);
    whiteBrush = vBrush(255,255,255);
    parkGreenBrush = vBrush(118,196,139);
    buBrush = vBrush(200,128,128);
    industrialBrush = vBrush(238,130,238);
    harbourBrush = vBrush(148,0,211);

  }

//===================>>> vbbbikeCanvasPane::~vbbbikeCanvasPane <<<============
  vbbbikeCanvasPane::~vbbbikeCanvasPane()
  {
  }

//======================>>> vbbbikeCanvasPane::HPage <<<======================
  void vbbbikeCanvasPane::HPage(int shown, int top)
  {
    vCanvasPane::HPage(shown, top);
    Redraw(0, 0, GetWidth(), GetHeight());
  }

//======================>>> vbbbikeCanvasPane::VPage <<<======================
  void vbbbikeCanvasPane::VPage(int shown, int top)
  {
    vCanvasPane::VPage(shown, top);
    Redraw(0, 0, GetWidth(), GetHeight());
  }

//=======================>>> vbbbikeCanvasPane::HScroll <<<===================
  void vbbbikeCanvasPane::HScroll(int step)
  {
    vCanvasPane::HScroll(step);
    int shown, top;
    GetHScroll(shown, top);
    SetHScroll(shown, top+step);
    Redraw(0, 0, GetWidth(), GetHeight());
  }

//======================>>> vbbbikeCanvasPane::VScroll <<<====================
  void vbbbikeCanvasPane::VScroll(int step)
  {
    vCanvasPane::VScroll(step);
    int shown, top;
    GetVScroll(shown, top);
    SetVScroll(shown, top+step);
    Redraw(0, 0, GetWidth(), GetHeight());
  }

//======================>>> vbbbikeCanvasPane::MouseDown <<<==================
  void vbbbikeCanvasPane::MouseDown(int X, int Y, int button)
  {
    vCanvasPane::MouseDown(X,Y,button);
  }

//========================>>> vbbbikeCanvasPane::MouseUp <<<==================
  void vbbbikeCanvasPane::MouseUp(int X, int Y, int button)
  {

    adjust(X, Y);
    X = (int)((double)X/zoom);
    Y = (int)((double)Y/zoom);

    int real_x, real_y;
    int nearest_x, nearest_y;
    anti_transpose(X, Y, real_x, real_y);
    Strassen *str = ((vbbbikeApp*)theApp)->str[0];
    str->kreuzungen.find_nearest(real_x, real_y, nearest_x, nearest_y);
    if (!((vbbbikeApp*)theApp)->waitForGoal) {
      koordptr_t startPtr = koordptr_by_koord(nearest_x, nearest_y);
      if (startPtr == -1) {
        std::cerr << "Can't find pointer for start "
                  << nearest_x << "/" << nearest_y << std::endl;
        return;
      }

      ((vbbbikeApp*)theApp)->startPtr    = startPtr;
      ((vbbbikeApp*)theApp)->waitForGoal = true;

      if (((vbbbikeApp*)theApp)->route) {
        free_route(((vbbbikeApp*)theApp)->route);
        reset_best_len();
        ((vbbbikeApp*)theApp)->route = NULL;
      }

      drawRoute();

    } else {
      koordptr_t goalPtr = koordptr_by_koord(nearest_x, nearest_y);
      if (goalPtr == -1) {
        std::cerr << "Can't find pointer for goal "
                  << nearest_x  << "/" << nearest_y << std::endl;
        return;
      }

      ((vbbbikeApp*)theApp)->waitForGoal = false;

      ((vbbbikeApp*)theApp)->route = init_route();
      ((vbbbikeApp*)theApp)->routeSlot =
        search_route(((vbbbikeApp*)theApp)->route,
                     ((vbbbikeApp*)theApp)->startPtr, goalPtr);
      Redraw(0, 0, GetWidth(), GetHeight());

    }
  }

//======================>>> vbbbikeCanvasPane::MouseMove <<<==================
  void vbbbikeCanvasPane::MouseMove(int x, int y, int button)
  {
    vCanvasPane::MouseMove(x,y,button);
  }

//=========================>>> vbbbikeCanvasPane::Redraw <<<==================
  void vbbbikeCanvasPane::Redraw(int x, int y, int w, int h)
  {

    static int nest = 0;
fprintf(stderr, "Redraw %d/%d - %d/%d, nest=%d\n", x,y,w,h,nest);
    if (++nest > 1) return;
   
    doRedraw(x, y, w, h);

    if (nest > 1)
      doRedraw(x, y, w, h);

    nest = 0;
  }

  void vbbbikeCanvasPane::doRedraw(int x, int y, int w, int h)
  {
    int hshown, vshown, htop, vtop;

    getDelta(dx, dy);
    
    int xx = x+w;
    int yy = y+h;
#if 0
printf("%d %d %d %d\n", x, xx, y, yy);
#endif

    SetBackground(grey);
    Clear();
    for(int i = 0; i <= MAXitem; i++) {
      for(int drawType = 0; drawType < 2; drawType++) {
	switch (i) {
	case BABitem: SetPen(bluePen); break;
	case HHitem:  SetPen(darkYellowPen); break;
	case Hitem:   SetPen(yellowPen); break;
	case NHitem:  SetPen(whitePen); break;
	case Nitem:   SetPen(whitePen); break;
	case NNitem:  SetPen(greenPen); break;
	case SAitem:
	case SBitem:  SetPen(green3Pen); break;
	case SCitem:  SetPen(green4Pen); break;
	case UAitem:
	case UBitem:  SetPen(blue4Pen); break;
	case Witem:
	  SetPen(lightBluePen);
	  SetBrush(lightBlueBrush);
	  break;
	case Fitem:
	  SetPen(parkGreenPen);
	  SetBrush(parkGreenBrush);
	  break;
	case Xitem:
	  SetPen(whitePen);
	  SetBrush(whiteBrush);
	  break;
	case BUitem:
	  SetPen(buPen);
	  SetBrush(buBrush);
	  break;
	case INitem:
	  SetPen(industrialPen);
	  SetBrush(industrialBrush);
	  break;
	case HBitem:
	  SetPen(harbourPen);
	  SetBrush(harbourBrush);
	  break;
	}

#if 0
printf("drawtype=%d itemtype=%d\n", drawType, i);
#endif
	if (drawType == 0) { // lines
	  CanvasLineItem **list = LineItemList[i].list;
	  for(int j = 0; j < LineItemList[i].count; j++) {
	    int x1,x2,y1,y2;
	    x1 = int((list[j]->x1 - dx)*zoom);
	    x2 = int((list[j]->x2 - dx)*zoom);
	    y1 = int((list[j]->y1 - dy)*zoom);
	    y2 = int((list[j]->y2 - dy)*zoom);
	    
	    if ((x1 >= x && x1 <= xx && y1 >= y && y1 <= yy) ||
		(x1 >= x && x1 <= xx && y2 >= y && y2 <= yy) ||
		(x2 >= x && x2 <= xx && y1 >= y && y1 <= yy) ||
		(x2 >= x && x2 <= xx && y2 >= y && y2 <= yy))
	      DrawLine(x1, y1, x2, y2);
	  } 
	} else { // drawType == 1, areas
	  CanvasAreaItem **list = AreaItemList[i].list;
	  for(int j = 0; j < AreaItemList[i].count; j++) {
	    int x1 = int((list[j]->minx - dx)*zoom);
	    int x2 = int((list[j]->maxx - dx)*zoom);
	    int y1 = int((list[j]->miny - dy)*zoom);
	    int y2 = int((list[j]->maxy - dy)*zoom);

	    if ((x1 >= x && x1 <= xx && y1 >= y && y1 <= yy) ||
		(x1 >= x && x1 <= xx && y2 >= y && y2 <= yy) ||
		(x2 >= x && x2 <= xx && y1 >= y && y1 <= yy) ||
		(x2 >= x && x2 <= xx && y2 >= y && y2 <= yy)) {
	      vPoint *copyPoints = new vPoint[list[j]->no];
	      for(int k = 0; k < list[j]->no; k++) {
		copyPoints[k].x = int((list[j]->points[k].x - dx)*zoom);
		copyPoints[k].y = int((list[j]->points[k].y - dy)*zoom);
	      }
	      DrawPolygon(list[j]->no, copyPoints);
	      delete copyPoints;
	    }
	  }
	}
      }
    }
    
    drawRoute();
  }

//======================>>> vbbbikeCanvasPane::Resize <<<======================
  void vbbbikeCanvasPane::Resize(int w, int h)
  {
    vCanvasPane::Resize(w,h);
  }

  void vbbbikeCanvasPane::drawRoute()
  {

    if (((vbbbikeApp*)theApp)->startPtr > 0) {
      int x1,y1;
      GETXY(((vbbbikeApp*)theApp)->startPtr, x1,y1);
      int tx1,ty1;
      transpose(x1,y1,tx1,ty1);
      SetPen(bluePen);
      SetBrush(blueBrush);
      DrawEllipse(int((tx1-dx)*zoom)-2,
                  int((ty1-dy)*zoom)-2,4,4);
    }

    if (((vbbbikeApp*)theApp)->route) {
      struct route *route =
        ((vbbbikeApp*)theApp)->route[((vbbbikeApp*)theApp)->routeSlot];
      SetPen(bluePen);

      for(int j=1; j<route->arrlen; j++) {
        int x1,y1, x2,y2;
        GETXY(route->data[j-1], x1,y1);
        GETXY(route->data[j],   x2,y2);

        int tx1,ty1, tx2,ty2;
        transpose(x1,y1,tx1,ty1);
        transpose(x2,y2,tx2,ty2);
        DrawLine(int((tx1-dx)*zoom),
                 int((ty1-dy)*zoom),
                 int((tx2-dx)*zoom),
                 int((ty2-dy)*zoom));
      }
    }
  }

  void vbbbikeCanvasPane::adjust(int& X, int& Y)
  {
    getDelta(dx, dy);

    X += dx;
    Y += dy;
  }

  void vbbbikeCanvasPane::getDelta(int& dx, int& dy)
  {
    int hshown, vshown, htop, vtop;
    GetHScroll(hshown, htop);
    GetVScroll(vshown, vtop);
    dx = htop*xm-x0;
    dy = vtop*ym-y0;
  }
