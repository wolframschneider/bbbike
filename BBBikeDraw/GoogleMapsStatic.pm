# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2008,2009 Slaven Rezic. All rights reserved.
# This package is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

=head1 NAME

BBBikeDraw::GoogleMapsStatic - draw maps via the Google Static Maps API

=head1 SYNOPSIS

From command line:

    ./miscsrc/bbbikedraw.pl -bbox 8000,8000,12000,12000 -module GoogleMapsStatic -imagetype png | display -
    ./miscsrc/bbbikedraw.pl -markerpoint 10000,1000 -routefile /path/to/track.trk -bbox 8000,8000,12000,12000 -module GoogleMapsStatic -imagetype png | display -

For module usage see L<BBBikeDraw>.

=head1 TODO

The URI length of the API request is limited to 2048 bytes for the
path part. It would be nice to automatically use a simplification
algortihm (e.g. douglas-peucker) for the path (which is generated by
the -routefile).

Rough algorithm sketch:

  - create a function douglas_peuker_loop or simplify_loop (which might be something
  binsearch-like, or for an easier impl. just de/increase some parameter
  for the next iteration. have an additional stop condition to avoid endless or too
  long loops)

  - the function would get a list of coords, a stop condition (simply
  a callback which returns bool, input is list of coords), and somehow a decrease value (could
  also be a callback to calculate the new value), and a maximum number
  of iterations

  - the function would return the simplified list of coords, the number
  of iterations, the currently used coefficient, if the loop was quit
  prematurely
  
  the stop condition here would be: generate the googlemaps URL using
  the current list of coords. return true if it is <= 2048
  
  if the uri is still too long, then crop the coords just before the
  last one. maybe use different coloring to signal the bad accuracy? and
  also WARN loudly that it was cropped.

=head1 AUTHOR

Slaven Rezic

=head1 SEE ALSO

L<BBBikeDraw>.

=cut

package BBBikeDraw::GoogleMapsStatic;

use strict;
use vars qw($VERSION $DEBUG);
$VERSION = sprintf("%d.%02d", q$Revision: 1.1 $ =~ /(\d+)\.(\d+)/);

use base qw(BBBikeDraw);

use CGI            qw();
use LWP::UserAgent qw();

use Karte;
Karte::preload(qw(Standard Polar));

sub pre_draw {
    my $self = shift;
    $self->{PreDrawCalled}++;
}

sub draw_route { } # dummy, everything's done in flush()

sub flush {
    my $self = shift;
    my %args = @_;

    my $ua = LWP::UserAgent->new;
    $ua->agent($ua->agent . " (" . __PACKAGE__ . " " . $VERSION . ")");

    my $google_api_key_file = "$ENV{HOME}/.googlemapsapikey";
    my $my_api_key;
    if (open(APIKEY, $google_api_key_file)) {
	$my_api_key = <APIKEY>;
	$my_api_key =~ s{[\r\n\s+]}{}g;
	close APIKEY;
	warn "Loaded Google Maps API key from $google_api_key_file...\n" if $DEBUG;
    }
    if (!$my_api_key) {
	die "No googlemapsapikey, cannot continue...";
    }

    my @multi_c = @{ $self->{MultiCoords} || [] } ? @{ $self->{MultiCoords} } : @{ $self->{Coords} || [] } ? [ @{ $self->{Coords} } ] : ();
    my $path;
    my $center;
    if (@multi_c) {
	$path = join("|", map { join("|", map {
	    my($x, $y) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	    $y.",".$x;
	} @$_) } @multi_c);
	$path = 'rgb:0x0000ff,weight:5|' . $path; # XXX make settable
    } else {
	my($cx,$cy) = ($self->{Min_x} + ($self->{Max_x}-$self->{Min_x})/2,
		       $self->{Min_y} + ($self->{Max_y}-$self->{Min_y})/2,
		      );
	($cx,$cy) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map($cx, $cy));
	$center = $cy.",".$cx;
    }

    my $marker_c;
    if ($self->{MarkerPoint}) {
	my($x,$y) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $self->{MarkerPoint}));
	$marker_c = "$y,$x";
    }

    my $format = ($self->{ImageType} eq 'png' ? 'png32' :
		  $self->{ImageType} eq 'jpeg' ? 'jpg' : 'gif');

    # max imagesize according to http://code.google.com/apis/maps/documentation/staticmaps/#Imagesizes
    my $w = $self->{Width};
    my $h = $self->{Height};
    if ($w > 640) {
	$h = $h*(640/$w);
	$w = 640;
    }
    if ($h > 640) {
	$w = $w*(640/$h);
	$h = 640;
    }

    CGI->import('-oldstyle_urls');
    my $qs = CGI->new({size => $w."x".$h,
		       maptype => "mobile", # XXX make settable
		       ($marker_c ? (markers => "$marker_c,red") : ()),
		       # markers=40.702147,-74.015794,blues%7C40.711614,-74.012318,greeng%7C40.718217,-73.998284,redc
		       key => $my_api_key,
		       format => $format,
		       ($path ? (path => $path) :
			( center => $center,
			  zoom => 14, # XXX
			)
		       ),
		      })->query_string;
    my $url = "http://maps.google.com/staticmap?$qs";
    my $resp = $ua->get($url);
    die "Error while getting $url: " . $resp->status_line if !$resp->is_success;

    my $fh = $args{Fh} || $self->{Fh};
    binmode $fh;
    print $fh $resp->decoded_content;
}

1;

__END__
