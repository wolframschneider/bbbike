#!/usr/local/bin/perl
#
# elevation-database - get elevation data
#
use strict;
use warnings;

use Storable;
use Getopt::Long;
use LWP::UserAgent;
use IO::File;
use XML::Simple;
use Data::Dumper;

######################################################################
# geonames.org API for elevation data:
#
# http://www.geonames.org/export/web-services.html#srtm3
#
# http://api.geonames.org/srtm3?lat=50.01&lng=10.2&username=demo
# http://api.geonames.org/srtm3?lats=50.01,51.01&lngs=10.2,11.2&username=demo

my $debug = 1;
my $database;
my $socksproxy;
my $readonly_database = 0;
my $api_url           = 'http://api.geonames.org/srtm3?username=demo';
my $data_osm_dir      = "data-osm";
my $max_points = 20;                                     # limit of geonames.org
my $user_agent = "BBBike @ World - http://bbbike.org";
my $sleep      = 2.5;

sub usage () {
    my $message = shift;

    warn $message, "\n" if $message;
    die <<EOF;
usage: $0 [options] cities ...

--database=elevation.database
--socksproxy=socks://host:port   set socks proxy
--readonly-database
--data-osm-dir=/path/to/bbbike/data-osm
--user-anget="user agent version xyz"
--sleep=$sleep
EOF
}

######################################################################
#
sub init_height_db {
    my $file = shift;

    my %height_db;
    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";

    my $use_rounding = 1;

    while (<$fd>) {
        chomp;
        my ( $height, $x, $coord ) = split;

        if ( !defined $height || !defined $x || !defined $coord ) {
            warn "Ignore broken line in height db: $_\n";
            next;
        }

        if ($use_rounding) {
            $height = int( $height + 0.5 );
        }

        $height_db{$coord} = $height;
    }
    close $fd;

    return \%height_db;
}

sub download {
    my $ua   = shift;
    my $uri  = shift;
    my $city = shift || "";

    warn "download URL for city: $city $uri\n" if $debug >= 2;

    my $response = $ua->get($uri);
    if ( $response->is_success ) {
        my $data = $response->decoded_content;    # or whatever
        return $data;
    }
    else {
        warn "Download failed: ", $response->status_line, "\n";
    }
}

sub padding {
    my $lat = shift;

    my ( $int, $dec ) = split( /\./, $lat );
    if ( !defined $dec ) {
        $dec = "";
        $lat .= '.';
    }

    while ( length($dec) < 7 ) {
        $dec .= '0';
        $lat .= '0';
    }
    return $lat;
}

sub activate_socksproxy {
    my $ua = shift;

    if ( !$ua ) {
        warn "LWP::UserAgent is not set, ignore socks proxy!\n";
        return;
    }

    eval {
        require LWP::Protocol::socks;
        $ua->proxy( [qw(http https)] => $socksproxy );
    };

    if ($@) {
        warn "Cannot load LWP::Protocol::socks, ignore socks proxy...\n";
        return;
    }
}

sub parse_hoehe {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        my ( $elevation, $x, $lnglat ) = split();
        if ( !$lnglat ) {
            warn "Unknown height in 'hoehe' file: $_\n" if $debug >= 2;
            next;
        }

        $hash->{$lnglat} = $elevation;
    }

    return $hash;
}

sub parse_streets {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    my $counter = 0;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        s/^[^\t]*\t\S+\s+//;

        my @points = split;
        foreach my $point (@points) {
            if ( exists $hash->{$point} ) {
                $hash->{$point}++;
                $counter++;
            }
            else {
                $hash->{$point} = 1;
            }
        }

    }

    warn "Corner count: $counter\n" if $debug;
    return $hash;
}

sub get_elevation_data {
    my $hash = shift;
    my $data = shift;
    my $ua   = shift;
    my $city = shift;

    my @data = @$data;

    # nothing to do?
    return if $#data < 0;

    my ( @lng, @lat );
    foreach my $key (@data) {
        my ( $lng, $lat ) = split ",", $key;
        push @lng, $lng;
        push @lat, $lat;
    }

    my $url =
      $api_url . '&lngs=' . join( ",", @lng ) . '&lats=' . join( ",", @lat );

    my $content = download( $ua, $url, $city );
    if ($content) {
        warn $content if $debug >= 3;
        my @heights = split( "\r\n", $content );

        if ( $#heights != $#data ) {
            warn "odd number of heights: $#heights != $#data\n";
        }
        else {
            for ( my $i = 0 ; $i < scalar(@heights) ; $i++ ) {
                my $height = $heights[$i];
                if ( $height && $height =~ /^[\d\-]+/ ) {
                    $hash->{ $data[$i] } = $height;
                }
                else {
                    warn "height '$height' is not a number!\n" if $debug >= 2;
                }
            }
        }

    }

    &mysleep($sleep);
    undef @$data;
}

sub mysleep {
    my $seconds = shift || "0.5";

    # sleep a half second
    select( undef, undef, undef, $seconds );
}

sub update_hoehe {
    my %args = @_;

    my $file   = $args{'file'};
    my $points = $args{'points'};
    my $hash   = $args{'database'};

    my $tmp = "$file.new";
    my $fd = new IO::File $tmp, "w" or die "open '$tmp': $!\n";
    binmode $fd, ":raw";

    foreach my $point (@$points) {
        if ( defined $hash->{$point} ) {
            print $fd $hash->{$point}, "\tX ", $point, "\n";
        }
        else {
            warn "undefined height: $point\n" if $debug >= 3;
        }
    }
    $fd->close;

    rename( $tmp, $file ) or die "rename $tmp -> $file: $!\n";
}

sub update_city {
    my %args = @_;
    my $city = $args{'city'};
    my $ua   = $args{'ua'};
    my $hash = $args{'database'};

    my $dir = "$data_osm_dir/$city";

    my $height  = &parse_hoehe("$dir/hoehe");
    my $streets = &parse_streets("$dir/strassen");

    # fill database with data from "hoehe" file
    while ( my ( $key, $val ) = each %$height ) {
        if ( !exists $hash->{$key} ) {
            $hash->{$key} = $val;
        }
    }

    my @data;
    my $c       = 0;
    my @corners = ();
    while ( my ( $key, $val ) = each %$streets ) {

        # no corner
        next if $val == 1;

        # all corners
        push @corners, $key;

        if ( exists $hash->{$key} ) {
            print "found: $key\n" if $debug >= 2;
        }
        else {
            push @data, $key;
        }
        &get_elevation_data( $hash, \@data, $ua, $city )
          if scalar(@data) >= $max_points;

        #last if $c++ >= 40;
    }

    # the rest
    &get_elevation_data( $hash, \@data, $ua, $city );

    &update_hoehe(
        'file'     => "$dir/hoehe2",
        'points'   => \@corners,
        'database' => $hash
    );

    return $hash;
}

sub read_database {
    my $database = shift;

    my $hash = {};

    if ( $database && -f $database ) {
        $hash = retrieve($database)
          or die "Storable.pm retrieve: $database $!\n";
    }

    return $hash;
}

sub write_database {
    my $database = shift;
    my $hash     = shift;

    return if !$database;

    store( $hash, $database ) or die "Storable.pm store: $database: $!\n";
}

######################################################################
# main
#

my $help;
GetOptions(
    "help"              => \$help,
    "debug=i"           => \$debug,
    "database=s"        => \$database,
    "socksproxy=s"      => \$socksproxy,
    "readonly-database" => \$readonly_database,
    "data-osm-dir=s"    => \$data_osm_dir,
    "user-agent=s"      => \$user_agent,
) or usage;

&usage if $help;

my @cities = @ARGV;
&usage("Missing the cities!\n") if !@cities;

my $ua = LWP::UserAgent->new;
$ua->agent($user_agent);
activate_socksproxy($ua) if $socksproxy;

my $hash = read_database($database);
foreach my $city (@cities) {
    warn "City: $city\n" if $debug;
    $hash = &update_city( 'city' => $city, 'ua' => $ua, 'database' => $hash );
}

# write database
&write_database( $database, $hash ) if !$readonly_database;

