#!/usr/local/bin/perl
# Copyright (c) Feb 2011 Wolfram Schneider, http://bbbike.org
#
# elevation-database - fetch SRTM3 elevation data for points in planet.osm without elevation infos
#

use Storable;
use Getopt::Long;
use LWP::UserAgent;
use IO::File;
use XML::Simple;
use Data::Dumper;

use strict;
use warnings;

######################################################################
# geonames.org API for elevation data:
#
# http://www.geonames.org/export/web-services.html#srtm3
#
# http://api.geonames.org/srtm3?lat=50.01&lng=10.2&username=demo
# http://api.geonames.org/srtm3?lats=50.01,51.01&lngs=10.2,11.2&username=demo
#

my $debug    = 1;
my $database = "";
my $socksproxy;
my $readonly_database = 0;
my $api_url           = 'http://api.geonames.org/srtm3?username=bbbike';
my $data_osm_dir      = "data-osm";
my $max_points = 20;                                     # limit of geonames.org
my $user_agent = "BBBike @ World - http://bbbike.org";
my $sleep      = 2.5;
my $check_database;
my $repair_database;
my $exit_on_error = 1;
my $test_mode     = 0;

my $NO_DATA = -32768;

sub usage () {
    my $message = shift;

    warn $message, "\n" if $message;
    die <<EOF;
usage: $0 [options] cities ...

--database=elevation.database
--socksproxy=socks://host:port   set socks proxy
--readonly-database
--data-osm-dir=/path/to/bbbike/data-osm
--user-anget="user agent version xyz"
--sleep=$sleep
--check-database
--repair-database
--exit-on-error=[0,1]
--test-mode
EOF
}

######################################################################
# helper functions
#

sub hoehe_header {

    return <<EOF;
#: #: -*- coding: utf-8 -*-
#:encoding: utf-8
#:map: polar
#:date: fixed
#:
#
# OpenStreetMap data can be used freely under the terms of the 
# Creative Commons Attribution-ShareAlike 2.0 license.
# http://wiki.openstreetmap.org/index.php/OpenStreetMap_License
#
# Converted from openstreetmap data using
# /home/wosch/projects/bbbike/miscsrc/osm2bbd v0.11
# DO NOT EDIT THIS FILE! Edit the original openstreetmap data!
#
EOF
}

sub Die {
    my $message = shift;
    warn $message;
    alarm(0);
    exit(1);
}

sub read_database {
    my $database = shift;

    my $hash = {};

    if ( $database && -f $database ) {
        $hash = retrieve($database)
          or die "Storable.pm retrieve error for database '$database'\n";
    }
    else {
        warn "database '$database' does not exists (yet) or not readable!\n";
    }

    return $hash;
}

sub write_database {
    my $database = shift;
    my $hash     = shift;
    my $counter  = shift || "unknown";

    return if !$database;
    if ($test_mode) {
        warn "updates: $counter\n" if $debug;
        return;
    }

    warn "Store hash in file '$database', updates: $counter\n" if $debug;

    # atomic store of data
    my $new_db = "$database.new";
    store( $hash, $new_db ) or die "Write Storable.pm store: $new_db: $!\n";
    rename( $new_db, $database ) or die "rename $new_db -> $database: $!\n";

}

sub check_database {
    my $hash = shift;

    while ( my ( $key, $val ) = each %$hash ) {

        # unknown value
        next if $val eq "" && $key =~ /^[\d\-\,\.]+$/;

        print "$key => $val\n"
          if $val !~ /^[\d-]+$/ || $key !~ /^[\d\-\,\.]+$/ || $val == -32768;
    }
}

sub repair_database {
    my $hash     = shift;
    my $database = shift;

    while ( my ( $key, $val ) = each %$hash ) {
        if ( !$val || $val eq "" || $val eq "-32768" || $val !~ /^[\d-]+$/ ) {
            $val = "";
            $hash->{$key} = $val;
        }

        if ( $key !~ /^[\d\-\,\.]+$/ ) {
            warn "Delete '$key' => '$val'\n" if $debug >= 2;
            delete $hash->{$key};
        }
    }

    &write_database( $database, $hash );
}

sub set_signal_handler {
    my %args              = @_;
    my $database          = $args{'database'};
    my $hash              = $args{'hash'};
    my $readonly_database = $args{'readonly_database'};

    if ( !$database || $readonly_database ) {
        warn "Nothing to store in database '$database'\n";
        return;
    }

    $SIG{INFO} = $SIG{HUP} = $SIG{ALRM} =
      sub { &write_database( $database, $hash ); };
    $SIG{INT} = sub { &write_database( $database, $hash ); exit(0) };
}

sub download_uri {
    my $ua   = shift;
    my $uri  = shift;
    my $city = shift || "";

    warn "download URL for city: $city $uri\n" if $debug >= 2;
    return if $test_mode;

    my $response = $ua->get($uri);
    if ( $response->is_success ) {
        my $data = $response->decoded_content;    # or whatever
        return $data;
    }
    else {
        warn "Download failed: ", $response->status_line, "\n";
    }
}

sub activate_socksproxy {
    my $ua = shift;

    if ( !$ua ) {
        warn "LWP::UserAgent is not set, ignore socks proxy!\n";
        return;
    }

    eval {
        require LWP::Protocol::socks;
        $ua->proxy( [qw(http https)] => $socksproxy );
    };

    if ($@) {
        warn "Cannot load LWP::Protocol::socks, ignore socks proxy...\n";
        return;
    }
}

sub parse_hoehe {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        my ( $elevation, $x, $lnglat ) = split();
        if ( !$lnglat ) {
            warn "Unknown height in 'hoehe' file: $_\n" if $debug >= 2;
            next;
        }

        $hash->{$lnglat} = $elevation;
    }

    return $hash;
}

sub parse_streets {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    my $counter = 0;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        s/^[^\t]*\t\S+\s+//;

        my @points = split;
        foreach my $point (@points) {
            if ( exists $hash->{$point} ) {
                $hash->{$point}++;
                $counter++;
            }
            else {
                $hash->{$point} = 1;
            }
        }

    }

    warn "Corner count: $counter\n" if $debug;
    return $hash;
}

sub get_elevation_data {
    my $hash = shift;
    my $data = shift;
    my $ua   = shift;
    my $city = shift;

    my @data = @$data;

    # nothing to do?
    return if $#data < 0;

    my ( @lng, @lat );
    foreach my $key (@data) {
        my ( $lng, $lat ) = split ",", $key;
        push @lng, $lng;
        push @lat, $lat;
    }

    my $url =
      $api_url . '&lngs=' . join( ",", @lng ) . '&lats=' . join( ",", @lat );

    my $content = download_uri( $ua, $url, $city );
    if ($content) {
        warn $content if $debug >= 3;
        my @heights = split( "\r\n", $content );

        if ( $#heights != $#data ) {
            warn "odd number of heights: $#heights != $#data\n";
            Die("Give up\n") if $exit_on_error;
        }

        else {
            for ( my $i = 0 ; $i < scalar(@heights) ; $i++ ) {
                my $height = $heights[$i];
                if ( defined $height && $height =~ /^[\d\-]+$/ ) {
                    if ( $height == $NO_DATA ) {
                        warn "unknown height for: ", $data[$i], "\n";

                        # keep negative hit cache
                        $height = "";
                    }
                    $hash->{ $data[$i] } = $height;
                }
                else {
                    warn "height '$height' is not a number!\n" if $debug >= 2;
                }
            }
        }

    }

    &mysleep($sleep);
    undef @$data;
}

# sleep in seconds.miliseconds
sub mysleep {
    my $seconds = shift || "0.5";

    return if $test_mode;

    # sleep a half second
    select( undef, undef, undef, $seconds );
}

sub update_hoehe {
    my %args = @_;

    my $file   = $args{'file'};
    my $points = $args{'points'};
    my $hash   = $args{'database'};

    my $tmp = "$file.new";
    my $fd = new IO::File $tmp, "w" or die "open '$tmp': $!\n";
    binmode $fd, ":raw";

    print $fd &hoehe_header;

    foreach my $point (@$points) {
        if ( defined $hash->{$point} ) {
            print $fd $hash->{$point}, "\tX ", $point, "\n";
        }
        else {
            warn "undefined height: $point\n" if $debug >= 3;
        }
    }
    $fd->close;

    rename( $tmp, $file ) or die "rename $tmp -> $file: $!\n";
}

sub update_city {
    my %args = @_;
    my $city = $args{'city'};
    my $ua   = $args{'ua'};
    my $hash = $args{'database'};

    my $dir = "$data_osm_dir/$city";

    my $height  = &parse_hoehe("$dir/hoehe");
    my $streets = &parse_streets("$dir/strassen");

    # fill database with data from "hoehe" file
    while ( my ( $key, $val ) = each %$height ) {
        if ( !exists $hash->{$key} ) {
            $hash->{$key} = $val;
        }
    }

    my @data;
    my $c       = 0;
    my @corners = ();
    my $counter = 0;
    while ( my ( $key, $val ) = each %$streets ) {

        # no corner
        next if $val == 1;

        # all corners
        push @corners, $key;

        if ( exists $hash->{$key} ) {
            warn "found: $key\n" if $debug >= 3;
        }
        else {
            push @data, $key;
            $counter++;
        }
        &get_elevation_data( $hash, \@data, $ua, $city )
          if scalar(@data) >= $max_points;

        #last if $c++ >= 40;
    }

    # the rest
    &get_elevation_data( $hash, \@data, $ua, $city );

    &update_hoehe(
        'file'     => "$dir/hoehe2",
        'points'   => \@corners,
        'database' => $hash
    );

    return ( $hash, $counter );
}

######################################################################
# main
#

my $help;
GetOptions(
    "help"              => \$help,
    "debug=i"           => \$debug,
    "database=s"        => \$database,
    "socksproxy=s"      => \$socksproxy,
    "readonly-database" => \$readonly_database,
    "data-osm-dir=s"    => \$data_osm_dir,
    "user-agent=s"      => \$user_agent,
    "check-database"    => \$check_database,
    "repair-database"   => \$repair_database,
    "test-mode"         => \$test_mode,
    "exit-on-error=i"   => \$exit_on_error,
) or usage;

&usage if $help;

my $hash = read_database($database);

if ($check_database) {
    &check_database($hash);
    exit;
}

# set signal handler to save state of the database
&set_signal_handler(
    'database'          => $database,
    'hash'              => $hash,
    'readonly_database' => $readonly_database
);

if ($repair_database) {
    &repair_database( $hash, $database );
    exit;
}

my @cities = @ARGV;
&usage("Missing the cities!\n") if !@cities;

# set networking
my $ua = LWP::UserAgent->new;
$ua->agent($user_agent);
activate_socksproxy($ua) if $socksproxy;

my $counter;
my $total_counter = 0;
# walk throught the list of cities
foreach my $city (@cities) {
    warn "City: $city\n" if $debug;
    ( $hash, $counter ) =
      &update_city( 'city' => $city, 'ua' => $ua, 'database' => $hash );
    $total_counter += $counter;

    # write database
    &write_database( $database, $hash, $counter )
      if !$readonly_database && $counter;
}

warn "Total updates: $total_counter\n" if $debug;

