#!/usr/local/bin/perl
#
# elevation-database - get elevation data
#
use strict;
use warnings;

use Storable;
use Getopt::Long;
use LWP::UserAgent;
use IO::File;
use XML::Simple;
use Data::Dumper;

######################################################################
# geonames.org API for elevation data:
#
# http://www.geonames.org/export/web-services.html#srtm3
#
# http://api.geonames.org/srtm3?lats=50.01,51.01&lngs=10.2,11.2&username=demo

sub usage () {
    my $message = shift;

    warn $message, "\n" if $message;
    die <<EOF;
usage: $0 [options] cities ...

--database=elevation.db
--socksproxy=socks://host:port   set socks proxy
--readonly-database
--data-osm-dir=/path/to/bbbike/data-osm
EOF
}

my $debug = 1;
my $database;
my $socksproxy;
my $readonly_database = 0;
my $api_url           = 'http://api.geonames.org/srtm3?username=demo';
my $data_osm_dir      = "data-osm";

######################################################################
#
sub init_height_db {
    my $file = shift;

    my %height_db;
    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";

    my $use_rounding = 1;

    while (<$fd>) {
        chomp;
        my ( $height, $x, $coord ) = split;

        if ( !defined $height || !defined $x || !defined $coord ) {
            warn "Ignore broken line in height db: $_\n";
            next;
        }

        if ($use_rounding) {
            $height = int( $height + 0.5 );
        }

        $height_db{$coord} = $height;
    }
    close $fd;

    return \%height_db;
}

sub download {
    my $ua  = shift;
    my $uri = shift;

    warn "download URL: $uri\n" if $debug >= 1;

    my $response = $ua->get($uri);
    if ( $response->is_success ) {
        my $data = $response->decoded_content;    # or whatever
        my $obj  = XMLin($data);
        if ( $obj->{'status'} ne 'OK' ) {
            die "ERROR status: ", $obj->{'status'}, "\n";
            return;
        }

        # height  X lng,lat
        # 108     X 13.0669708,52.3508471

        my @obj =
          ref $obj->{'result'} eq 'ARRAY'
          ? @{ $obj->{'result'} }
          : $obj->{'result'};
        foreach my $result (@obj) {
            print $result->{'elevation'}, "\tX ",
              $result->{'location'}->{'lng'}, q{,},
              $result->{'location'}->{'lat'}, "\n";
        }
    }
    else {
        warn "Download failed: ", $response->status_line, "\n";
    }
}

sub padding {
    my $lat = shift;

    my ( $int, $dec ) = split( /\./, $lat );
    if ( !defined $dec ) {
        $dec = "";
        $lat .= '.';
    }

    while ( length($dec) < 7 ) {
        $dec .= '0';
        $lat .= '0';
    }
    return $lat;
}

sub activate_socksproxy {
    my $ua = shift;

    if ( !$ua ) {
        warn "LWP::UserAgent is not set, ignore socks proxy!\n";
        return;
    }

    eval {
        require LWP::Protocol::socks;
        $ua->proxy( [qw(http https)] => $socksproxy );
    };

    if ($@) {
        warn "Cannot load LWP::Protocol::socks, ignore socks proxy...\n";
        return;
    }
}

# stale code
sub foo {
    my %hash;

    my $max = 50;
    my $string;
    warn Dumper( \%hash ) if $debug >= 3;
    my %hash2;
    my $counter;
    my $ua;
    my $url;

    while (<>) {
        chomp;
        next if /^\s*#/;

        my $coords = $_;
        if (/\t/) {
            $coords =~ s/^[^\t]*\t\S+\s+//;
        }

        foreach my $c ( split( / /, $coords ) ) {
            my ( $lng, $lat ) = split( /,/, $c );

            my $coord = &padding($lng) . "," . &padding($lat);
            if ( exists $hash{$coord} ) {
                warn "$coord already exists\n" if $debug >= 2;
                next;
            }
            if ( exists $hash2{$coord} ) {
                warn "$coord already parsed\n" if $debug >= 2;
                next;
            }
            $hash2{$coord} = 1;

            $string .= "|" if $string;
            $string .= "$lat,$lng";

            $counter++;
            if ( $counter == $max ) {
                &download( $ua, "$url$string" );
                $string  = "";
                $counter = 0;
            }
        }
    }
}

sub parse_hoehe {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        my ( $elevation, $x, $lnglat ) = split();
        $hash->{$lnglat} = $elevation;
    }

    return $hash;
}

sub parse_streets {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        s/^[^\t]*\t\S+\s+//;

        my @points = split;
        foreach my $point (@points) {
            if ( exists $hash->{$point} ) {
                $hash->{$point}++;
            }
            else {
                $hash->{$point} = 1;
            }
        }

    }
    return $hash;
}

sub update_city {
    my %args = @_;
    my $city = $args{'city'};
    my $ua   = $args{'ua'};
    my $hash = $args{'database'};

    my $dir = "$data_osm_dir/$city";

    my $height  = &parse_hoehe("$dir/hoehe");
    my $corners = &parse_streets("$dir/strassen");

    #while ( my ( $key, $val ) = each %$height ) { print "$key: $val\n"; }

    print Dumper($corners);
}

######################################################################
# main
#

my $help;
GetOptions(
    "help"              => \$help,
    "debug=i"           => \$debug,
    "database=s"        => \$database,
    "socksproxy=s"      => \$socksproxy,
    "readonly-database" => \$readonly_database,
    "data-osm-dir=s"    => \$data_osm_dir,
) or usage;

&usage if $help;

my @cities = @ARGV;
&usage("Missing the cities!\n") if !@cities;

my $ua = LWP::UserAgent->new;
$ua->agent("BBBike @ World - http://bbbike.org");
activate_socksproxy($ua) if $socksproxy;

my $hash;
foreach my $city (@cities) {
    &update_city( 'city' => $city, 'ua' => $ua, 'database' => $hash );
}

# run the rest
#&download( $ua, "$url$string" ) if $string;

