#!/usr/local/bin/perl
# Copyright (c) 2009-2011 Wolfram Schneider, http://bbbike.org
#
# munin-routes - munin statistics for BBBike, searches per interval

use Getopt::Long;
use Data::Dumper;
use File::stat;
use IO::File;

use strict;
use warnings;

#binmode \*STDIN,  ":utf8";
#binmode \*STDOUT, ":utf8";

my $debug    = 0;                              # 0: quiet, 1: normal, 2: verbose
my $database = '/var/tmp/munin-bbbike';
my $logfile  = '/var/log/lighttpd/bbbike.log';
my $type     = 'route';

my $config = {
    'ajax' => [
        qw/api street_coord crossing maptype weather slippymap location livesearch/
    ],
    'output' => [qw/print gpx-track gpx-route kml-track pdf/],
};

sub usage {
    my $types = join " | ", &get_types;

    <<EOF;
usage: $0 [--debug={0..2}] config

--debug=0..2    		default: $debug
--logfile=/path/to/logfile	default: $logfile
--database=/path/to/logfile	default: $database
--type=<stat type		$types, default: $type
EOF
}

sub get_types {
    my @types = qw/ajax route output/;
    return sort @types;
}

sub config_routes () {
    <<EOF;
graph_title Route Searches
graph_vlabel Searches
graph_category BBBike
graph_info Number of Route Searches
data.label Route Searches
EOF
}

sub config_ajax () {
    my $data = <<EOF;
graph_title Ajax
graph_vlabel Ajax Requests
graph_category BBBike
graph_info Number of Ajax Requests
EOF

    foreach my $s ( sort @{ $config->{'ajax'} } ) {
        $data .= "$s.label $s\n";
        $data .= "$s.min 0\n";
    }

    return $data;
}

sub config_output () {
    my $data = <<EOF;
graph_title Oputput Formats
graph_vlabel Oputput Formats
graph_category BBBike
graph_info Number of Oputput Formats
EOF

    foreach my $s ( sort @{ $config->{'output'} } ) {
        $data .= "$s.label $s\n";
        $data .= "$s.min 0\n";
    }

    return $data;
}

sub config {
    my $type = shift;

    return
        $type eq 'ajax'  ? &config_ajax
      : $type eq 'route' ? &config_routes
      :                    die "Unknown stat type: $type\n";
}

sub parse_log {
    my %args = @_;

    my $logfile  = $args{'logfile'};
    my $type     = $args{'type'};
    my $database = $args{'database'};
    $database .= "-$<-$type.txt";

    my $st = stat($logfile) or die "stat $logfile: $!";
    my $offset = $st->size;

    # first run, save file offset of logfile, do nothing
    if ( !-e $database ) {
        write_offset( $database, $offset );
        return;
    }

    my $last_offset = get_offset($database);

    my $data = "";
    if ( $type eq 'route' ) {
        my $route_count = count_routes(
            'logfile' => $logfile,
            'offset'  => $last_offset,
            'type'    => $type
        );

        $data = qq{data.value $route_count\n};
    }
    elsif ( $type eq 'ajax' ) {
        my $count = count_ajax(
            'logfile' => $logfile,
            'offset'  => $last_offset,
            'type'    => $type,
            'scripts' => $config->{'ajax'}
        );

        foreach my $script ( sort @{ $config->{'ajax'} } ) {
            my $s = $script;
            $s =~ s/_/-/g;    # street_coord -> street-coord

            $data .= "$script.value "
              . ( exists $count->{$s} ? $count->{$s} : 0 ) . "\n";
        }
    }
    elsif ( $type eq 'output' ) {
        my $count = count_output(
            'logfile' => $logfile,
            'offset'  => $last_offset,
            'type'    => $type,
            'output'  => $config->{'output'}
        );

        foreach my $output ( sort @{ $config->{'output'} } ) {
            $data .= "$output.value "
              . ( exists $count->{$output} ? $count->{$output} : 0 ) . "\n";
        }
    }
    else {
        die "Unknown type: $type\n";
    }

    # store current log file size in database for next run
    $st = stat($logfile) or die "stat $logfile: $!";
    write_offset( $database, $st->size );

    return $data;
}

sub get_offset {
    my $file = shift;

    my $fh = IO::File->new( $file, "r" ) or die "open $file: $!\n";
    my $number = <$fh>;

    chomp($number);

    warn "Got offset $number from $file\n" if $debug;
    return $number;
}

sub write_offset {
    my $file   = shift;
    my $offset = shift;

    warn "Store offset $offset in $file\n" if $debug;
    my $fh = IO::File->new( $file, "w" ) or die "open $file: $!\n";
    print $fh $offset;
    $fh->close;
}

#
# parse the bbbike access log file and count route
# searches (parameters startc, zielc, pref_seen)
#
sub count_routes {
    my %args   = @_;
    my $file   = $args{'logfile'};
    my $offset = $args{'offset'};

    my $counter = 0;
    my $fh = IO::File->new( $file, "r" ) or die "open $file: $!\n";

    if ( defined $offset ) {
        warn "Starting at offset: $offset\n" if $debug;
        seek( $fh, $offset, 0 );
    }

    while (<$fh>) {
        if ( /pref_seen=1/ && /startc=[0-9\-\+]/ && /zielc=[0-9\-\+]/ ) {
            $counter++;
        }
    }

    return $counter;
}

#
# parse the bbbike access log file and count ajax request
#
sub count_ajax {
    my %args   = @_;
    my $file   = $args{'logfile'};
    my $offset = $args{'offset'};

    my $counter = {};
    my $fh = IO::File->new( $file, "r" ) or die "open $file: $!\n";

    if ( defined $offset ) {
        warn "Starting at offset: $offset\n" if $debug;
        seek( $fh, $offset, 0 );
    }

    while (<$fh>) {
        if (m,"GET /cgi/(.*?)(\.cgi)?\?,) {
            $counter->{$1}++;
        }
        elsif (m,"POST /,) {
            if (   m,"POST /[A-Z][a-z]+\S+/ ,
                || m,"POST /[A-Z][a-z]+\S+/\?[a-z]+, )
            {
                $counter->{"pdf"}++;
            }

        }
    }

    return $counter;
}

#
# parse the bbbike access log file and count output
# requests (GPX, KML, print)
#
sub count_output {
    my %args   = @_;
    my $file   = $args{'logfile'};
    my $offset = $args{'offset'};

    my $counter = {};
    my $fh = IO::File->new( $file, "r" ) or die "open $file: $!\n";

    if ( defined $offset ) {
        warn "Starting at offset: $offset\n" if $debug;
        seek( $fh, $offset, 0 );
    }

# "GET /Erlangen/?startc=10.95985%2C49.58876;zielc=11.02811%2C49.57724;pref_seen=1;pref_speed=20;pref_cat=;pref_quality=;pref_specialvehicle=;scope=;output_as=print
    while (<$fh>) {
        if (m,"GET /\S+output_as=(.*?)[;&\s],) {
            $counter->{$1}++;
        }
    }

    return $counter;
}

######################################################################
# main
#

my $help;
GetOptions(
    "debug=i"    => \$debug,
    "database=s" => \$database,
    "logfile=s"  => \$logfile,
    "type=s"     => \$type,
    "help"       => \$help
) or die usage;

die usage if $help;
die "Unknown type '$type'\n\n" . &usage if !grep { $type eq $_ } &get_types;

if ( defined $ARGV[0] && $ARGV[0] eq 'config' ) {
    print &config($type);
}
else {
    my $text = &parse_log(
        'logfile'  => $logfile,
        'database' => $database,
        'type'     => $type
    );
    print $text if $text;
}

