#!/usr/local/bin/perl 
# Copyright (c) 2009-2011 Wolfram Schneider, http://bbbike.org
#
# bbbike-db - command line tool to parse bbbike @ world city database

use File::Basename;
use Data::Dumper;

use lib '.';
use lib './world/bin';
use lib '../bbbike/world/bin';
use lib '../..';
use BBBikeWorldDB;
use Strassen::Util;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = 0.1;

use Getopt::Long;

my $debug = 1;    # 0: quiet, 1: normal, 2: verbose
binmode \*STDOUT, ":utf8";
binmode \*STDERR, ":utf8";

sub osm_round {
    my $real    = shift;
    my $number  = shift || 100_000;
    my $padding = 1;

    # how many digits after the '.'
    my $counter = 0;
    for ( my $i = $number ; $i > 1 ; $i = $i / 10 ) {
        $counter++;
    }

    my $round = int( $real * $number + 0.5 ) / $number;

    if ($padding) {
        my $digits = $round;
        $digits =~ s/^\d*\.?//;

        warn "Digits: $digits\n" if $debug >= 2;

        # no digits at all
        $round .= '.' if !$digits;

        for ( my $i = length($digits) ; $i < $counter ; $i++ ) {
            $round .= '0';
        }
    }

    warn "$real <-> $round ", $real - $round, "\n"
      if $debug >= 2 && $real != $round;

    return $round;
}

sub poly {
    my ( $city, $x1, $y1, $x2, $y2 ) = @_;
    my $data = "";

    $data .= "$city\n";
    $data .= "1\n";

    $data .= "   $x1  $y1\n";
    $data .= "   $x2  $y1\n";
    $data .= "   $x2  $y2\n";
    $data .= "   $x1  $y2\n";

    $data .= "END\n";
    $data .= "END\n";

    return $data;
}

sub distance {
    my $a = shift;
    my $b = shift;

    my ( $x1, $y1, @rest )  = split( $", $a );
    my ( $x2, $y2, @rest2 ) = split( $", $b );

    my $distance = Strassen::Util::strecke_polar( [ $x1, $y1 ], [ $x2, $y2 ] );
    return int( $distance / 1_000 );
}

sub neighbours {
    my %args = @_;

    my $db   = $args{'db'};
    my $city = $args{'city'};

    my @list;

    my $coord = $db->{"_city"}->{$city}->{'coord'};
    foreach my $c ( keys %{ $db->{"_city"} } ) {
        push(
            @list,
            [
                &distance( $coord, $db->{"_city"}->{$c}->{'coord'} ), $c,
                $db->{"_city"}->{$c}->{'name'}
            ]
        );
    }

    @list = sort { $a->[0] <=> $b->[0] } @list;

    print Dumper( @list[ 0 .. 9 ] );
}

sub usage () {
    <<EOF;
usage: $0 [--debug={0..2}] [options] city

--debug=0..2	  debug option
--lang
--local-lang
--population
--neighbours
--coord
--poly
--centerdelta
--area=area
--city-by-lang=lang
--city-names
--step
--list
--city-database=/path/to/etc/cities.csv
EOF
}

my $lang;
my $local_lang;
my $step;
my $population;
my $coord;
my $poly;
my $centerdelta;
my $area;
my $city_by_lang;
my $list;
my $city_names;
my $city_database;
my $neighbours;

GetOptions(
    "debug=i"         => \$debug,
    "lang"            => \$lang,
    "local-lang"      => \$local_lang,
    "step"            => \$step,
    "city-names"      => \$city_names,
    "population"      => \$population,
    "neighbours"      => \$neighbours,
    "coord"           => \$coord,
    "poly"            => \$poly,
    "centerdelta"     => \$centerdelta,
    "area=s"          => \$area,
    "city-by-lang=s"  => \$city_by_lang,
    "list"            => \$list,
    "city-database=s" => \$city_database,
) or die usage;

my $city = shift;
die &usage if !( $city || $area || $city_by_lang || $list );

$city =~ s/-(convert|download)$// if $city;

my $database =
  $city_database ? $city_database : dirname( dirname($0) ) . "/etc/cities.csv";

my %hash;

my $db = BBBikeWorldDB->new( 'database' => $database );
%hash = %{ $db->city };

if ( defined $area ) {
    while ( my ( $key, $val ) = each %hash ) {
        print $key, "\n" if $hash{$key}->{area} eq $area;
    }
    exit 0;
}

if ( defined $city_by_lang || $list ) {
    while ( my ( $key, $val ) = each %hash ) {
        print $key, "\n"
          if $list
              || $city_by_lang eq 'any'
              || $hash{$key}->{lang} eq $city_by_lang;
    }
    exit 0;
}

if ( exists $hash{$city} ) {
    if ($lang) {
        print $hash{$city}->{lang} ? $hash{$city}->{lang} : "en";
        print " ";
    }
    elsif ($local_lang) {
        print $hash{$city}->{local_lang} ? $hash{$city}->{local_lang} : "en";
        print " ";
    }
    elsif ($city_names) {
        print $hash{$city}->{name} ? $hash{$city}->{name} : $city;
    }
    elsif ($coord) {
        my ( $x1, $y1, $x2, $y2 ) =
          map { &osm_round( $_, 100 ) } split( /\s+/, $hash{$city}->{coord} );
        print "$x1 $y1 $x2 $y2 ";
    }
    elsif ($poly) {
        my ( $x1, $y1, $x2, $y2 ) =
          map { &osm_round( $_, 100 ) } split( /\s+/, $hash{$city}->{coord} );
        print &poly( $city, ( $x1, $y1, $x2, $y2 ) );
    }
    elsif ($centerdelta) {
        my ( $x1, $y1, $x2, $y2 ) =
          map { &osm_round( $_, 100 ) } split( /\s+/, $hash{$city}->{coord} );
        print "$x1,$y1 ";
    }
    elsif ($population) {
        print $hash{$city}->{population}, "\n";
    }
    elsif ($neighbours) {
        print &neighbours( 'city' => $city, 'db' => $db );
    }
    elsif ($step) {
        print $hash{$city}->{step}, "\n";
    }

    else { warn "unknown directive\n"; die &usage; }
}
else {
    warn "Unknown city: $city\n";
    &usage;
}
